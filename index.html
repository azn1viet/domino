<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="description" content="Domino Game - Vietnamese Style">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Domino">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="logo.png">
  <meta name="theme-color" content="#444444">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="256x256" href="logo.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <title>Block Dominoes - Vietnamese Style</title>
  <style>
   :root {
    --tile-width: 30px; /* Updated to match tile width */
    --tile-height: 60px; /* Updated to match tile height */
    --tile-gap: 2px;
  }

  .player-south .tiles-container {
    max-width: calc(100vw - 20px); /* Fit within screen width with padding */
    z-index: 110; /* Higher z-index for Player South */
  }

  .player-north .tiles-container {
    max-width: calc(100vw - 20px);
    z-index: 100; /* Lower than South */
  }

  .player-east .tiles-container,
  .player-west .tiles-container {
    min-height: calc(100vh - 20px);
    z-index: 100; /* Lower than South */
  }

  .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    box-shadow: -2px 0 4px rgba(255, 255, 255, 0.5);
  }

  .tiles-container.overlapped.vertical > .tile:not(:first-child) {
    box-shadow: 0 -2px 4px rgba(255, 255, 255, 0.5);
  }

    * {
      box-sizing: border-box;
    }

    button,
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border: none;
      outline: none;
      background: #0f0;
      color: black;
      border-radius: 6px;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 14px;
      padding: 8px 15px;
      cursor: pointer;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: background 0.2s, transform 0.1s;
    }

    button:hover,
    select:hover {
      background: #0c0;
      transform: scale(1.05);
    }

    button:active,
    select:active {
      transform: scale(0.98);
    }

    select {
      background-image: linear-gradient(45deg, transparent 50%, black 50%),
                        linear-gradient(135deg, black 50%, transparent 50%);
      background-position: calc(100% - 15px) calc(50% - 4px),
                           calc(100% - 10px) calc(50% - 4px);
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 30px;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      background-color: #444;
      position: fixed;
      overflow: hidden;
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-weight: 400;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }

    #player-selection-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    #player-selection-modal.hidden {
      display: none;
    }

    .modal-content {
	 width: 95%;
      background: #333;
      padding: 30px;
      border-radius: 15px;
      border: 3px solid #0f0;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }

    .modal-content h2 {
      color: #0f0;
      margin: 0 0 20px 0;
      font-size: 24px;
    }

    .modal-content p {
      color: #add8e6;
      margin: 0 0 25px 0;
      font-size: 16px;
    }

    .player-options {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .player-option {
      background: #444;
      color: #fff;
      border: 2px solid #666;
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .player-option:hover {
      background: #555;
      border-color: #0f0;
      transform: scale(1.05);
    }

    .player-option.selected {
      background: #0f0;
      color: black;
      border-color: #0f0;
    }

    #game-container {
      position: absolute;
	  top: 0;
      left: 0;
    /*top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);*/
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      overflow: visible;
      pointer-events: none;
    }
	
#table {
  position: absolute;
  left: 50%;
  top: calc(50% - 50px);
  transform: translate(-50%, -50%);
  
  width: 80%;
  height: calc(100% - 260px);
  
  display: block;
  pointer-events: all;
}
    .player-hand {
      position: fixed;
      text-align: center;
      z-index: 100;
      padding: 5px;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
/*
 /* SOUTH ‚Äî score below tiles, near screen bottom edge */
.player-south {
 bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  flex-direction: column;
}
.player-south .score {
  position: absolute;
  bottom: 69px; /* move closer or further from bottom edge */
  left: 50%;
  transform: translateX(-50%);
}*/

.player-south {
  position: fixed;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100vw;
  height: 150px; /* fixed area for player hand */
  display: flex;
  justify-content: center;
  align-items: flex-end;
}

.player-south .tiles-container {
  position: absolute;
  bottom: 80px; /* your designed height above bottom */
  left: 50%;
  transform: translateX(-50%);
}

.player-south .score {
  position: absolute;
  bottom: 68px; /* below the tiles */
  left: 50%;
  transform: translateX(-50%);
}


/* NORTH ‚Äî score above tiles, near top edge */
.player-north {
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  flex-direction: column-reverse;
}
.player-north .score {
  position: absolute;
  top: -74px;
  left: 50%;
  transform: translateX(-50%);
}

/* EAST ‚Äî score on far right edge */
.player-east {
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  flex-direction: row;
}
.player-east .score {
  position: absolute;
  right: -55px; /* distance outside right edge */
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
}
/* WEST ‚Äî score on far left edge */
.player-west {
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  flex-direction: row-reverse;
}
.player-west .score {
  position: absolute;
  left: -55px;
  top: 50%;
  transform: translateY(-50%) rotate(90deg);
}

    .tiles-container {
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2px;
      min-height: 80px;
    }

 /*.player-south .tiles-container,*/
.player-north .tiles-container {
  max-width: calc(var(--tile-width) * 7 + var(--tile-gap) * 6);
  margin-top: 7px;
}

.player-east .tiles-container,
.player-west .tiles-container {
  flex-direction: column;
  min-height: calc(var(--tile-height) * 7 + var(--tile-gap) * 6);
  min-width: 40px;
}

  /*  .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    margin-left: -10px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .player-south .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    margin-left: -17.5px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .player-south .tiles-container.overlapped.horizontal.many-tiles > .tile:not(:first-child) {
    margin-left: -11.67px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .tiles-container.overlapped.vertical > .tile:not(:first-child) {
    margin-top: -20px;
    box-shadow: 0 -2px 4px rgba(255,255,255, 0.5);
  }
  */

    .tile {
      display: block;
     width: var(--tile-width);
     height: var(--tile-height);
      border: 2px solid black;
      cursor: pointer;
      border-radius: 8px;
      background-color: black;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }

    .tile svg,
    .table-tile svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .selected {
      border: 3px solid yellow;
      box-shadow: 0 0 10px yellow;
    }

    .draggable {
      border: 2px dashed #6a6a6a;
    }

    .table-tile {
      position: absolute;
      width: var(--tile-width);
      height: var(--tile-height);
      border: 2px solid #666;
      border-radius: 6px;
      background-color: #1a1a1a;
      z-index: 15;
      transition: border-color 0.3s;
    }

    .table-tile.horizontal {
      width: var(--tile-height);
      height: var(--tile-width);
    }

    .table-tile.match-drop::before,
    .table-tile.match-drop::after {
      border-style: dashed !important;
    }

    .table-tile.placeholder {
      z-index: 20;
      pointer-events: auto;
      background-color: transparent;
    }

    .table-tile.end-top::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-top: 2px solid #0ff;
      border-left: 2px solid #0ff;
      border-right: 2px solid #0ff;
      border-radius: 6px 6px 0 0;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-bottom::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-bottom: 2px solid #0ff;
      border-left: 2px solid #0ff;
      border-right: 2px solid #0ff;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-left::before {
      content: '';
      position: absolute;
      left: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-left: 2px solid #0ff;
      border-top: 2px solid #0ff;
      border-bottom: 2px solid #0ff;
      border-radius: 6px 0 0 6px;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-right::after {
      content: '';
      position: absolute;
      right: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-right: 2px solid #0ff;
      border-top: 2px solid #0ff;
      border-bottom: 2px solid #0ff;
      border-radius: 0 6px 6px 0;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.double-end-top::before,
    .table-tile.double-end-bottom::after,
    .table-tile.double-end-left::before,
    .table-tile.double-end-right::after {
      content: '';
      position: absolute;
      border: 2px solid #0ff;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.double-end-top::before {
      top: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-radius: 6px 6px 0 0;
    }

    .table-tile.double-end-bottom::after {
      bottom: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-radius: 0 0 6px 6px;
    }

    .table-tile.double-end-left::before {
      left: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-radius: 6px 0 0 6px;
    }

    .table-tile.double-end-right::after {
      right: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-radius: 0 6px 6px 0;
    }

    .tile:hover {
      border: 3px solid #0f0;
      box-shadow: 0 0 8px #0f0;
    }

    .score {
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      margin: 3px 0;
      z-index: 201;
      text-shadow: 0 0 5px #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 100px;
      pointer-events: none;
	  bottom: 2px;
    }

    .score-arrow {
      width: 25px;
      display: inline-block;
      text-align: center;
      color: #0f0;
    }

    .score-text {
      white-space: nowrap;
      margin-left: 10px;
      color: #0f0;
    }

    .score-number {
      position: relative;
      display: inline-block;
      margin-left: 50px;
    }

    .coins-container {
      position: absolute;
      z-index: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      height: 20px;
      pointer-events: none;
      display: flex;
      align-items: center;
    }

    .coins-container .coin {
      font-size: 18px;
      margin-left: -8px;
      opacity: 0.5;
    }

    .coins-container .coin:first-child {
      margin-left: 0;
    }

    .coins-container.yellow .coin {
      filter: none;
    }

    .coins-container.violet .coin {
      filter: brightness(0) saturate(100%) invert(69%) sepia(23%) saturate(1988%) hue-rotate(248deg) brightness(104%) contrast(87%);
    }

    .coins-container.orange .coin {
      filter: brightness(0) saturate(50%) invert(52%) sepia(50%) saturate(1120%) hue-rotate(6deg) brightness(50%) contrast(97%);
    }

    .coins-container.red .coin {
      filter: brightness(0) saturate(100%) invert(35%) sepia(71%) saturate(6921%) hue-rotate(350deg) brightness(88%) contrast(133%);
    }

    .coins-container.silver .coin {
      filter: brightness(0) saturate(100%) invert(88%) sepia(3%) saturate(0%) hue-rotate(193deg) brightness(95%) contrast(90%);
    }

    .play-buttons {
      margin-top: 35px;
      display: flex;
      gap: 5px;
      justify-content: center;
      align-items: center;
      min-height: 40px;
      pointer-events: auto;
    }

    .play-buttons button {
      padding: 6px 10px;
      background: #0f0;
      color: black;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      display: none;
	  flex: 0 0 auto; /* don‚Äôt shrink */
	  white-space: nowrap;
    }

    .play-buttons button:hover {
      background: #0c0;
      transform: scale(1.05);
    }

    #new-game {
      position: fixed;
      bottom: -6px;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 3px 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #0f0;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      z-index: 999;
      font-size: 18px;
      font-weight: bold;
    }

    #new-game:hover {
      background: #090;
    }

    #bets {
      position: fixed;
      bottom: 10px;
      right: 3px;
      z-index: 100;
      background: #444;
      color: #add8e6;
      border: 1px solid #0f0;
      padding: 5px;
      font-size: 14px;
    }

    .table-tile.first-double {
      border: 2px solid #0ff !important;
      box-shadow: 0 0 10px #0ff !important;
    }

#options-button:active {
  transform: scale(0.95); /* Immediate visual feedback */
  background: #0a0;
}

#options-button {
  position: fixed;
  bottom: 10px;
  left: 3px;
  z-index: 100;
  background: #444;
  color: #add8e6;
  border: 1px solid #0f0;
  padding: 5px;
  font-size: 14px;
  cursor: pointer;
  touch-action: manipulation;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  pointer-events: auto;
  transition: all 0.1s ease; /* Smooth transition */
}

    #options-button:hover {
      background: #0c0;
      transform: scale(1.05);
    }


    #options-menu {
      position: fixed;
      bottom: 50px;
      left: 10px;
      background: #444;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 10px;
      z-index: 201;
      display: none;
      color: #add8e6;
      font-size: 12px;
      pointer-events: auto;
    }

    #options-menu select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: #333;
      color: #add8e6;
      border: 1px solid #0f0;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 12px;
      line-height: 1.4;
      outline: none;
      cursor: pointer;
      width: auto;
      background-image: none;
      box-shadow: none;
    }

    #options-menu select:focus {
      border-color: #0c0;
      outline: none;
    }

    #options-menu label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0;
    }

    .close-btn {
      position: absolute;
      top: -4px;
      right: 2px;
      cursor: pointer;
      color: #0f0;
      font-size: 18px;
      font-weight: bold;
      transition: 0.2s ease;
    }

    .close-btn:hover {
      color: #fff;
      transform: scale(1.2);
    }

    #boneyard {
      position: fixed;
      top: 1px;
      left: 1px;
      padding: 1px;
      display: none;
    }

    #installBtn {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.5);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      z-index: 9999;
      display: none;
      box-shadow: 0 0 10px #0f08;
    }
  </style>
</head>
<body>
  <div id="player-selection-modal">
    <div class="modal-content">
      <h2>Welcome to Block Dominoes!</h2>
      <p>Select number of players to start:</p>
      <div class="player-options">
        <button class="player-option selected" data-players="2">2 Players</button>
        <button class="player-option" data-players="3">3 Players</button>
        <button class="player-option" data-players="4">4 Players</button>
      </div>
      <button id="start-game-btn" style="background: #0f0; color: black; padding: 12px 30px; font-size: 16px;">Start Game</button>
    </div>
  </div>

  <button id="installBtn">üì≤ Install App</button>

  <div id="game-container">
    <div id="table"></div>
  </div>
  <button id="new-game">New Game</button>
  <div id="players">
    <div class="player-hand player-south" data-player="0"></div>
    <div class="player-hand player-east" data-player="1"></div>
    <div class="player-hand player-north" data-player="2"></div>
    <div class="player-hand player-west" data-player="3"></div>
  </div>
  <div id="boneyard">
    <div id="boneyard-tiles" style="display: grid; grid-template-columns: repeat(7, auto); gap: 1px;"></div>
  </div>
  <button id="options-button">Options</button>

  <div id="options-menu">
    <span id="close-options" class="close-btn">&times;</span>
    <label>Players
      <select id="numPlayers">
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4" selected>4</option>
      </select>
    </label>
    <label>Tile Mode
      <select id="tileMode">
        <option value="Open">Open</option>
        <option value="Close" selected>Close</option>
      </select>
    </label>
    <label>Background Color
      <select id="backgroundColor">
        <option value="white">White</option>
        <option value="olive">Olive</option>
        <option value="teal">Teal</option>
        <option value="indigo">Indigo</option>
        <option value="gold">Gold</option>
        <option value="#444" selected>Grey</option>
      </select>
    </label>
    <label>Sound
      <select id="sound">
        <option value="On" selected>On</option>
        <option value="Off">Off</option>
      </select>
    </label>
    <label>Fun Voice
      <select id="funVoice">
        <option value="On">On</option>
        <option value="Off" selected>Off</option>
      </select>
    </label>
  </div>
  <select id="bets">
    <option value="1000">1000</option>
    <option value="10000" selected>10000</option>
    <option value="50000">50000</option>
    <option value="100000">100000</option>
    <option value="500000">500000</option>
    <option value="1000000">1000000</option>
  </select>
  <div style="position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%); color: #ccc; font-size: 14px; opacity: 0.8; pointer-events: none;">Version 3.1.2</div>

<script>
  // PWA Install Script
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'block';
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const choice = await deferredPrompt.userChoice;
      if (choice.outcome === 'accepted') {
        installBtn.style.display = 'none';
        localStorage.setItem('pwaInstalled', 'true');
      }
      deferredPrompt = null;
    });

    window.addEventListener('appinstalled', () => {
      installBtn.style.display = 'none';
      localStorage.setItem('pwaInstalled', 'true');
    });

    if (!localStorage.getItem('pwaInstalled')) {
      navigator.serviceWorker.getRegistrations().then(regs => regs.forEach(r => r.unregister()));
      caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
    }

    document.addEventListener('click', () => {
      if (!deferredPrompt && installBtn.style.display === 'none') {
        setTimeout(() => {
          if (deferredPrompt) installBtn.style.display = 'block';
        }, 1000);
      }
    });
  </script>

<script>
// Additional: Ensure bets is enabled initially (before first game start)
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('bets').disabled = false; // Enabled before any game starts
});
</script>

<script>
    // Game Variables
    let audioContext = null;
    let canPlaySound = true;
    let soundLocked = false;
    let funVoice = false;
    let tileMode = 'Close';
    let backgroundColor = '#444';
    let bet = 10000;
    let isOverallFirstGame = true;
    let draggedTile = null;
    let numPlayersVar = 4;
    let gameState = null;
    let currentActivePlayerTurn = 0;
    let nextGameStarter = 0;
    let lastValidPlayer = 0;
    // Updated global variables and initialization
let scores = [10000000, 10000000, 10000000, 10000000];

// Load persisted data from localStorage
const storedScores = localStorage.getItem('dominoScores');
if (storedScores) {
  scores = JSON.parse(storedScores);
}
const storedBet = localStorage.getItem('dominoBet');
if (storedBet) {
  bet = parseInt(storedBet, 10);
}
document.getElementById('bets').value = bet; // Sync select with loaded bet
// Updated bets change listener
document.getElementById('bets').addEventListener('change', function(e) {
  if (gameState && !gameState.gameOver) {
    alert('Cannot change bet during game!');
    e.target.value = bet; // Revert to previous bet value
    return;
  }
  bet = parseInt(e.target.value, 10);
  localStorage.setItem('dominoBet', bet);
});

    const tiles = [
      {top: 6, bottom: 6}, {top: 6, bottom: 5}, {top: 6, bottom: 4}, {top: 6, bottom: 3}, {top: 6, bottom: 2}, {top: 6, bottom: 1}, {top: 6, bottom: 0},
      {top: 5, bottom: 5}, {top: 5, bottom: 4}, {top: 5, bottom: 3}, {top: 5, bottom: 2}, {top: 5, bottom: 1}, {top: 5, bottom: 0},
      {top: 4, bottom: 4}, {top: 4, bottom: 3}, {top: 4, bottom: 2}, {top: 4, bottom: 1}, {top: 4, bottom: 0},
      {top: 3, bottom: 3}, {top: 3, bottom: 2}, {top: 3, bottom: 1}, {top: 3, bottom: 0},
      {top: 2, bottom: 2}, {top: 2, bottom: 1}, {top: 2, bottom: 0},
      {top: 1, bottom: 1}, {top: 1, bottom: 0},
      {top: 0, bottom: 0}
    ];

    const numTiles = 7;

// Player Selection Modal Logic
const modal = document.getElementById('player-selection-modal');
const playerOptions = document.querySelectorAll('.player-option');
const startGameBtn = document.getElementById('start-game-btn');

// Initialize selectedPlayers from any option already marked `.selected` in markup,
// otherwise fall back to 4 (or whatever default you want).
let selectedPlayers = (() => {
  const pre = document.querySelector('.player-option.selected');
  return pre ? parseInt(pre.dataset.players, 10) : 4;
})();

// Click handler for options ‚Äî keeps selectedPlayers in sync with UI
playerOptions.forEach(option => {
  option.addEventListener('click', () => {
    playerOptions.forEach(opt => opt.classList.remove('selected'));
    option.classList.add('selected');

    // parseInt with radix and guard fallback
    const n = parseInt(option.dataset.players, 10);
    selectedPlayers = Number.isFinite(n) ? n : 4;
  });
});


    startGameBtn.addEventListener('click', () => {
      numPlayersVar = selectedPlayers;
      document.getElementById('numPlayers').value = numPlayersVar;
      modal.classList.add('hidden');
      initAudioContext();
      startNewGame();
    });

    // Helper Functions
    function abbreviate(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      else if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      else if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      else return num.toString();
    }

    function formatPayout(amount) {
      return abbreviate(Math.abs(amount)) + (amount < 0 ? ' loss' : ' gain');
    }

    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
    }

    function playSound() {
      if (!canPlaySound) return;
      initAudioContext();
      let oscillator = audioContext.createOscillator();
      let gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.value = 523.25;
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function generateBackTileSvg(isHorizontal) {
      let svg;
      if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
      } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
      }
      svg += "</svg>";
      return svg;
    }

    function generateTileSvg(isHorizontal, tileData) {
      const colors = ["", "red", "gold", "white", "red", "seagreen", "white"];
      let svg;
      if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
        const { top, bottom } = tileData;
        if (top > 0) {
          svg += `<g class='dots' fill='${colors[top]}'>`;
          const tops = {
            1: "<circle cx='25' cy='20' r='5' />",
            2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
            3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
            4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
          };
          svg += tops[top] + "</g>";
        }
        if (bottom > 0) {
          svg += `<g class='dots' fill='${colors[bottom]}'>`;
          const bottoms = {
            1: "<circle cx='25' cy='80' r='5' />",
            2: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='85' r='5' />",
            3: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='85' r='5' />",
            4: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
            5: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
            6: "<circle cx='15' cy='65' r='5' /><circle cx='15' cy='77' r='5' /><circle cx='15' cy='89' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='35' cy='77' r='5' /><circle cx='35' cy='89' r='5' />"
          };
          svg += bottoms[bottom] + "</g>";
        }
        svg += "<line x1='0' y1='50%' x2='100%' y2='50%' stroke='#666' stroke-width='2' />";
      } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
        const { left, right } = tileData;
        svg += "<line x1='50%' y1='0' x2='50%' y2='100%' stroke='#666' stroke-width='2' />";
        if (left > 0) {
          svg += `<g class='dots' fill='${colors[left]}'>`;
          const leftPatterns = {
            1: "<circle cx='25' cy='20' r='5' />",
            2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
            3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
            4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
          };
          svg += leftPatterns[left] + "</g>";
        }
        if (right > 0) {
          svg += `<g class='dots' fill='${colors[right]}'>`;
          const rightPatterns = {
            1: "<circle cx='75' cy='30' r='5' />",
            2: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='35' r='5' />",
            3: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='35' r='5' />",
            4: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
            5: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
            6: "<circle cx='65' cy='15' r='5' /><circle cx='65' cy='27' r='5' /><circle cx='65' cy='39' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='85' cy='27' r='5' /><circle cx='85' cy='39' r='5' />"
          };
          svg += rightPatterns[right] + "</g>";
        }
      }
      svg += "</svg>";
      return svg;
    }

    function getTileSizes() {
      const rootStyle = getComputedStyle(document.documentElement);
      const tw = parseFloat(rootStyle.getPropertyValue('--tile-width'));
      const th = parseFloat(rootStyle.getPropertyValue('--tile-height'));
      return { V_W: tw, V_H: th, H_W: th, H_H: tw, FULL: th, OFFSET: th / 4 };
    }

    function isDouble(tile) {
      return tile.top === tile.bottom;
    }

    function canPlayTile(tile, board) {
      if (!board.leftEnd) return true;
      const leftEnd = board.leftEnd.value;
      const rightEnd = board.rightEnd.value;
      return tile.top === leftEnd || tile.bottom === leftEnd || tile.top === rightEnd || tile.bottom === rightEnd;
    }

    function canPlayOnEnd(tile, endValue) {
      return tile.top === endValue || tile.bottom === endValue;
    }

    function getPlayerNumber(index) {
      return index + 1;
    }

    function rotateTile(tile) {
      return { top: tile.bottom, bottom: tile.top };
    }

    function setupGame() {
      const gameTiles = [...tiles];
      shuffle(gameTiles);
      let players = Array(4).fill().map(() => []);
      let boneyard = [];
      let playerOrder = numPlayersVar === 2 ? [0, 2] : numPlayersVar === 3 ? [0, 1, 2] : [0, 1, 2, 3];
      
      for (let p of playerOrder) {
        players[p] = gameTiles.splice(0, numTiles);
      }
      boneyard = gameTiles;

      const board = {
        tiles: [],
        leftEnd: null,
        rightEnd: null,
        offsetX: 0,
        offsetY: 0
      };

      let highestDouble = null;
      let starter = 0;
      for (let p of playerOrder) {
        const doubles = players[p].filter(t => isDouble(t));
        if (doubles.length > 0) {
          const playerHighest = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
          if (!highestDouble || playerHighest.top > highestDouble.top) {
            highestDouble = playerHighest;
            starter = p;
          }
        }
      }

      const isThisFirstGame = isOverallFirstGame;
      if (isThisFirstGame) {
        currentActivePlayerTurn = starter;
        isOverallFirstGame = false;
      } else {
        currentActivePlayerTurn = nextGameStarter;
      }

      const roundHistory = [];

      return {
        players, 
        boneyard, 
        board, 
        prevBoard: null, 
        gameOver: false, 
        roundHistory, 
        selectedIndex: -1, 
        isThisFirstGame, 
        playerOrder, 
        highestDouble
      };
    }

// Updated startNewGame function (remove scores reset to persist previous scores)
function startNewGame() {
  isOverallFirstGame = true;
  currentActivePlayerTurn = 0;
  nextGameStarter = 0;
  lastValidPlayer = 0;
  // Removed: scores = [10000000, 10000000, 10000000, 10000000]; // Persist previous scores
  
  document.getElementById('new-game').style.display = 'none';
  gameState = setupGame();
  renderGame(gameState);
  
  if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
    setTimeout(() => playAI(gameState), 1500);
  }
}

    document.getElementById('close-options').addEventListener('click', () => {
      document.getElementById('options-menu').style.display = 'none';
    });

// Options button - immediate response
const optionsButton = document.getElementById('options-button');
const optionsMenu = document.getElementById('options-menu');

optionsButton.addEventListener('click', (e) => {
  e.stopPropagation();
  
  // Toggle menu immediately
  const isHidden = optionsMenu.style.display === 'none' || optionsMenu.style.display === '';
  optionsMenu.style.display = isHidden ? 'block' : 'none';
  
  // Visual feedback
  optionsButton.style.transform = 'scale(0.95)';
  setTimeout(() => {
    optionsButton.style.transform = 'scale(1)';
  }, 100);
});

// Close button
document.getElementById('close-options').addEventListener('click', (e) => {
  e.stopPropagation();
  optionsMenu.style.display = 'none';
});

// Close menu when clicking outside
document.addEventListener('click', (e) => {
  if (optionsMenu.style.display === 'block' && 
      !optionsMenu.contains(e.target) && 
      !optionsButton.contains(e.target)) {
    optionsMenu.style.display = 'none';
  }
});
    document.getElementById('numPlayers').onchange = (e) => {
      numPlayersVar = parseInt(e.target.value);
      startNewGame();
      document.getElementById('options-menu').style.display = 'none';
    };

    document.getElementById('tileMode').onchange = (e) => {
      tileMode = e.target.value;
      if (gameState) renderGame(gameState);
    };

    document.getElementById('backgroundColor').onchange = (e) => {
      backgroundColor = e.target.value;
      document.body.style.background = backgroundColor;
      if (backgroundColor === '#444') {
        document.body.style.color = '#fff';
      } else {
        document.body.style.color = '#000';
      }
    };

    document.getElementById('funVoice').onchange = (e) => {
      funVoice = e.target.value === 'On';
    };

    document.getElementById('sound').addEventListener('change', (e) => {
      if (e.target.value === 'Off') {
        canPlaySound = false;
        soundLocked = true;
      } else {
        canPlaySound = true;
        soundLocked = false;
      }
    });
///
    function calculatePlacement(board, end, tableRect, tile) {
      const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();
      const MARGIN = 0;

      let e = board[end === 'left' ? 'leftEnd' : 'rightEnd'];
      let isLeftChain = end === 'left';
      let turnDir = isLeftChain ? 'up' : 'down';

      let p = {};
      let hdir = e.dir;
      let isDoubleTile = isDouble(tile);
      let tryVerticalFirst = false;

      if (board.forceHorizontalNext) {
        tryVerticalFirst = false;
        board.forceHorizontalNext = false;
      } else {
        if (isDoubleTile && !e.isVertical) {
          const nearLeftEdge = e.x - FULL * 1.5 < MARGIN + FULL * 2;
          const nearRightEdge = e.x + FULL * 2.5 > tableRect.width - (MARGIN + FULL * 2);
          if ((isLeftChain && nearLeftEdge) || (!isLeftChain && nearRightEdge)) {
            tryVerticalFirst = true;
          }
        }
      }

      if (tryVerticalFirst) {
        if (turnDir === 'up') {
          p.x = e.x - OFFSET;
          p.y = e.y - (FULL + OFFSET);
          p.nextEndX = p.x + OFFSET;
          p.nextEndY = p.y + OFFSET;
        } else {
          p.x = e.x - OFFSET;
          p.y = e.y + OFFSET;
          p.nextEndX = p.x + OFFSET;
          p.nextEndY = p.y + FULL - OFFSET;
        }
        p.isHorizontal = false;
        p.isVertical = true;
        p.width = V_W;
        p.height = V_H;

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        p.boundCheck = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                        v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (!p.boundCheck) {
          let newHdir = hdir === 'left' ? 'right' : 'left';
          p.newHdir = newHdir;
          p.turnDir = turnDir;
          const nearLeftEdge = v_eff_x - FULL * 1.5 < MARGIN + FULL * 2;
          const nearRightEdge = v_eff_x + FULL * 2.5 > tableRect.width - (MARGIN + FULL * 2);
          if (nearLeftEdge || nearRightEdge) {
            board.forceHorizontalNext = true;
          }
          return p;
        }
      }

      if (hdir === 'left') {
        p.x = e.x - (FULL + OFFSET);
        p.nextEndX = p.x + OFFSET;
      } else {
        p.x = e.x + OFFSET;
        p.nextEndX = p.x + FULL - OFFSET;
      }
      p.y = e.y - OFFSET;
      p.isHorizontal = true;
      p.isVertical = false;
      p.width = H_W;
      p.height = H_H;
      p.nextEndY = p.y + OFFSET;

      const eff_x = p.x + board.offsetX;
      const eff_y = p.y + board.offsetY;
      p.boundCheck = (eff_x < MARGIN || eff_x + p.width > tableRect.width - MARGIN ||
                      eff_y < MARGIN || eff_y + p.height > tableRect.height - MARGIN);

      if (!p.boundCheck) {
        return p;
      } else {
        if (turnDir === 'up') {
          p.y = e.y - (FULL + OFFSET);
          p.nextEndY = p.y + OFFSET;
        } else {
          p.y = e.y + OFFSET;
          p.nextEndY = p.y + FULL - OFFSET;
        }
        p.x = e.x - OFFSET;
        p.isHorizontal = false;
        p.isVertical = true;
        p.width = V_W;
        p.height = V_H;
        p.nextEndX = p.x + OFFSET;

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        let v_bound = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                       v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (v_bound) {
          let shiftX = 0, shiftY = 0;
          if (v_eff_x < MARGIN) shiftX = MARGIN - v_eff_x;
          else if (v_eff_x + p.width > tableRect.width - MARGIN)
            shiftX = (tableRect.width - MARGIN) - (v_eff_x + p.width);
          if (v_eff_y < MARGIN) shiftY = MARGIN - v_eff_y;
          else if (v_eff_y + p.height > tableRect.height - MARGIN)
            shiftY = (tableRect.height - MARGIN) - (v_eff_y + p.height);
          board.offsetX += shiftX;
          board.offsetY += shiftY;
        }

        let newHdir = hdir === 'left' ? 'right' : 'left';
        p.newHdir = newHdir;
        p.turnDir = turnDir;
        const nearLeftEdge = v_eff_x - FULL * 1.5 < MARGIN + FULL * 2;
        const nearRightEdge = v_eff_x + FULL * 2.5 > tableRect.width - (MARGIN + FULL * 2);
        if (nearLeftEdge || nearRightEdge) {
          board.forceHorizontalNext = true;
        }
        return p;
      }
    }

///
function computePlayerValues(players) {
  const values = [];
  
  // Count zeros on the table (from played tiles)
  let zerosOnTable = 0;
  if (gameState && gameState.roundHistory) {
    for (let move of gameState.roundHistory) {
      const tile = move.playedTile;
      if (tile.top === 0) zerosOnTable++;
      if (tile.bottom === 0) zerosOnTable++;
    }
  }
  
  // If 6 zeros visible, the 7th zero is in [0-0] ‚Üí value = 13
  // Otherwise [0-0] = 0
  const doubleZeroValue = (zerosOnTable >= 6) ? 13 : 0;
  
  for (let p = 0; p < 4; p++) {
    let sum = 0;
    for (let tile of players[p]) {
      let pips = tile.top + tile.bottom;
      
      // Special case: [0-0]
      if (pips === 0) {
        pips = doubleZeroValue;
      }
      
      sum += pips;
    }
    values[p] = sum;
  }
  
  return values;
}
///

    function simulatePlay(board, tile, end) {
      if (!board.leftEnd) {
        return {
          leftEnd: { value: tile.top },
          rightEnd: { value: tile.bottom }
        };
      }

      let simLeftEnd = { ...board.leftEnd };
      let simRightEnd = { ...board.rightEnd };
      if (end === 'left') {
        const oldValue = simLeftEnd.value;
        if (tile.top === oldValue) {
          simLeftEnd.value = tile.bottom;
        } else {
          simLeftEnd.value = tile.top;
        }
      } else {
        const oldValue = simRightEnd.value;
        if (tile.top === oldValue) {
          simRightEnd.value = tile.bottom;
        } else {
          simRightEnd.value = tile.top;
        }
      }
      return { leftEnd: simLeftEnd, rightEnd: simRightEnd };
    }
	
    function isPlayableForAnyone(players, boneyard, board, playerOrder) {
      if (!board.leftEnd) return true;
      for (const p of playerOrder) {
        if (players[p].some(tile => canPlayTile(tile, board))) {
          return true;
        }
      }
      if (boneyard.length === 0) return false;
      const left = board.leftEnd.value;
      const right = board.rightEnd.value;
      return boneyard.some(tile => tile.top === left || tile.bottom === left || tile.top === right || tile.bottom === right);
    }

    function countAllPips(players, roundHistory) {
      const counts = [0, 0, 0, 0, 0, 0, 0];
      const allKnownTiles = [];
      allKnownTiles.push(...players[currentActivePlayerTurn]);
      if (roundHistory) {
        for (const move of roundHistory) {
          allKnownTiles.push(move.playedTile);
        }
      }
      for (const tile of allKnownTiles) {
        counts[tile.top]++;
        counts[tile.bottom]++;
      }
      return counts;
    }

    function getValidMoves(hand, board) {
      const validMoves = [];
      if (!board.leftEnd) {
        hand.forEach(tile => validMoves.push({ tile, end: 'right' }));
      } else {
        hand.forEach(tile => {
          const canLeft = canPlayOnEnd(tile, board.leftEnd.value);
          const canRight = canPlayOnEnd(tile, board.rightEnd.value);
          if (canLeft) {
            validMoves.push({ tile, end: 'left' });
          }
          if (canRight) {
            if (!isDouble(tile) || !canLeft) {
              validMoves.push({ tile, end: 'right' });
            }
          }
        });
      }
      return validMoves;
    }

    function drawUntilMatch(gameState, player) {
      const { players, board, boneyard } = gameState;
      const hand = players[player];
      while (boneyard.length > 0 && getValidMoves(hand, board).length === 0) {
        const idx = Math.floor(Math.random() * boneyard.length);
        const drawn = boneyard.splice(idx, 1)[0];
        hand.push(drawn);
      }
      if (player === 0 && hand.length > 0) {
        const lastDrawn = hand[hand.length - 1];
        if (canPlayTile(lastDrawn, board)) {
          gameState.selectedIndex = hand.length - 1;
        }
      }
    }

    function isInevitableBlock(board, players, boneyard, currentActivePlayerTurn, depth, maxDepth, playerOrder) {
      if (!board.leftEnd) return false;
      if (depth > maxDepth) return false;
      if (!isPlayableForAnyone(players, boneyard, board, playerOrder)) {
        return true;
      }

      const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
      const nextPlayer = playerOrder[nextPlayerIndex];
      const nextHand = players[nextPlayer];
      const validMoves = getValidMoves(nextHand, board);
      if (validMoves.length === 0) {
        return isInevitableBlock(board, players, boneyard, nextPlayer, depth + 1, maxDepth, playerOrder);
      }

      let allLeadToBlock = true;
      for (const move of validMoves) {
        const simBoard = simulatePlay(board, move.tile, move.end);
        const simPlayers = JSON.parse(JSON.stringify(players));
        const tileIdx = simPlayers[nextPlayer].findIndex(t => t.top === move.tile.top && t.bottom === move.tile.bottom);
        simPlayers[nextPlayer].splice(tileIdx, 1);
        if (simPlayers[nextPlayer].length === 0) {
          allLeadToBlock = false;
          break;
        }
        if (!isInevitableBlock(simBoard, simPlayers, boneyard, nextPlayer, depth + 1, maxDepth, playerOrder)) {
          allLeadToBlock = false;
          break;
        }
      }
      return allLeadToBlock;
    }

    function hasPreventingAlternative(hand, board, allPlayers, playerIndex, maxDepth = 0) {
      if (!board.leftEnd) return false;

      const playableTiles = hand.filter(tile => canPlayTile(tile, board));
      if (playableTiles.length < 1) return false;

      let hasNonBlockingMove = false;

      for (const tile of playableTiles) {
        const canPlayLeft = canPlayOnEnd(tile, board.leftEnd.value);
        const canPlayRight = canPlayOnEnd(tile, board.rightEnd.value);

        if (canPlayLeft) {
          const simBoard = simulatePlay(board, tile, 'left');
          const simPlayers = JSON.parse(JSON.stringify(allPlayers));
          const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
          simPlayers[playerIndex].splice(tileIdx, 1);
          if (!isInevitableBlock(simBoard, simPlayers, [], playerIndex, 1, maxDepth)) {
            hasNonBlockingMove = true;
            break;
          }
        }

        if (canPlayRight && (!isDouble(tile) || !canPlayLeft)) {
          const simBoard = simulatePlay(board, tile, 'right');
          const simPlayers = JSON.parse(JSON.stringify(allPlayers));
          const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
          simPlayers[playerIndex].splice(tileIdx, 1);
          if (!isInevitableBlock(simBoard, simPlayers, [], playerIndex, 1, maxDepth)) {
            hasNonBlockingMove = true;
            break;
          }
        }
      }

      const hasMultipleOptions = playableTiles.length > 1 ||
        (playableTiles.length === 1 &&
         canPlayOnEnd(playableTiles[0], board.leftEnd.value) &&
         canPlayOnEnd(playableTiles[0], board.rightEnd.value));

      return hasMultipleOptions && hasNonBlockingMove;
    }
	///
	
function playAI(gameState) {
  // ‚≠êÔ∏è FIX: Reverted this line to your original. 
  // It now assumes 'currentActivePlayerTurn' exists in the scope, as your original code did.
  const { players, board, roundHistory, isThisFirstGame, boneyard, playerOrder } = gameState; 

  // --- SAFETY CHECK FOR TURN INDEX ---
  // This check will now use the 'currentActivePlayerTurn' from the outer scope.
  if (typeof currentActivePlayerTurn !== 'number' || currentActivePlayerTurn < 0 || currentActivePlayerTurn >= players.length) {
    console.error('‚ö†Ô∏è playAI: invalid currentActivePlayerTurn =', currentActivePlayerTurn, 'players length =', players.length);
    return;
  }

  const playerHand = players[currentActivePlayerTurn];
  if (!Array.isArray(playerHand)) {
    console.error('‚ö†Ô∏è playAI: playerHand is invalid', playerHand);
    return;
  }

  const has_boneyard = playerOrder.length < 4;
  const bet = gameState.bet || 1; // fall-back if not provided

  // ===== small helpers (embedded so you don't need external changes) =====
  const TOTAL_PIP_TILES = 7; // double-six set: each pip (0..6) appears on 7 tiles (0..6 paired with pip)

  function clone(obj) { return JSON.parse(JSON.stringify(obj)); }

  // Count pip occurrences we have actually seen: board tiles + played tiles (roundHistory) + our own hand
  function countSeenPips() {
    const counts = Array(7).fill(0);

    function addTile(t) {
      if (!t) return;
      counts[t.top] = (counts[t.top] || 0) + 1;
      counts[t.bottom] = (counts[t.bottom] || 0) + 1;
    }

    // Board tiles (visible)
    if (board && Array.isArray(board.tiles)) {
      board.tiles.forEach(addTile);
    }

    // Round history: tiles that were played earlier (if structure exists)
    if (Array.isArray(roundHistory)) {
      roundHistory.forEach(entry => {
        if (entry && entry.tile) addTile(entry.tile);
      });
    }

    // Our own hand (we know them)
    playerHand.forEach(addTile);

    // Note: we do NOT count opponents' hidden hands or unknown boneyard tiles here.
    return counts;
  }

  // Remaining possible tiles for a pip given seen counts
  function remainingPipCounts(seenCounts) {
    const remaining = Array(7).fill(0);
    for (let p = 0; p <= 6; p++) {
      // Each pip appears exactly TOTAL_PIP_TILES times across the whole set (counts are per pip value occurrence)
      remaining[p] = Math.max(0, TOTAL_PIP_TILES - (seenCounts[p] || 0));
    }
    return remaining;
  }

  // After playing `tile`, what will remaining counts look like (simulate removing its pips from seen)
  function remainingAfterPlaying(seenCounts, tile) {
    const next = seenCounts.slice();
    next[tile.top] = Math.max(0, next[tile.top] - 1);
    next[tile.bottom] = Math.max(0, next[tile.bottom] - 1);
    return remainingPipCounts(next);
  }

  // Utility: measure how "closed" an end is (0 remaining => closed; 1 => nearly closed)
  function closureScoreForValue(remainingCounts, val) {
    // smaller remaining -> higher closure score
    const r = remainingCounts[val];
    if (r === 0) return 100; // effectively closed
    if (r === 1) return 60;
    if (r === 2) return 30;
    if (r === 3) return 15;
    return 0;
  }

  // ===== NEW HELPER FUNCTION =====
  /**
   * Checks if any *winning* opponent (lower hand value) can create a 
   * *winning block* on their *next* turn, given our simulated move.
   */
  function checkOpponentWinningBlock(simBoard, simPlayers, boneyard, boneyardEmpty, playerOrder, currentActivePlayerTurn, winningOpponents) {
    let opponentCanCreateWinningBlock = false;
    for (const opponent of winningOpponents) {
      const oppPlayer = opponent.player;
      const oppHand = simPlayers[oppPlayer];
      const oppMoves = getValidMoves(oppHand, simBoard);

      if (oppMoves.length > 0) {
        for (const oppMove of oppMoves) {
          const oppSimBoard = simulatePlay(simBoard, oppMove.tile, oppMove.end);
          const oppSimPlayers = clone(simPlayers);
          const oppTileIdx = oppSimPlayers[oppPlayer].findIndex(t =>
            t.top === oppMove.tile.top && t.bottom === oppMove.tile.bottom
          );
          if (oppTileIdx === -1) continue; // Should not happen, but safety
          oppSimPlayers[oppPlayer].splice(oppTileIdx, 1);

          const oppIsBlock = !isPlayableForAnyone(oppSimPlayers, boneyard, oppSimBoard, playerOrder);
          if (oppIsBlock && boneyardEmpty) {
            const oppSimValues = computePlayerValues(oppSimPlayers);
            const oppValue = oppSimValues[oppPlayer];
            const othersValues = playerOrder.filter(p => p !== oppPlayer).map(p => oppSimValues[p]);
            const minOthers = Math.min(...othersValues);
            if (oppValue <= minOthers) {
              opponentCanCreateWinningBlock = true;
              break;
            }
          }
        }
      }
      if (opponentCanCreateWinningBlock) break;
    }
    return opponentCanCreateWinningBlock;
  }

  // ===== TILE COUNT & HAND VALUE ANALYSIS =====
  const myTileCount = playerHand.length;
  const opponentTileCounts = playerOrder
    .filter(p => p !== currentActivePlayerTurn)
    .map(p => players[p].length);
  const minOpponentTiles = opponentTileCounts.length ? Math.min(...opponentTileCounts) : 0;
  const tileCountDisadvantage = myTileCount - minOpponentTiles;

  const isInDanger = tileCountDisadvantage >= 2;
  const isAtRisk = tileCountDisadvantage >= 1;

  const currentValues = computePlayerValues(players);
  const myCurrentValue = currentValues[currentActivePlayerTurn];
  const opponentValues = playerOrder.filter(p => p !== currentActivePlayerTurn).map(p => currentValues[p]);
  const minOpponentValue = opponentValues.length ? Math.min(...opponentValues) : Infinity;
  const maxOpponentValue = opponentValues.length ? Math.max(...opponentValues) : -Infinity;

  // ===== OPPONENT THREAT ASSESSMENT =====
  const opponentThreats = playerOrder
    .filter(p => p !== currentActivePlayerTurn)
    .map(p => ({
      player: p,
      tileCount: players[p].length,
      handValue: currentValues[p],
      isWinningPosition: currentValues[p] <= myCurrentValue
    }));
  
  const winningOpponents = opponentThreats.filter(o => o.isWinningPosition);
  const hasWinningOpponent = winningOpponents.length > 0;
  const mostDangerousOpponent = opponentThreats
    .filter(opp => opp.isWinningPosition)
    .sort((a, b) => a.handValue - b.handValue)[0] || null;
    
  // Find opponents who can win *next turn* (1 tile left)
  const runOutThreats = playerOrder.filter(p =>
    p !== currentActivePlayerTurn && players[p].length === 1
  );

  // ===== Precompute pip visibility =====
  const seenPips = countSeenPips();
  const remainingPipsGlobal = remainingPipCounts(seenPips); // how many of each pip left unknown

  // Enforce highest double on first play (your original rule)
  if (!board.leftEnd && isThisFirstGame) {
    if (gameState.highestDouble && playerHand.some(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom)) {
      const tileToPlay = playerHand.find(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom);
      playTile(gameState, tileToPlay, 'right');
      return;
    }
  }

  let bestMove = { tile: null, end: null, score: -Infinity };
  const validMoves = getValidMoves(playerHand, board);

  if (validMoves.length === 0) return;

  for (const move of validMoves) {
    let score = 0;
    const { tile, end } = move;

    const simBoard = simulatePlay(board, tile, end);
    const simPlayers = clone(players);
    const tileIndex = simPlayers[currentActivePlayerTurn].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
    
    // Safety check: if tile not found, this move is invalid
    if (tileIndex === -1) continue; 
    
    simPlayers[currentActivePlayerTurn].splice(tileIndex, 1);

    // ===== PRIORITY 0: WINNING MOVE =====
    if (simPlayers[currentActivePlayerTurn].length === 0) {
      // Strong preference to go out immediately
      score = 1_000_000;
      bestMove = { tile, end, score };
      break;
    }
    
    // ===== ‚≠êÔ∏è NEW: PRIORITY -1: AVOID OPPONENT WIN (RUN-OUT) ‚≠êÔ∏è =====
    // Check if this move allows an opponent with one tile to win *this next turn*.
    // We use the *original* 'players' object to see their current hands.
    let opponentCanWinNext = false;
    if (runOutThreats.length > 0) {
      for (const oppPlayer of runOutThreats) {
        const oppHand = players[oppPlayer]; // Their hand (of 1 tile)
        // Check if their one tile is playable on our *simulated* board
        const oppMoves = getValidMoves(oppHand, simBoard);
        if (oppMoves.length > 0) {
          opponentCanWinNext = true;
          break;
        }
      }
    }

    if (opponentCanWinNext) {
      // This is a game-losing move. Assign a massive penalty.
      // This score is catastrophic, ensuring it's only picked if *all*
      // moves lead to an immediate loss.
      score = -500_000;
      if (score > bestMove.score) {
        bestMove = { tile, end, score };
      }
      continue; // Stop processing this disastrous move
    }
    // =============================================================

    const simValues = computePlayerValues(simPlayers);
    const mySimValue = simValues[currentActivePlayerTurn];

    // recompute remaining pips after playing this tile (we can forecast what's now visible)
    // We simulate that our tile is now played (it was counted in seenPips as part of our hand)
    const remainingIfPlayed = remainingAfterPlaying(seenPips, tile);

    // Evaluate immediate closure potential: if remaining count for an end value is 0,
    // playing that value on the open end will likely close it (no more tiles with that pip exist).
    const leftVal = simBoard.leftEnd.value;
    const rightVal = simBoard.rightEnd.value;
    const leftClosureScore = closureScoreForValue(remainingIfPlayed, leftVal);
    const rightClosureScore = closureScoreForValue(remainingIfPlayed, rightVal);

    // If both ends closed => block scenario
    const isBlock = !isPlayableForAnyone(simPlayers, boneyard, simBoard, playerOrder);
    const boneyardEmpty = has_boneyard ? boneyard.length === 0 : true;

    if (isBlock && boneyardEmpty) {
      const simOpponentValues = playerOrder.filter(p => p !== currentActivePlayerTurn).map(p => simValues[p]);
      const minSimOpponent = Math.min(...simOpponentValues);

      if (mySimValue <= minSimOpponent) {
        score += 8000;
        const valueDifference = minSimOpponent - mySimValue;
        score += valueDifference * 100;
      } else {
        score -= 20000;
        const valueDifference = mySimValue - minSimOpponent;
        score -= valueDifference * 100;
      }
    }

    // ===== NEW: PIP AVAILABILITY & BLOCK FORECASTING =====
    // If playing this move closes an end (remaining==0) we add a big bonus if it benefits us,
    // or a big penalty if it benefits opponent(s).
    // Evaluate which end this move affects more (depending on the tile orientation)
    const affectsLeft = (end === 'left') || (move.ends && move.ends.includes('left')) || (simBoard.leftEnd.value === tile.top || simBoard.leftEnd.value === tile.bottom);
    const affectsRight = (end === 'right') || (move.ends && move.ends.includes('right')) || (simBoard.rightEnd.value === tile.top || simBoard.rightEnd.value === tile.bottom);

    // If the move is likely to close an end:
    if (affectsLeft && leftClosureScore >= 60) {
      // closing left end is likely
      // if closing helps us (we have low sum compared to others) reward, else penalty
      if (mySimValue <= minOpponentValue) score += 3000;
      else score -= 2500;
    }

    if (affectsRight && rightClosureScore >= 60) {
      if (mySimValue <= minOpponentValue) score += 3000;
      else score -= 2500;
    }

    // ===== PRIORITY BRANCHING: DANGER MODE vs NORMAL MODE =====
    if (isInDanger || isAtRisk) {
      // DANGER MODE: dump points, but avoid enabling opponent 2x wins
      let tileValue = tile.top + tile.bottom;

      // Base dumping incentive
      if (isInDanger) {
        score += tileValue * 150;
        if (tileValue >= 10) score += 2500;
        if (tileValue >= 9) score += 1500;
        if (tileValue >= 8) score += 800;
      } else if (isAtRisk) {
        score += tileValue * 80;
        if (tileValue >= 9) score += 1500;
        if (tileValue >= 7) score += 800;
        if (tileValue >= 5) score += 400;
      }

      // Danger-mode: if our play reduces remaining count of a pip to 0 and that pip is frequent in opponents' hands,
      // then closing might be beneficial ‚Äî boost if closing prevents others from playing a low-value tile to go out.
      // Conversely, if closing makes an opponent able to block and win, penalize strongly.
      const remAfter = remainingIfPlayed;
      // If we close the pip opponent most likely needs (heuristic: pip with lowest remAfter but many opponents have low tiles)
      const closureImpactLeft = closureScoreForValue(remAfter, leftVal);
      const closureImpactRight = closureScoreForValue(remAfter, rightVal);
      const closureImpact = Math.max(closureImpactLeft, closureImpactRight);
      if (closureImpact >= 100) {
        // a strong closure: highly valuable to consider
        // check whether opponents are likely to benefit: simulate one move ahead for opponents
        if (hasWinningOpponent) {
          // penalize if any winning opponent could use this to create a winning block
          
          // ===== ‚≠êÔ∏è REFACTORED BLOCK ‚≠êÔ∏è =====
          const oppCouldWinBlock = checkOpponentWinningBlock(
            simBoard, simPlayers, boneyard, boneyardEmpty,
            playerOrder, currentActivePlayerTurn, winningOpponents
          );
          if (oppCouldWinBlock) {
            score -= 6000; // serious penalty
          }
          // ===================================
        }
      }

      // Remote threat check (1 step deep) already present; keep it but consider pip availability
      if (!isBlock && mostDangerousOpponent) {
        const nextPlayerIdx = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
        const nextPlayer = playerOrder[nextPlayerIdx];
        if (nextPlayer === mostDangerousOpponent.player) {
          const nextHand = simPlayers[nextPlayer];
          const nextMoves = getValidMoves(nextHand, simBoard);
          let remoteBlockThreat = false;
          for (const nextMove of nextMoves) {
            const nextSimBoard = simulatePlay(simBoard, nextMove.tile, nextMove.end);
            const nextSimPlayers = clone(simPlayers);
            const nextTileIdx = nextSimPlayers[nextPlayer].findIndex(t =>
              t.top === nextMove.tile.top && t.bottom === nextMove.tile.bottom
            );
            if(nextTileIdx === -1) continue;
            
            nextSimPlayers[nextPlayer].splice(nextTileIdx, 1);
            const stillPlayable = isPlayableForAnyone(nextSimPlayers, boneyard, nextSimBoard, playerOrder);
            if (!stillPlayable && boneyardEmpty) {
              const nextSimValues = computePlayerValues(nextSimPlayers);
              const nextOppValue = nextSimValues[nextPlayer];
              const othersVals = playerOrder.filter(p => p !== nextPlayer).map(p => nextSimValues[p]);
              const minOthers = Math.min(...othersVals);
              if (nextOppValue <= minOthers) {
                remoteBlockThreat = true;
                break;
              }
            }
          }
          if (remoteBlockThreat) {
            score -= 3000;
          }
        }
      }

      // New Danger-mode run-out heuristic:
      // If we are near end (our tiles small and boneyard empty or small), prefer moves that:
      //  - reduce distinct pip counts in our remaining hand (so next plays easier),
      //  - or remove pip values that have few remaining tiles (making future blocks more likely in our favor).
      if (boneyardEmpty || boneyard.length < 3) {
        const afterHand = simPlayers[currentActivePlayerTurn];
        const valuesLeft = new Set();
        afterHand.forEach(t => { valuesLeft.add(t.top); valuesLeft.add(t.bottom); });
        const diversityAfter = valuesLeft.size;
        score += (10 - diversityAfter) * 200; // prefer lower diversity
        // reward if we remove a pip that would otherwise allow opponents to play
        const removedPips = [];
        if (!playerHand.some(h => h.top === tile.top && h.bottom === tile.bottom)) {
          // already handled but safe
        }
        // reward closing rare pip
        if (closureImpact >= 60) score += 1200;
      }

    } else {
      // NORMAL MODE: Full strategic play

      if (has_boneyard) {
        let tileValue = tile.top + tile.bottom;
        if (isDouble(tile)) tileValue += 5;

        if (!isBlock) {
          // Prevent opponent winning blocks (existing logic)
          if (hasWinningOpponent) {
             // ===== ‚≠êÔ∏è REFACTORED BLOCK ‚≠êÔ∏è =====
            const oppCouldWinBlock = checkOpponentWinningBlock(
              simBoard, simPlayers, boneyard, boneyardEmpty,
              playerOrder, currentActivePlayerTurn, winningOpponents
            );
            if (oppCouldWinBlock) {
              score -= 7000;
            }
            // ===================================
          }

          // Trap strategy (help opponent lose block) - kept
          if (mySimValue < minOpponentValue) {
            const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
            const nextPlayer = playerOrder[nextPlayerIndex];
            const nextPlayerHand = simPlayers[nextPlayer];
            const nextPlayerMoves = getValidMoves(nextPlayerHand, simBoard);
            if (nextPlayerMoves.length > 0) {
              let nextPlayerCouldLoseBlock = false;
              for (const nextMove of nextPlayerMoves) {
                const nextSimBoard = simulatePlay(simBoard, nextMove.tile, nextMove.end);
                const nextSimPlayers = clone(simPlayers);
                const nextTileIdx = nextSimPlayers[nextPlayer].findIndex(t =>
                  t.top === nextMove.tile.top && t.bottom === nextMove.tile.bottom
                );
                if (nextTileIdx === -1) continue;
                
                nextSimPlayers[nextPlayer].splice(nextTileIdx, 1);
                const nextIsBlock = !isPlayableForAnyone(nextSimPlayers, boneyard, nextSimBoard, playerOrder);
                if (nextIsBlock && boneyardEmpty) {
                  const nextSimValues = computePlayerValues(nextSimPlayers);
                  const nextPlayerValue = nextSimValues[nextPlayer];
                  const othersValues = playerOrder.filter(p => p !== nextPlayer).map(p => nextSimValues[p]);
                  const minOthers = Math.min(...othersValues);
                  if (nextPlayerValue > minOthers) {
                    nextPlayerCouldLoseBlock = true;
                    break;
                  }
                }
              }
              if (nextPlayerCouldLoseBlock) score += 4500;
            }
          }

          // TURN CONTINUITY (avoid drawing)
          const tilesPlayableAfterThisMove = simPlayers[currentActivePlayerTurn].filter(t =>
            canPlayTile(t, simBoard)
          ).length;
          const remainingTileCount = simPlayers[currentActivePlayerTurn].length;
          const playabilityRatio = remainingTileCount > 0 ? (tilesPlayableAfterThisMove / remainingTileCount) : 0;

          score += playabilityRatio * 1000;
          if (playabilityRatio >= 0.5) score += 800;

          const leftEndVal = simBoard.leftEnd.value;
          const rightEndVal = simBoard.rightEnd.value;

          const tilesMatchingLeft = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === leftEndVal || t.bottom === leftEndVal
          ).length;
          const tilesMatchingRight = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === rightEndVal || t.bottom === rightEndVal
          ).length;

          if (tilesMatchingLeft === 0 && tilesMatchingRight === 0) {
            score -= 1500;
          }

          const totalMatchingTiles = tilesMatchingLeft + tilesMatchingRight;
          if (totalMatchingTiles === 1) score -= 800;
          else if (totalMatchingTiles === 2) score -= 400;
          else if (totalMatchingTiles >= 4) score += 300;

          if (leftEndVal === rightEndVal) score -= 200;

          // HAND VALUE REDUCTION
          score += tileValue * 30;

          // FORCE OPPONENT TO DRAW: keep (existing)
          if (boneyard.length > 0) {
            const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
            const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
            if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
              score += 200;
            }
          }

          // RARE PIPS: improved weighting using remainingPipsGlobal
          // prefer to play a tile that uses pips which are rarer in remaining deck (increase chance to close)
          const leftRarity = TOTAL_PIP_TILES - remainingIfPlayed[leftEndVal];
          const rightRarity = TOTAL_PIP_TILES - remainingIfPlayed[rightEndVal];
          score += leftRarity * 20;
          score += rightRarity * 20;

          // ENDGAME AGGRESSION
          if (boneyard.length < 5) {
            score += tileValue * 15;
          }
        }

      } else {
        // 4-player logic largely preserved but enriched with pip heuristics
        if (!isBlock) {
          if (hasWinningOpponent) {
             // ===== ‚≠êÔ∏è REFACTORED BLOCK ‚≠êÔ∏è =====
             // Note: boneyardEmpty is effectively 'true' in 4-player, so helper is fine
            const oppCouldWinBlock = checkOpponentWinningBlock(
              simBoard, simPlayers, boneyard, true,
              playerOrder, currentActivePlayerTurn, winningOpponents
            );
            if (oppCouldWinBlock) {
              score -= 7000;
            }
            // ===================================
          }

          // TURN CONTINUITY & pip diversity
          const tilesPlayableAfterThisMove = simPlayers[currentActivePlayerTurn].filter(t =>
            canPlayTile(t, simBoard)
          ).length;
          const remainingTileCount = simPlayers[currentActivePlayerTurn].length;
          const playabilityRatio = remainingTileCount > 0 ? (tilesPlayableAfterThisMove / remainingTileCount) : 0;

          score += playabilityRatio * 1200;
          if (playabilityRatio >= 0.6) score += 1000;

          const leftEndVal = simBoard.leftEnd.value;
          const rightEndVal = simBoard.rightEnd.value;

          const tilesMatchingLeft = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === leftEndVal || t.bottom === leftEndVal
          ).length;
          const tilesMatchingRight = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === rightEndVal || t.bottom === rightEndVal
          ).length;

          if (tilesMatchingLeft === 0 && tilesMatchingRight === 0) {
            score -= 2000;
          }

          const totalMatchingTiles = tilesMatchingLeft + tilesMatchingRight;
          if (totalMatchingTiles === 1) score -= 1000;
          else if (totalMatchingTiles === 2) score -= 500;
          else if (totalMatchingTiles >= 5) score += 400;

          if (leftEndVal === rightEndVal) score -= 300;

          // PIP DIVERSITY: keep but prefer reducing diversity as endgame tactic
          const pipsInRemainingHand = new Set();
          simPlayers[currentActivePlayerTurn].forEach(t => {
            pipsInRemainingHand.add(t.top);
            pipsInRemainingHand.add(t.bottom);
          });
          const pipDiversity = pipsInRemainingHand.size;
          score += pipDiversity * 50;

          let tileValue = tile.top + tile.bottom;
          if (isDouble(tile)) tileValue += 10;
          score += tileValue * 10;

          // BLOCK NEXT PLAYER (force pass)
          const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
          const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
          if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
            score += 200;
          }

          // RARE PIPS: use remaining if played to prefer using rare pips
          const rarityLeft = TOTAL_PIP_TILES - remainingIfPlayed[leftEndVal];
          const rarityRight = TOTAL_PIP_TILES - remainingIfPlayed[rightEndVal];
          score += rarityLeft * 5;
          score += rarityRight * 5;
        } else {
          // Block scenario: reward if we had no non-blocking alternative
          const minValue = Math.min(...playerOrder.map(p => simValues[p]));
          if (mySimValue <= minValue) {
            let hadNonBlockingAlternative = false;
            for (const otherMove of validMoves) {
              if (otherMove.tile === move.tile && otherMove.end === move.end) continue;
              const otherSimBoard = simulatePlay(board, otherMove.tile, otherMove.end);
              const otherSimPlayers = clone(players);
              const otherTileIndex = otherSimPlayers[currentActivePlayerTurn].findIndex(t =>
                t.top === otherMove.tile.top && t.bottom === otherMove.tile.bottom
              );
              if (otherTileIndex === -1) continue;

              otherSimPlayers[currentActivePlayerTurn].splice(otherTileIndex, 1);
              if (isPlayableForAnyone(otherSimPlayers, boneyard, otherSimBoard, playerOrder)) {
                hadNonBlockingAlternative = true;
                break;
              }
            }
            if (hadNonBlockingAlternative) score += 5000;
            else score += 2500;
          }
        }
      }
    }

    // FINAL: baseline tie-breakers
    // Prefer lower pip-sum tiles in late game if we cannot win immediately (reduce hand sum)
    if (myTileCount <= 3) {
      score += -(tile.top + tile.bottom) * 20; // prefer lower pip tiles to minimize loss
      // prefer moves that reduce distinct pips in our hand
      const afterHand = clone(simPlayers[currentActivePlayerTurn]);
      const setVals = new Set();
      afterHand.forEach(t => { setVals.add(t.top); setVals.add(t.bottom); });
      score += (10 - setVals.size) * 100;
    }

    if (score > bestMove.score) {
      bestMove = { tile, end, score };
    }
  }

  if (bestMove.tile) {
    playTile(gameState, bestMove.tile, bestMove.end);
  }
}

///

// UPDATED handleTileClick function - use currentActivePlayerTurn
function handleTileClick(gameState, tileIndex, playButtons) {
  const { players, selectedIndex, board, isThisFirstGame } = gameState;
  const hand = players[0];
  const clickedTile = hand[tileIndex];

  if (currentActivePlayerTurn === 0) {
    // ACTIVE TURN - Selection mode only (for playing tiles)
    if (selectedIndex === tileIndex) {
      // Click selected tile again - just deselect
      gameState.selectedIndex = -1;
    } else {
      // Click different tile - select it
      gameState.selectedIndex = tileIndex;
    }
  } else {
    // INACTIVE TURN - Full sorting mode (rotate + swap)
    if (selectedIndex === -1) {
      // No tile selected - select this one
      gameState.selectedIndex = tileIndex;
    } else if (selectedIndex === tileIndex) {
      // Click selected tile again - ROTATE it
      // Exception: Don't rotate required highest double in first game
      if (board.tiles.length === 0 && isThisFirstGame) {
        const doubles = hand.filter(t => isDouble(t));
        if (doubles.length > 0) {
          const highestDouble = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
          if (clickedTile.top === highestDouble.top && clickedTile.bottom === highestDouble.bottom) {
            // Don't rotate required highest double - just deselect
            gameState.selectedIndex = -1;
            renderGame(gameState);
            return;
          }
        }
      }
      // Rotate the tile
      hand[tileIndex] = rotateTile(clickedTile);
      gameState.selectedIndex = -1;
    } else {
      // Different tile clicked - SWAP positions
      const selectedTile = hand[selectedIndex];
      hand[selectedIndex] = clickedTile;
      hand[tileIndex] = selectedTile;
      gameState.selectedIndex = -1;
    }
  }

  renderGame(gameState);
}
///
// Fixed playTile function - Add drawing tracking to roundHistory
function playTile(gameState, tile, end) {
  const { players, board, roundHistory, isThisFirstGame, playerOrder, boneyard } = gameState;
  const playerHand = players[currentActivePlayerTurn];
  const tileIndex = playerHand.findIndex(t => t.top === tile.top && t.bottom === tile.bottom);

  if (tileIndex === -1 || !canPlayTile(tile, board)) {
    console.warn("Invalid move attempt:", tile, "on board:", board.leftEnd?.value, board.rightEnd?.value);
    renderGame(gameState); // Re-render to reset any UI state, can remove
    return false;
  }

  if (board.tiles.length === 0 && isThisFirstGame) {
    if (gameState.highestDouble) {
      if (tile.top !== gameState.highestDouble.top || tile.bottom !== gameState.highestDouble.bottom) {
        if (currentActivePlayerTurn === 0) {
          alert(`Must play the highest double [${gameState.highestDouble.top}-${gameState.highestDouble.bottom}] first!`);
        }
        return false;
      }
      if (currentActivePlayerTurn !== playerOrder.find(p => players[p].some(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom))) {
        return false;
      }
    }
  }

  const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();

  gameState.prevBoard = board.leftEnd ? {
    leftEnd: {...board.leftEnd},
    rightEnd: {...board.rightEnd}
  } : null;

  const playedTile = playerHand.splice(tileIndex, 1)[0];

  if (currentActivePlayerTurn === 0) {
    gameState.selectedIndex = -1;
  }

  // FIXED: Track tiles in hand before this move (for assistance detection)
  const handBeforePlay = [...playerHand, playedTile];

  if (roundHistory) {
    roundHistory.push({
      player: currentActivePlayerTurn,
      playedTile: {...playedTile},
      end: end,
      boardBefore: gameState.prevBoard,
      handBeforePlay: handBeforePlay.map(t => ({...t})) // ADD THIS: Store hand before playing
    });
  }

  const tableDiv = document.getElementById('table');
  const tableRect = tableDiv.getBoundingClientRect();

  let x, y, isHorizontal, displayTop, displayBottom, displayLeft, displayRight;

  const isFirst = board.tiles.length === 0;
  let e, turnDir;
  let isLeftChain = end === 'left';
  turnDir = isLeftChain ? 'up' : 'down';

  if (isFirst) {
    const isFirstDouble = isDouble(playedTile);
    if (isFirstDouble) {
      isHorizontal = false;
      x = tableRect.width / 2 - V_W / 2;
      y = tableRect.height / 2 - V_H / 2;
      displayTop = playedTile.top;
      displayBottom = playedTile.bottom;
      const centerX = x + V_W / 2;
      const topY = y + OFFSET;
      const bottomY = y + V_H - OFFSET;
      board.leftEnd = { value: playedTile.top, x: centerX, y: topY, dir: 'left', openSide: 'up' };
      board.rightEnd = { value: playedTile.bottom, x: centerX, y: bottomY, dir: 'right', openSide: 'down' };
    } else {
      x = tableRect.width / 2 - H_W / 2;
      y = tableRect.height / 2 - H_H / 2;
      isHorizontal = true;
      displayTop = playedTile.bottom;
      displayBottom = playedTile.top;
      displayLeft = playedTile.top;
      displayRight = playedTile.bottom;
      board.leftEnd = { value: playedTile.top, x: x + OFFSET, y: y + OFFSET, dir: 'left', openSide: 'left' };
      board.rightEnd = { value: playedTile.bottom, x: x + FULL - OFFSET, y: y + OFFSET, dir: 'right', openSide: 'right' };
    }
  } else {
    e = (end === 'left') ? board.leftEnd : board.rightEnd;
    const placement = calculatePlacement(board, end, tableRect, playedTile);
    x = placement.x;
    y = placement.y;
    isHorizontal = placement.isHorizontal;
    e.x = placement.nextEndX;
    e.y = placement.nextEndY;
    e.isVertical = placement.isVertical;

    const oldValue = e.value;
    let connectingValue, newEndValue;
    if (tile.top === oldValue) {
      connectingValue = tile.top;
      newEndValue = tile.bottom;
    } else {
      connectingValue = tile.bottom;
      newEndValue = tile.top;
    }
    e.value = newEndValue;

    if (isHorizontal) {
      if (e.dir === 'left') {
        displayTop = connectingValue;
        displayBottom = newEndValue;
      } else {
        displayTop = newEndValue;
        displayBottom = connectingValue;
      }
    } else {
      if (turnDir === 'up') {
        displayTop = newEndValue;
        displayBottom = connectingValue;
      } else {
        displayTop = connectingValue;
        displayBottom = newEndValue;
      }
    }

    if (placement.newHdir) {
      e.dir = placement.newHdir;
      e.openSide = placement.turnDir;
    } else {
      e.openSide = e.dir;
    }
  }

  let tileData;
  if (isHorizontal) {
    displayLeft = displayBottom;
    displayRight = displayTop;
    tileData = { left: displayLeft, right: displayRight };
  } else {
    tileData = { top: displayTop, bottom: displayBottom };
  }
  const tileDiv = document.createElement('div');
  tileDiv.className = 'table-tile';
  if (isHorizontal) tileDiv.classList.add('horizontal');
  tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
  tileDiv.style.left = `${x + board.offsetX}px`;
  tileDiv.style.top = `${y + board.offsetY}px`;

  tableDiv.appendChild(tileDiv);
  board.tiles.push({ tile: { top: displayTop, bottom: displayBottom }, x, y, isHorizontal });

  const pushedIndex = board.tiles.length - 1;
  if (board.tiles.length === 1) {
    board.leftEnd.tileIndex = pushedIndex;
    board.rightEnd.tileIndex = pushedIndex;
  } else {
    if (end === 'left') {
      board.leftEnd.tileIndex = pushedIndex;
    } else {
      board.rightEnd.tileIndex = pushedIndex;
    }
  }

  playSound();
  lastValidPlayer = currentActivePlayerTurn;

  if (playerHand.length === 0) {
    handleNormalGameWin(gameState);
    return true;
  }

  const currentIndex = playerOrder.indexOf(currentActivePlayerTurn);
  let firstSkipped = -1;
  let checkedPlayers = 0;
  let nextIndex = (currentIndex + 1) % playerOrder.length;
  let nextPlayer = playerOrder[nextIndex];

  drawUntilMatch(gameState, nextPlayer);
  if (!players[nextPlayer].some(t => canPlayTile(t, board))) {
    firstSkipped = nextPlayer;
    checkedPlayers = 1;
    nextIndex = (nextIndex + 1) % playerOrder.length;
    nextPlayer = playerOrder[nextIndex];
    drawUntilMatch(gameState, nextPlayer);
    while (checkedPlayers < playerOrder.length && !players[nextPlayer].some(t => canPlayTile(t, board))) {
      checkedPlayers++;
      nextIndex = (nextIndex + 1) % playerOrder.length;
      nextPlayer = playerOrder[nextIndex];
      drawUntilMatch(gameState, nextPlayer);
    }
  }

  if (checkedPlayers === playerOrder.length) {
    handleBlockedGame(gameState, lastValidPlayer, firstSkipped, playedTile, end);
    return true;
  }

  currentActivePlayerTurn = nextPlayer;
  renderGame(gameState);

  if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
    setTimeout(() => playAI(gameState), 1500);
  }
  return true;
}

    function getPreviousPlayer(p, playerOrder) {
      const idx = playerOrder.indexOf(p);
      return playerOrder[(idx - 1 + playerOrder.length) % playerOrder.length];
    }

   // Updated updateScoresForWin (add localStorage save)
function updateScoresForWin(winner, gameState) {
  let values = computePlayerValues(gameState.players);
  let pot = 0;
  const { playerOrder } = gameState;
  for (let i of playerOrder) {
    if (i !== winner) {
      let pay = values[i] * bet;
      pot += pay;
      scores[i] -= pay;
    }
  }
  scores[winner] += pot;
  nextGameStarter = winner;
  let message = `Player ${getPlayerNumber(winner)} wins ${abbreviate(pot)}\n\n`;
  for (let i of playerOrder) {
    if (i !== winner) {
      let pay = values[i] * bet;
      message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
    }
  }
  setTimeout(() => alert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}

// Updated updateScoresForIntentionalBlockWithAssist (add localStorage save)
function updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState) {
  let values = computePlayerValues(gameState.players);
  let minAll = Math.min(...gameState.playerOrder.map(p => values[p]));
  let blockerValue = values[blocker];
  let othersTotal = gameState.playerOrder.reduce((sum, p) => p === blocker ? sum : sum + values[p], 0);
  let payAmount = 2 * othersTotal * bet;
  let message;
  if (blockerValue <= minAll) {
    scores[assistant] -= payAmount;
    scores[blocker] += payAmount;
    message = `Player ${getPlayerNumber(blocker)} wins block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
    message += `Player ${getPlayerNumber(assistant)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(blocker)}`;
  } else {
    scores[blocker] -= payAmount;
    scores[assistant] += payAmount;
    message = `Player ${getPlayerNumber(blocker)} loses block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
    message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(assistant)}`;
  }
  nextGameStarter = blocker;
  setTimeout(() => alert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}

// Updated updateScoresForIntentionalBlockNoAssist (add localStorage save)
function updateScoresForIntentionalBlockNoAssist(blocker, gameState) {
  let values = computePlayerValues(gameState.players);
  let blockerValue = values[blocker];
  let othersValues = gameState.playerOrder.filter(p => p !== blocker).map(p => values[p]);
  let minOthers = Math.min(...othersValues);
  let totalTransfer = othersValues.reduce((a, b) => a + b, 0) * 2 * bet;
  let message;
  if (blockerValue <= minOthers) {
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[i] -= pay;
        scores[blocker] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} wins block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} receives ${abbreviate(totalTransfer)}\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
      }
    }
  } else {
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[blocker] -= pay;
        scores[i] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} loses block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(totalTransfer)} total\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} receives ${abbreviate(pay)}\n`;
      }
    }
  }
  nextGameStarter = blocker;
  setTimeout(() => alert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}

// Updated updateScoresForForceBlock (add localStorage save)
function updateScoresForForceBlock(gameState) {
  let values = computePlayerValues(gameState.players);
  let minVal = Math.min(...gameState.playerOrder.map(p => values[p]));
  let winners = [];
  let losers = [];
  for (let i of gameState.playerOrder) {
    if (values[i] === minVal) {
      winners.push(i);
    } else {
      losers.push(i);
    }
  }

  let message;
  if (winners.length === gameState.playerOrder.length) {
    message = `Force block! All players tie.\n\nNo payout.\nPlayer ${getPlayerNumber(nextGameStarter)} starts next game.`;
    nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
  } else {
    let total_pot = 0;
    losers.forEach(l => {
      let pay = values[l] * bet;
      scores[l] -= pay;
      total_pot += pay;
    });
    let share = total_pot / winners.length;
    winners.forEach(w => {
      scores[w] += share;
    });
    if (winners.length === 1) {
      nextGameStarter = winners[0];
      message = `Force block! Player ${getPlayerNumber(nextGameStarter)} has lowest hand.\n\n`;
      message += `Player ${getPlayerNumber(nextGameStarter)} wins ${abbreviate(total_pot)}\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    } else {
      nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
      message = `Force block! Tie between: ${winners.map(w => `Player ${getPlayerNumber(w)}`).join(', ')}\n\n`;
      message += `Winners share ${abbreviate(total_pot)} (${abbreviate(share)} each)\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    }
  }
  setTimeout(() => alert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}

    function handleNormalGameWin(gameState) {
      gameState.gameOver = true;
      updateScoresForWin(currentActivePlayerTurn, gameState);
      renderGame(gameState);
      showNewGameButton();
    }
	
function hadAlternativeThatAvoidsBlock(playerIndex, boardBefore, handBefore, playersState, boneyard, playerOrder) {

  // Get all valid moves for this player at that board state
  const validMoves = getValidMoves(handBefore, boardBefore);
  
  if (validMoves.length <= 1) {
    // No alternatives (0 or 1 move only)
    return false;
  }

  // Check each alternative move
  for (const move of validMoves) {
    // Simulate playing this tile
    const simBoard = simulatePlay(boardBefore, move.tile, move.end);
    const simPlayers = JSON.parse(JSON.stringify(playersState));
    
    // Remove the played tile from simulated hand
    const tileIdx = simPlayers[playerIndex].findIndex(t => 
      t.top === move.tile.top && t.bottom === move.tile.bottom
    );
    simPlayers[playerIndex].splice(tileIdx, 1);

    // Check if this move leads to a playable state (not force block)
    if (isPlayableForAnyone(simPlayers, boneyard, simBoard, playerOrder)) {
      // Found an alternative that avoids force block
      return true;
    }
  }

  // All alternatives also lead to force block
  return false;
}
///added
/*function hadAlternativeThatAvoidsBlock(playerIndex, boardBefore, handBefore, playersState, boneyard, playerOrder) {
  const validMoves = getValidMoves(handBefore, boardBefore);
  
  if (validMoves.length <= 1) {
    return false;
  }

  for (const move of validMoves) {
    const simBoard = simulatePlay(boardBefore, move.tile, move.end);
    const simPlayers = JSON.parse(JSON.stringify(playersState));
    
    const tileIdx = simPlayers[playerIndex].findIndex(t => 
      t.top === move.tile.top && t.bottom === move.tile.bottom
    );
    simPlayers[playerIndex].splice(tileIdx, 1);

    if (isPlayableForAnyone(simPlayers, boneyard, simBoard, playerOrder)) {
      return true;
    }
  }

  return false;
}*/
///new
function handleBlockedGame(gameState, lastValidPlayer, firstSkipped, lastPlayedTile, lastPlayedEnd) {
  gameState.gameOver = true;
  const { players, board, roundHistory, playerOrder, boneyard } = gameState;

  const prevBoard = gameState.prevBoard;
  if (!prevBoard) {
    updateScoresForForceBlock(gameState);
    renderGame(gameState);
    showNewGameButton();
    return;
  }

  const lastMove = roundHistory[roundHistory.length - 1];
  const lastPlayerHandBefore = lastMove.handBeforePlay;
  const playersAtLast = JSON.parse(JSON.stringify(players));
  playersAtLast[lastValidPlayer].push({...lastPlayedTile});

  const lastHadAvoidingAlt = hadAlternativeThatAvoidsBlock(
    lastValidPlayer,
    prevBoard,
    lastPlayerHandBefore,
    playersAtLast,
    boneyard,
    playerOrder
  );

  if (lastHadAvoidingAlt) {
    let assistant = -1;
    
    if (roundHistory.length >= 2) {
      const prevMove = roundHistory[roundHistory.length - 2];
      const prevPlayer = prevMove.player;
      
      if (playerOrder.includes(prevPlayer) && prevPlayer !== lastValidPlayer) {
        const prevHandBefore = prevMove.handBeforePlay;
        const playersAtPrevMove = JSON.parse(JSON.stringify(players));
        playersAtPrevMove[prevPlayer].push({...prevMove.playedTile});
        playersAtPrevMove[lastValidPlayer].push({...lastPlayedTile});

        const prevBoardBefore = prevMove.boardBefore;
        
        if (prevBoardBefore && prevBoardBefore.leftEnd) {
          const prevHadAvoidingAlt = hadAlternativeThatAvoidsBlock(
            prevPlayer,
            prevBoardBefore,
            prevHandBefore,
            playersAtPrevMove,
            boneyard,
            playerOrder
          );
          
          if (prevHadAvoidingAlt) {
            assistant = prevPlayer;
          }
        }
      }
    }

    if (assistant !== -1) {
      updateScoresForIntentionalBlockWithAssist(lastValidPlayer, assistant, gameState);
    } else {
      updateScoresForIntentionalBlockNoAssist(lastValidPlayer, gameState);
    }
    
    renderGame(gameState);
    showNewGameButton();
    return;
  }

  let remoteBlocker = -1;
  const startIndex = roundHistory.length - 2;
  const endIndex = Math.max(0, roundHistory.length - 4);

  for (let i = startIndex; i >= endIndex; i--) {
    const move = roundHistory[i];
    const player = move.player;

    if (!playerOrder.includes(player)) {
      continue;
    }

    const handBefore = move.handBeforePlay;
    const playersAtThisMove = JSON.parse(JSON.stringify(players));
    
    for (let j = i; j < roundHistory.length; j++) {
      const laterMove = roundHistory[j];
      playersAtThisMove[laterMove.player].push({...laterMove.playedTile});
    }

    const boardBefore = move.boardBefore;
    
    if (!boardBefore || !boardBefore.leftEnd) {
      continue;
    }

    const hadAvoidingAlt = hadAlternativeThatAvoidsBlock(
      player,
      boardBefore,
      handBefore,
      playersAtThisMove,
      boneyard,
      playerOrder
    );

    if (hadAvoidingAlt) {
      remoteBlocker = player;
      break;
    }
  }

  if (remoteBlocker !== -1) {
    updateScoresForIntentionalBlockNoAssist(remoteBlocker, gameState);
    renderGame(gameState);
    showNewGameButton();
    return;
  }

  updateScoresForForceBlock(gameState);
  renderGame(gameState);
  showNewGameButton();
}

// Keep existing helper functions (these don't need changes)
function updateScoresForIntentionalBlockNoAssist(blocker, gameState) {
  let values = computePlayerValues(gameState.players);
  let blockerValue = values[blocker];
  let othersValues = gameState.playerOrder.filter(p => p !== blocker).map(p => values[p]);
  let minOthers = Math.min(...othersValues);
  let totalTransfer = othersValues.reduce((a, b) => a + b, 0) * 2 * bet;
  let message;
  
  if (blockerValue <= minOthers) {
    // Blocker wins
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[i] -= pay;
        scores[blocker] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} wins block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} receives ${abbreviate(totalTransfer)}\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
      }
    }
  } else {
    // Blocker loses
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[blocker] -= pay;
        scores[i] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} loses block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(totalTransfer)} total\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} receives ${abbreviate(pay)}\n`;
      }
    }
  }
  
  nextGameStarter = blocker;
  setTimeout(() => alert(message), 100);
}

function updateScoresForForceBlock(gameState) {
  let values = computePlayerValues(gameState.players);
  let minVal = Math.min(...gameState.playerOrder.map(p => values[p]));
  let winners = [];
  let losers = [];
  
  for (let i of gameState.playerOrder) {
    if (values[i] === minVal) {
      winners.push(i);
    } else {
      losers.push(i);
    }
  }

  let message;
  if (winners.length === gameState.playerOrder.length) {
    // Everyone ties
    message = `Force block! All players tie.\n\nNo payout.\nPlayer ${getPlayerNumber(nextGameStarter)} starts next game.`;
    nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
  } else {
    let total_pot = 0;
    losers.forEach(l => {
      let pay = values[l] * bet;
      scores[l] -= pay;
      total_pot += pay;
    });
    let share = total_pot / winners.length;
    winners.forEach(w => {
      scores[w] += share;
    });
    
    if (winners.length === 1) {
      nextGameStarter = winners[0];
      message = `Force block! Player ${getPlayerNumber(nextGameStarter)} has lowest hand.\n\n`;
      message += `Player ${getPlayerNumber(nextGameStarter)} wins ${abbreviate(total_pot)}\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    } else {
      nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
      message = `Force block! Tie between: ${winners.map(w => `Player ${getPlayerNumber(w)}`).join(', ')}\n\n`;
      message += `Winners share ${abbreviate(total_pot)} (${abbreviate(share)} each)\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    }
  }
  
  setTimeout(() => alert(message), 100);
}

///
    function showNewGameButton() {
      const newGameBtn = document.getElementById('new-game');
      newGameBtn.style.display = 'block';
      newGameBtn.onclick = () => {
        initAudioContext();
        newGameBtn.style.display = 'none';
        gameState = setupGame();
        renderGame(gameState);
        if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
          setTimeout(() => playAI(gameState), 1500);
        }
      };
    }
///

// UPDATED renderGame function - use currentActivePlayerTurn
function renderGame(gameState) {
  const {players, board, gameOver, selectedIndex, isThisFirstGame} = gameState;
  const tableDiv = document.getElementById('table');

  tableDiv.innerHTML = '';
  board.tiles.forEach(({tile, x, y, isHorizontal}, index) => {
    const tileDiv = document.createElement('div');
    tileDiv.className = 'table-tile';
    if (isHorizontal) tileDiv.classList.add('horizontal');
    if (board.tiles.length === 1 && index === 0 && isDouble(tile)) {
      tileDiv.classList.add('first-double');
    }

    if (!gameOver) {
      let isLeftEnd = index === (board.leftEnd ? board.leftEnd.tileIndex : -1);
      let isRightEnd = index === (board.rightEnd ? board.rightEnd.tileIndex : -1);
      let isDoubleEnd = isDouble(tile);
      if (isLeftEnd) {
        const openSide = board.leftEnd.openSide;
        if (isHorizontal) {
          if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
          else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
        } else {
          if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
          else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
        }
      }
      if (isRightEnd) {
        const openSide = board.rightEnd.openSide;
        if (isHorizontal) {
          if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
          else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
        } else {
          if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
          else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
        }
      }
    }

    let tileData = isHorizontal ? { left: tile.bottom, right: tile.top } : tile;
    tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
    tileDiv.style.left = `${x + board.offsetX}px`;
    tileDiv.style.top = `${y + board.offsetY}px`;
    tableDiv.appendChild(tileDiv);
  });

  let leftPlaceholder = null;
  let rightPlaceholder = null;

  if (!gameOver && currentActivePlayerTurn === 0 && board.tiles.length > 0) {
    const dummyTile = {top: 0, bottom: 0};
    const tableRect = tableDiv.getBoundingClientRect();
    const hand = players[0];

    let tileToCheck = null;
    if (draggedTile) {
      tileToCheck = draggedTile;
    } else if (selectedIndex !== -1) {
      tileToCheck = hand[selectedIndex];
    }

    const shouldShowLeft = tileToCheck
      ? canPlayOnEnd(tileToCheck, board.leftEnd.value)
      : hand.some(tile => canPlayOnEnd(tile, board.leftEnd.value));

    const shouldShowRight = tileToCheck
      ? canPlayOnEnd(tileToCheck, board.rightEnd.value)
      : hand.some(tile => canPlayOnEnd(tile, board.rightEnd.value));

    if (shouldShowLeft) {
      const leftPlacement = calculatePlacement(board, 'left', tableRect, dummyTile);
      leftPlaceholder = document.createElement('div');
      leftPlaceholder.className = 'table-tile placeholder';
      if (leftPlacement.isHorizontal) leftPlaceholder.classList.add('horizontal');
      leftPlaceholder.style.left = `${leftPlacement.x + board.offsetX}px`;
      leftPlaceholder.style.top = `${leftPlacement.y + board.offsetY}px`;
      leftPlaceholder.style.border = '2px dashed #6a6a6a';
      tableDiv.appendChild(leftPlaceholder);

      leftPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.leftEnd.value)) leftPlaceholder.style.border = '2px dashed yellow'; };
      leftPlaceholder.ondragleave = () => { leftPlaceholder.style.border = '2px dashed #6a6a6a'; };
      leftPlaceholder.ondrop = (e) => { e.preventDefault(); leftPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.leftEnd.value)) playTile(gameState, tileData, 'left'); } catch (err) {} };
      leftPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.leftEnd.value)) playTile(gameState, selectedTile, 'left'); } };
    }

    if (shouldShowRight) {
      const rightPlacement = calculatePlacement(board, 'right', tableRect, dummyTile);
      rightPlaceholder = document.createElement('div');
      rightPlaceholder.className = 'table-tile placeholder';
      if (rightPlacement.isHorizontal) rightPlaceholder.classList.add('horizontal');
      rightPlaceholder.style.left = `${rightPlacement.x + board.offsetX}px`;
      rightPlaceholder.style.top = `${rightPlacement.y + board.offsetY}px`;
      rightPlaceholder.style.border = '2px dashed #6a6a6a';
      tableDiv.appendChild(rightPlaceholder);

      rightPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.rightEnd.value)) rightPlaceholder.style.border = '2px dashed yellow'; };
      rightPlaceholder.ondragleave = () => { rightPlaceholder.style.border = '2px dashed #6a6a6a'; };
      rightPlaceholder.ondrop = (e) => { e.preventDefault(); rightPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.rightEnd.value)) playTile(gameState, tileData, 'right'); } catch (err) {} };
      rightPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.rightEnd.value)) playTile(gameState, selectedTile, 'right'); } };
    }
  }

  if (!gameOver && currentActivePlayerTurn === 0) {
    if (board.tiles.length === 0) {
      tableDiv.ondragover = (e) => e.preventDefault();
      tableDiv.ondrop = (e) => { e.preventDefault(); try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); playTile(gameState, tileData, 'right'); } catch (err) {} };
      tableDiv.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; playTile(gameState, selectedTile, 'right'); } };
    }
  }

  document.querySelectorAll('.player-hand').forEach((hand, index) => {
    if (!gameState.playerOrder.includes(index)) {
      hand.style.display = 'none';
      return;
    }
    hand.style.display = 'flex';
    hand.innerHTML = '';
    const scoreDiv = document.createElement('div');
    scoreDiv.className = 'score';
    const scoreValue = scores[index];
    const scoreText = scoreValue < 0 ? '-$' + Math.abs(scoreValue) : '$' + scoreValue;
    const scoreLength = scoreText.length;
    const numCoins = Math.max(3, Math.ceil(scoreLength / 2));
    const coinsHtml = '<span class="coin">ü™ô</span>'.repeat(numCoins);
    let coinColorClass = 'yellow';
    if (scoreValue >= 1000000000) {
      coinColorClass = 'red';
    } else if (scoreValue >=500000000) {
      coinColorClass = 'orange';
    } else if (scoreValue >= 100000000) {
      coinColorClass = 'violet';
    } else if (scoreValue <= -1) {
      coinColorClass = 'silver';
    }
    scoreDiv.innerHTML = `<span class="score-arrow">${!gameOver && index === currentActivePlayerTurn ? '‚û§' : ''}</span><span class="score-text">[P${getPlayerNumber(index)}]</span><div class="score-number"><div class="coins-container ${coinColorClass}">${coinsHtml}</div><span class="score-text" style="position: absolute; top: 50%; left: 50%;top: -1px; transform: translate(calc(-50% - 10px), calc(-50% + 3px)); z-index: 2; color: black;">${scoreText}</span></div>`;

    const tilesContainer = document.createElement('div');
    tilesContainer.className = 'tiles-container';
    let playButtons;

    let highestDoubleInHand = null;
    if (!gameOver && index === 0 && board.tiles.length === 0 && isThisFirstGame) {
      if (gameState.highestDouble) {
        highestDoubleInHand = gameState.highestDouble;
      }
    }
///
// Calculate dynamic overlap
const rootStyle = getComputedStyle(document.documentElement);
const tileWidth = parseFloat(rootStyle.getPropertyValue('--tile-width'));
const tileHeight = parseFloat(rootStyle.getPropertyValue('--tile-height'));
const tileGap = parseFloat(rootStyle.getPropertyValue('--tile-gap'));

const numTiles = players[index].length;
let containerWidth = window.innerWidth - 20; // Screen width minus padding
let containerHeight = window.innerHeight - 20; // Screen height minus padding
let overlapStyle = '';

if (index === 0 || index === 2) {
  // Horizontal layout (South, North)
  const totalWidth = numTiles * tileWidth + (numTiles - 1) * tileGap;
  if (totalWidth > containerWidth) {
    tilesContainer.classList.add('overlapped', 'horizontal');
    const overlap = (totalWidth - containerWidth) / (numTiles - 1);
    overlapStyle = `margin-left: -${overlap.toFixed(2)}px;`;
  }
} else {
  // Vertical layout (East, West)
  const totalHeight = numTiles * tileHeight + (numTiles - 1) * tileGap;
  if (totalHeight > containerHeight) {
    tilesContainer.classList.add('overlapped', 'vertical');
    const overlap = (totalHeight - containerHeight) / (numTiles - 1);
    overlapStyle = `margin-top: -${overlap.toFixed(2)}px;`;
  }
}

// Apply dynamic overlap via inline style
if (overlapStyle) {
  const styleElement = document.createElement('style');
  styleElement.textContent = `
    .player-hand[data-player="${index}"] .tiles-container.overlapped > .tile:not(:first-child) {
      ${overlapStyle}
    }
  `;
  hand.appendChild(styleElement);
}
///
    if (!gameOver && index === 0) {
      playButtons = document.createElement('div');
      playButtons.className = 'play-buttons';
      playButtons.innerHTML = `<button class="play-left">Play Left</button><button class="play-right">Play Right</button>`;
      playButtons.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
    }

    players[index].forEach((tile, tileIdx) => {
      const tileDiv = document.createElement('div');
      tileDiv.className = 'tile';
      
      if (!gameOver && index !== 0 && tileMode === 'Close') {
        tileDiv.innerHTML = generateBackTileSvg(false);
      } else {
        tileDiv.innerHTML = generateTileSvg(false, tile);
        tileDiv.dataset.top = tile.top;
        tileDiv.dataset.bottom = tile.bottom;

        if (!gameOver && index === 0) {
          // ALWAYS make Player 0's tiles clickable (for both playing and sorting)
          tileDiv.style.cursor = 'pointer';
          
          // Tile click handler - works anytime
          tileDiv.onclick = (e) => {
            initAudioContext();
            if (!soundLocked) canPlaySound = true;
            e.stopPropagation();
            if (tileDiv.dataset.justMoved === 'true') {
              delete tileDiv.dataset.justMoved;
              return;
            }
            handleTileClick(gameState, tileIdx, playButtons);
          };
          
          if (selectedIndex === tileIdx) tileDiv.classList.add('selected');

          // Determine if tile is playable (for drag-and-drop)
          let isPlayable = false;
          if (board.tiles.length === 0) {
            if (isThisFirstGame) {
              if (gameState.highestDouble && (tile.top === gameState.highestDouble.top && tile.bottom === gameState.highestDouble.bottom)) {
                isPlayable = true;
              }
            } else {
              isPlayable = true;
            }
          } else {
            isPlayable = canPlayTile(tile, board);
          }

          // Only enable drag-and-drop when it's Player 0's turn AND tile is playable
          if (isPlayable && currentActivePlayerTurn === 0) {
            tileDiv.classList.add('draggable');
            tileDiv.draggable = true;

            tileDiv.ondragstart = (e) => {
              initAudioContext();
              if (!soundLocked) canPlaySound = true;
              draggedTile = tile;
              gameState.selectedIndex = -1;
              e.dataTransfer.setData('text/plain', JSON.stringify(tile));
            };

            tileDiv.addEventListener('touchstart', (e) => {
              initAudioContext();
              if (!soundLocked) canPlaySound = true;
              draggedTile = tile;
              gameState.selectedIndex = -1;

              const touch = e.touches[0];
              const ghost = tileDiv.cloneNode(true);
              ghost.style.position = 'fixed';
              ghost.style.pointerEvents = 'none';
              ghost.style.zIndex = 1000;
              document.body.appendChild(ghost);
              ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
              ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;
              let moved = false;
              
              const onTouchMove = (ev) => {
                ev.preventDefault();
                if (ev.touches.length === 1) {
                  moved = true;
                  const t = ev.touches[0];
                  ghost.style.left = `${t.clientX - ghost.offsetWidth / 2}px`;
                  ghost.style.top = `${t.clientY - ghost.offsetHeight / 2}px`;
                  if (board.tiles.length > 0) {
                    if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                    if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                    const dropX = t.clientX;
                    const dropY = t.clientY;
                    if (leftPlaceholder && canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                      const leftRect = leftPlaceholder.getBoundingClientRect();
                      if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                        leftPlaceholder.style.border = '2px dashed yellow';
                      }
                    }
                    if (rightPlaceholder && canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                      const rightRect = rightPlaceholder.getBoundingClientRect();
                      if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                        rightPlaceholder.style.border = '2px dashed yellow';
                      }
                    }
                  }
                }
              };
              
              const onTouchEnd = (ev) => {
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                ghost.remove();
                if (board.tiles.length > 0) {
                  if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                  if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                }
                if (!moved) {
                  draggedTile = null;
                  return;
                }
                if (moved) {
                  tileDiv.dataset.justMoved = 'true';
                }
                const dropTouch = ev.changedTouches[0] || {clientX: 0, clientY: 0};
                let dropped = false;
                const dropX = dropTouch.clientX;
                const dropY = dropTouch.clientY;
                if (board.tiles.length === 0) {
                  const tableRect = tableDiv.getBoundingClientRect();
                  if (dropX > tableRect.left && dropX < tableRect.right && dropY > tableRect.top && dropY < tableRect.bottom) {
                    playTile(gameState, draggedTile, 'right');
                    dropped = true;
                  }
                } else {
                  if (leftPlaceholder) {
                    const leftRect = leftPlaceholder.getBoundingClientRect();
                    if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                      if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                        playTile(gameState, draggedTile, 'left');
                        dropped = true;
                      }
                    }
                  }
                  if (rightPlaceholder) {
                    const rightRect = rightPlaceholder.getBoundingClientRect();
                    if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                      if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                        playTile(gameState, draggedTile, 'right');
                        dropped = true;
                      }
                    }
                  }
                }
                draggedTile = null;
              };
              
              document.addEventListener('touchmove', onTouchMove, {passive: false});
              document.addEventListener('touchend', onTouchEnd, {passive: false});
            });
          }
        }
      }
      tilesContainer.appendChild(tileDiv);
    });

    /*if (index === 2) { hand.appendChild(tilesContainer); hand.appendChild(scoreDiv); }
	
    else if (index === 0) { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); }
	
    else { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); }*/
	if (index === 2) { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); }
	else{
	hand.appendChild(tilesContainer);
    hand.appendChild(scoreDiv);
	}

    if (playButtons) {
      hand.appendChild(playButtons);
      // Only show play buttons during Player 0's active turn
      if (currentActivePlayerTurn === 0 && selectedIndex !== -1) {
        const selectedTileData = players[0][selectedIndex];
        const leftBtn = playButtons.querySelector('.play-left');
        const rightBtn = playButtons.querySelector('.play-right');
        leftBtn.style.display = 'none';
        rightBtn.style.display = 'none';

        if (board.tiles.length === 0) {
          if (isThisFirstGame) {
            if (gameState.highestDouble && (selectedTileData.top === gameState.highestDouble.top && selectedTileData.bottom === gameState.highestDouble.bottom)) {
              rightBtn.style.display = 'inline-block';
              rightBtn.textContent = `Play First`;
              rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
            }
          } else {
            rightBtn.style.display = 'inline-block';
            rightBtn.textContent = `Play First`;
            rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
          }
        } else {
          const leftEnd = board.leftEnd.value;
          const rightEnd = board.rightEnd.value;
          if (canPlayOnEnd(selectedTileData, leftEnd)) {
            leftBtn.style.display = 'inline-block';
            leftBtn.textContent = `Play Left (${leftEnd})`;
            leftBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'left'); };
          }
          if (canPlayOnEnd(selectedTileData, rightEnd)) {
            rightBtn.style.display = 'inline-block';
            rightBtn.textContent = `Play Right (${rightEnd})`;
            rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
          }
        }
      }
    }
  });
    // ADD THE BONEYARD CODE HERE (at the very end, before closing the function)
  const boneyardDiv = document.getElementById('boneyard');
  if (gameState.boneyard && gameState.boneyard.length > 0 && gameState.playerOrder.length < 4) {
    boneyardDiv.style.display = 'block';
    const tilesDiv = document.getElementById('boneyard-tiles');
    tilesDiv.innerHTML = '';
    for (let i = 0; i < gameState.boneyard.length; i++) {
      const rect = document.createElement('div');
      rect.style.width = '6px';
      rect.style.height = '12px';
      rect.style.background = 'black';
      rect.style.border = '1px solid #222';
      rect.style.borderRadius = '2px';
      tilesDiv.appendChild(rect);
    }
  } else {
    boneyardDiv.style.display = 'none';
  }
  
}
 /// 
    function centerTilesOnResize() {
      if (!gameState || !gameState.board) return;
      const table = document.getElementById('table');
      const tiles = table.querySelectorAll('.table-tile');
      if (!tiles.length) return;

      const tableRect = table.getBoundingClientRect();
      const centerX = tableRect.width / 2;
      const centerY = tableRect.height / 2;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      tiles.forEach(tile => {
        const rect = tile.getBoundingClientRect();
        const tableBox = table.getBoundingClientRect();
        const left = rect.left - tableBox.left;
        const top = rect.top - tableBox.top;
        minX = Math.min(minX, left);
        minY = Math.min(minY, top);
        maxX = Math.max(maxX, left + rect.width);
        maxY = Math.max(maxY, top + rect.height);
      });

      const tilesCenterX = (minX + maxX) / 2;
      const tilesCenterY = (minY + maxY) / 2;

      const offsetX = centerX - tilesCenterX;
      const offsetY = centerY - tilesCenterY;

      tiles.forEach(tile => {
        const left = parseFloat(tile.style.left || 0);
        const top = parseFloat(tile.style.top || 0);
        tile.style.left = `${left + offsetX}px`;
        tile.style.top = `${top + offsetY}px`;
      });
    }

    window.addEventListener('resize', centerTilesOnResize);

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(() => console.log('‚úÖ Service worker registered'))
        .catch(err => console.error('SW registration failed:', err));
    }
  </script>
</body>

</html>