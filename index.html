<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Dominoes</title>
    <style>
        :root {
            --tile-width: 25px;
            --tile-height: 50px;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #444;
            position: fixed;
            overflow: hidden;
			  font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-weight: 400;
        }
#game-container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 70%;
  height: 70%;
  overflow: visible;
}

/* #table centered independently in viewport */
#table {
  width: 100%;
  height: 100%;
  position: fixed; /* keeps it centered on screen */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 5;
}


        .player-hand {
            position: fixed;
            text-align: center;
            z-index: 100;
            padding: 5px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .player-south { 
            bottom: 8px; 
            left: 50%; 
            transform: translateX(-50%); 
            width: 100vw;
            justify-content: center;
            height: 150px;
        }
        .player-east { 
            top: 50%; 
            right: -25px; 
            transform: translateY(-50%);
            height: 100vh;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            min-width: 150px;
        }
        .player-east .score {
            transform: rotate(-90deg) translateY(50%);
            margin-right: -30px;
        }
        .player-north { 
            top: -18px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 100vw;
            justify-content: center;
            height: 140px;
        }
		  .player-east .score {
            transform: rotate(-90deg) translateY(50%);
            margin-left: -25px;
        }
        .player-west { 
            top: 50%; 
            left: -20px; 
            transform: translateY(-50%);
            height: 100vh;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            justify-content: center;
            min-width: 150px;
        }
        .player-west .score {
            transform: rotate(90deg) translateY(-50%);
            margin-left: -45px;
        }
        .tiles-container {
            pointer-events: auto;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 3px;
            min-height: 80px;
        }
        .player-east .tiles-container,
        .player-west .tiles-container {
            flex-direction: column;
            min-height: calc(70px * 7 + 3px * 6);
            min-width: 40px;
        }
        .tile {
            display: block;
            width: 35px;
            height: 70px;
            border: 2px solid black;
            cursor: pointer;
            border-radius: 8px;
            background-color: black;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .tile svg, .table-tile svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .selected {
            border: 3px solid yellow;
            box-shadow: 0 0 10px yellow;
        }
        .draggable {
            border: 2px dashed #6a6a6a;
        }
        .table-tile {
            position: absolute;
            width: var(--tile-width);
            height: var(--tile-height);
            border: 2px solid #666;
            border-radius: 6px;
            background-color: #1a1a1a;
            z-index: 15;
            transition: border-color 0.3s;
        }
        .table-tile.horizontal {
            width: var(--tile-height);
            height: var(--tile-width);
        }
        .table-tile.match-drop::before,
        .table-tile.match-drop::after {
            border-style: dashed !important;
        }
        .table-tile.placeholder {
            z-index: 20;
            pointer-events: auto;
            background-color: transparent;
        }
        .table-tile.end-top::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-top: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 6px 6px 0 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-bottom::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-bottom: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-left::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-left: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 6px 0 0 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-right::after {
            content: '';
            position: absolute;
            right: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-right: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 0 6px 6px 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-top::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-top: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 6px 6px 0 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-bottom::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-bottom: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-left::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-left: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 6px 0 0 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-right::after {
            content: '';
            position: absolute;
            right: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-right: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 0 6px 6px 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .tile:hover {
            border: 3px solid #0f0;
            box-shadow: 0 0 8px #0f0;
        }
        .score {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
			left:-50px;
            margin: 3px 0;
            z-index: 101;
            text-shadow: 0 0 5px #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 100px;
            pointer-events: none;
        }
        .score-arrow {
            width: 25px;
            display: inline-block;
            text-align: center;
           color: #0f0;
        }
        .score-text {
            white-space: nowrap;
			margin-left: 10px;
			color: #0f0;
        }
        .score-number {
            position: relative;
            display: inline-block;
            margin-left: 50px;	
        }

.coins-container {
    position: absolute;
    z-index: 1;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    height: 20px;
    pointer-events: none;
    display: flex;            /* ← ADDED flex layout */
    align-items: center;      /* ← ADDED */
}
.coins-container .coin {
    font-size: 18px;
    margin-left: -8px;        /* ← ADDED overlap effect */
	opacity: 0.5;
}
.coins-container .coin:first-child {
    margin-left: 0;           /* ← ADDED no margin for first coin */
}
.coins-container.yellow .coin { filter: none; }
.coins-container.violet .coin {
  filter: brightness(0) saturate(100%) invert(69%) sepia(23%) saturate(1988%) hue-rotate(248deg) brightness(104%) contrast(87%);
}

.coins-container.orange .coin {
  filter: brightness(0) saturate(50%) invert(52%) sepia(50%) saturate(1120%) hue-rotate(6deg) brightness(50%) contrast(97%);
  /* warm, vivid orange */
}

.coins-container.red .coin {
  filter: brightness(0) saturate(100%) invert(35%) sepia(71%) saturate(6921%) hue-rotate(350deg) brightness(88%) contrast(133%);
}

.coins-container.silver .coin {
  filter: brightness(0) saturate(100%) invert(88%) sepia(3%) saturate(0%) hue-rotate(193deg) brightness(95%) contrast(90%);
  /* metallic silver tone */
}

        .play-buttons {
            margin-top: 0px;
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            min-height: 40px;
            pointer-events: auto;
        }
        .play-buttons button {
            padding: 8px 15px;
            background: #0f0;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            display: none;
        }
        .play-buttons button:hover {
            background: #0c0;
            transform: scale(1.05);
        }
        #new-game {
            position: fixed;
            bottom: -12px;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 3px 10px;
			color: #fff;
           background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0f0;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            z-index: 999;
            font-size: 18px;
            font-weight: bold;
        }
        #new-game:hover {
            background: #090;
        }
      
        #bets {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            background: #444;
            color: #add8e6;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 14px;
        }
/* New: Full glow for initial double tile */
    .table-tile.first-double {
        border: 2px solid #0ff !important;
        box-shadow: 0 0 10px #0ff !important;
    }
	  #options-button {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            background: #444;
            color: #add8e6;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 14px;
        }
        #options-button:hover {
            background: #0c0;
            transform: scale(1.05);
        }
        #options-menu {
            position: fixed;
            bottom: 50px;
            left: 10px;
            background: #444;
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 10px;
            z-index: 201;
            display: none;
            color: #add8e6;
            font-size: 14px;
        }
        #options-menu label {
            display: block;
            margin: 5px 0;
        }
        #options-menu select {
            background: #444;
            color: #add8e6;
            border: 1px solid #0f0;
            border-radius: 3px;
            padding: 2px;
            font-size: 14px;
            margin-left: 5px;
        }
	/* Close button absolutely inside the menu */
.close-btn {
  position: absolute;
  top: 4px;
  right: 6px;
  cursor: pointer;
  color: #0f0;
  font-size: 16px;
  font-weight: bold;
  transition: 0.2s ease;
}
.close-btn:hover {
  color: #fff;
  transform: scale(1.2);
}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="table"></div>
    </div>
    <button id="new-game">New Game</button>
    <div id="players">
        <div class="player-hand player-south" data-player="0"></div>
        <div class="player-hand player-east" data-player="1"></div>
        <div class="player-hand player-north" data-player="2"></div>
        <div class="player-hand player-west" data-player="3"></div>
    </div>
 <button id="options-button">Options</button>

<div id="options-menu">
  <span id="close-options" class="close-btn">&times;</span>
  <label>Tile Mode:
    <select id="tileMode">
      <option value="Open">Open</option>
      <option value="Close" selected>Close</option>
    </select>
  </label>

  <label>Background Color:
    <select id="backgroundColor">
      <option value="white">White</option>
      <option value="olive">Olive</option>
      <option value="teal">Teal</option>
      <option value="indigo">Indigo</option>
	   <option value="gold">Gold</option>
      <option value="#444" selected>Grey</option>
    </select>
  </label>

  <label>Sound:
    <select id="sound">
      <option value="On" selected>On</option>
      <option value="Off">Off</option>
    </select>
  </label>

  <label>Fun Voice:
    <select id="funVoice">
      <option value="On">On</option>
      <option value="Off" selected>Off</option>
    </select>
  </label>
</div>
    <select id="bets">
        <option value="1000">1000</option>
        <option value="10000" selected>10000</option>
        <option value="20000">20000</option>
        <option value="50000">50000</option>
        <option value="100000">100000</option>
        <option value="500000">500000</option>
        <option value="1000000">1000000</option>
    </select>
    <div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);color:#ccc;font-size:14px;opacity:0.8;pointer-events:none;">Version 1.3.0</div>

<script>
document.getElementById('close-options').addEventListener('click', () => {
  document.getElementById('options-menu').style.display = 'none';
});
let audioContext = null;
let canPlaySound = true; // Changed to true to match Sound: On default
let soundLocked = false; // new flag to prevent overwriting by other code
let funVoice = false; // Added for Fun Voice default Off
let tileMode = 'Close';
let backgroundColor = '#444';
let bet = 10000;
let isOverallFirstGame = true;
let draggedTile = null;



function abbreviate(num) {
    if (num >= 1e9) {
        return (num / 1e9).toFixed(1) + 'B';
    } else if (num >= 1e6) {
        return (num / 1e6).toFixed(1) + 'M';
    } else if (num >= 1e3) {
        return (num / 1e3).toFixed(1) + 'K';
    } else {
        return num.toString();
    }
}

function formatPayout(amount) {
    return abbreviate(Math.abs(amount)) + (amount < 0 ? ' loss' : ' gain');
}

function initAudioContext() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
}

function playSound() {
    if (!canPlaySound) return;
    initAudioContext();
    let oscillator = audioContext.createOscillator();
    let gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = 523.25;
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
}

function generateBackTileSvg(isHorizontal) {
    let svg;
    if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
    } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
    }
    svg += "</svg>";
    return svg;
}

const tiles = [
    {top: 6, bottom: 6}, {top: 6, bottom: 5}, {top: 6, bottom: 4}, {top: 6, bottom: 3}, {top: 6, bottom: 2}, {top: 6, bottom: 1}, {top: 6, bottom: 0},
    {top: 5, bottom: 5}, {top: 5, bottom: 4}, {top: 5, bottom: 3}, {top: 5, bottom: 2}, {top: 5, bottom: 1}, {top: 5, bottom: 0},
    {top: 4, bottom: 4}, {top: 4, bottom: 3}, {top: 4, bottom: 2}, {top: 4, bottom: 1}, {top: 4, bottom: 0},
    {top: 3, bottom: 3}, {top: 3, bottom: 2}, {top: 3, bottom: 1}, {top: 3, bottom: 0},
    {top: 2, bottom: 2}, {top: 2, bottom: 1}, {top: 2, bottom: 0},
    {top: 1, bottom: 1}, {top: 1, bottom: 0},
    {top: 0, bottom: 0}
];

const numPlayers = 4;
const numTiles = 7;
let currentPlayer = 0;
let nextGameStarter = 0;
let lastValidPlayer = 0;
let scores = [10000000, 10000000, 10000000, 10000000];

const playerOrder = [0, 1, 2, 3];

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function generateTileSvg(isHorizontal, tileData) {
    const colors = ["", "red", "gold", "white", "red", "seagreen", "white"];
    let svg;
    if (!isHorizontal) {
        // Vertical
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
        const { top, bottom } = tileData;
        if (top > 0) {
            svg += `<g class='dots' fill='${colors[top]}'>`;
            const tops = {
                1: "<circle cx='25' cy='20' r='5' />",
                2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
                3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
                4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
            };
            svg += tops[top] + "</g>";
        }
        if (bottom > 0) {
            svg += `<g class='dots' fill='${colors[bottom]}'>`;
            const bottoms = {
                1: "<circle cx='25' cy='80' r='5' />",
                2: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='85' r='5' />",
                3: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='85' r='5' />",
                4: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
                5: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
                6: "<circle cx='15' cy='65' r='5' /><circle cx='15' cy='77' r='5' /><circle cx='15' cy='89' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='35' cy='77' r='5' /><circle cx='35' cy='89' r='5' />"
            };
            svg += bottoms[bottom] + "</g>";
        }
        svg += "<line x1='0' y1='50%' x2='100%' y2='50%' stroke='#666' stroke-width='2' />";
    } else {
        // Horizontal
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
        const { left, right } = tileData;
        svg += "<line x1='50%' y1='0' x2='50%' y2='100%' stroke='#666' stroke-width='2' />";
        if (left > 0) {
            svg += `<g class='dots' fill='${colors[left]}'>`;
            const leftPatterns = {
                1: "<circle cx='25' cy='20' r='5' />",
                2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
                3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
                4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
            };
            svg += leftPatterns[left] + "</g>";
        }
        if (right > 0) {
            svg += `<g class='dots' fill='${colors[right]}'>`;
            const rightPatterns = {
                1: "<circle cx='75' cy='30' r='5' />",
                2: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='35' r='5' />",
                3: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='35' r='5' />",
                4: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
                5: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
                6: "<circle cx='65' cy='15' r='5' /><circle cx='65' cy='27' r='5' /><circle cx='65' cy='39' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='85' cy='27' r='5' /><circle cx='85' cy='39' r='5' />"
            };
            svg += rightPatterns[right] + "</g>";
        }
    }
    svg += "</svg>";
    return svg;
}

function getTileSizes() {
    const rootStyle = getComputedStyle(document.documentElement);
    const tw = parseFloat(rootStyle.getPropertyValue('--tile-width'));
    const th = parseFloat(rootStyle.getPropertyValue('--tile-height'));
    return { V_W: tw, V_H: th, H_W: th, H_H: tw, FULL: th, OFFSET: th / 4 };
}

function setupGame() {
    const gameTiles = [...tiles];
    shuffle(gameTiles);
    let players = [];
    let boneyard = [];

    for (let i = 0; i < numPlayers; i++) {
        players[i] = gameTiles.splice(0, numTiles);
    }
    boneyard = gameTiles;
	
  const board = {
        tiles: [],
        leftEnd: null,
        rightEnd: null,
        offsetX: 0,
        offsetY: 0
    };
    
    // Determine the starting player
    const isThisFirstGame = isOverallFirstGame;
    if (isThisFirstGame) {
        // For the very first game, find the player with the highest double
        let starter = 0;
        let found = false;
        for (let n = 6; n >= 0 && !found; n--) {
            for (let p = 0; p < numPlayers; p++) {
                if (players[p].some(t => t.top === n && t.bottom === n)) {
                    starter = p;
                    found = true;
                    break;
                }
            }
        }
        currentPlayer = starter;
        isOverallFirstGame = false; // Ensure this logic only runs once
    } else {
        // For all subsequent games, the designated starter begins
        currentPlayer = nextGameStarter;
    }

    const roundHistory = [];


    return {players, boneyard, board, prevBoard: null, gameOver: false, roundHistory, selectedIndex: -1, isThisFirstGame};
}
function isDouble(tile) {
    return tile.top === tile.bottom;
}

function canPlayTile(tile, board) {
    if (!board.leftEnd) return true;
    const leftEnd = board.leftEnd.value;
    const rightEnd = board.rightEnd.value;
    return tile.top === leftEnd || tile.bottom === leftEnd || tile.top === rightEnd || tile.bottom === rightEnd;
}

function canPlayOnEnd(tile, endValue) {
    return tile.top === endValue || tile.bottom === endValue;
}

function computePlayerValues(players) {
    const values = [];
    for (let p = 0; p < numPlayers; p++) {
        let sum = 0;
        for (let tile of players[p]) {
            let pips = tile.top + tile.bottom;
            if (pips === 0) {  // double blank
                // Check if other hands have any 0-pip tile
                let otherHasZero = false;
                for (let op = 0; op < numPlayers; op++) {
                    if (op === p) continue;
                    for (let otile of players[op]) {
                        if (otile.top === 0 || otile.bottom === 0) {
                            otherHasZero = true;
                            break;
                        }
                    }
                    if (otherHasZero) break;
                }
                pips = otherHasZero ? 0 : 13;
            }
            sum += pips;
        }
        values[p] = sum;
    }
    return values;
}

// Updated simulatePlay function to handle the first move correctly
function simulatePlay(board, tile, end) {
    // If board is empty, this is the first play
    if (!board.leftEnd) {
        return {
            leftEnd: { value: tile.top },
            rightEnd: { value: tile.bottom }
        };
    }

    // Simulate the ends after playing tile on end
    let simLeftEnd = { ...board.leftEnd };
    let simRightEnd = { ...board.rightEnd };
    if (end === 'left') {
        const oldValue = simLeftEnd.value;
        if (tile.top === oldValue) {
            simLeftEnd.value = tile.bottom;
        } else {
            simLeftEnd.value = tile.top;
        }
    } else { // 'right'
        const oldValue = simRightEnd.value;
        if (tile.top === oldValue) {
            simRightEnd.value = tile.bottom;
        } else {
            simRightEnd.value = tile.top;
        }
    }
    return { leftEnd: simLeftEnd, rightEnd: simRightEnd };
}

// Helper function to check if any player can make a move on the simulated board.
function isPlayableForAnyone(players, board) {
    if (!board.leftEnd) return true; // Before first move, anyone can play.
    for (const hand of players) {
        if (hand.some(tile => canPlayTile(tile, board))) {
            return true;
        }
    }
    return false;
}

// Helper function to count known pips to gauge rarity.
function countAllPips(players, roundHistory) {
    const counts = [0, 0, 0, 0, 0, 0, 0];
    const allKnownTiles = [];
    allKnownTiles.push(...players[currentPlayer]);
    if (roundHistory) {
        for (const move of roundHistory) {
            allKnownTiles.push(move.playedTile);
        }
    }
    for (const tile of allKnownTiles) {
        counts[tile.top]++;
        counts[tile.bottom]++;
    }
    return counts;
}

function getValidMoves(hand, board) {
    const validMoves = [];
    if (!board.leftEnd) {
        hand.forEach(tile => validMoves.push({ tile, end: 'right' }));
    } else {
        hand.forEach(tile => {
            const canLeft = canPlayOnEnd(tile, board.leftEnd.value);
            const canRight = canPlayOnEnd(tile, board.rightEnd.value);
            if (canLeft) {
                validMoves.push({ tile, end: 'left' });
            }
            if (canRight) {
                if (!isDouble(tile) || !canLeft) {
                    validMoves.push({ tile, end: 'right' });
                }
            }
        });
    }
    return validMoves;
}

function isInevitableBlock(board, players, currentPlayer, depth, maxDepth = 3) {
    if (depth > maxDepth) {
        return false;
    }

    if (!isPlayableForAnyone(players, board)) {
        return true;
    }

    let nextIndex = (playerOrder.indexOf(currentPlayer) + 1) % numPlayers;
    let nextPlayer = playerOrder[nextIndex];
    let validMoves = getValidMoves(players[nextPlayer], board);

    while (validMoves.length === 0 && nextIndex !== playerOrder.indexOf(currentPlayer)) {
        nextIndex = (nextIndex + 1) % numPlayers;
        nextPlayer = playerOrder[nextIndex];
        validMoves = getValidMoves(players[nextPlayer], board);
    }

    if (validMoves.length === 0) {
        return true;
    }

    let allLeadToBlock = true;
    for (const move of validMoves) {
        const simBoard = simulatePlay(board, move.tile, move.end);
        const simPlayers = JSON.parse(JSON.stringify(players));
        const tileIndex = simPlayers[nextPlayer].findIndex(t => t.top === move.tile.top && t.bottom === move.tile.bottom);
        simPlayers[nextPlayer].splice(tileIndex, 1);

        if (simPlayers[nextPlayer].length === 0) {
            return false; // Leads to win, not block
        }

        if (!isInevitableBlock(simBoard, simPlayers, nextPlayer, depth + 1, maxDepth)) {
            allLeadToBlock = false;
            break;
        }
    }
    return allLeadToBlock;
}

function hasPreventingAlternative(hand, board, allPlayers, playerIndex, maxDepth = 3) {
    const validMoves = getValidMoves(hand, board);
    if (validMoves.length === 0) return false;

    let hasMultipleOptions = validMoves.length > 1 ||
        (validMoves.length === 1 &&
         canPlayOnEnd(validMoves[0].tile, board.leftEnd ? board.leftEnd.value : null) &&
         canPlayOnEnd(validMoves[0].tile, board.rightEnd ? board.rightEnd.value : null) &&
         board.leftEnd && board.rightEnd && board.leftEnd.value !== board.rightEnd.value);
    if (!hasMultipleOptions) return false;

    let hasNonBlockingMove = false;
    for (const move of validMoves) {
        const simBoard = simulatePlay(board, move.tile, move.end);
        const simPlayers = JSON.parse(JSON.stringify(allPlayers));
        const tileIndex = simPlayers[playerIndex].findIndex(t => t.top === move.tile.top && t.bottom === move.tile.bottom);
        simPlayers[playerIndex].splice(tileIndex, 1);

        if (simPlayers[playerIndex].length === 0) {
            hasNonBlockingMove = true;
            break;
        }

        if (!isInevitableBlock(simBoard, simPlayers, playerIndex, 1, maxDepth)) {
            hasNonBlockingMove = true;
            break;
        }
    }
    return hasNonBlockingMove;
}

function playAI(gameState) {
    const { players, board, roundHistory, isThisFirstGame } = gameState;
    const playerHand = players[currentPlayer];

    // --- START: Enforce highest double on first play for AI only in overall first game ---
    if (!board.leftEnd && isThisFirstGame) {
        const doubles = playerHand.filter(tile => isDouble(tile));
        if (doubles.length > 0) {
            // Find the highest double
            let highestDouble = doubles.reduce((max, tile) => tile.top > max.top ? tile : max, doubles[0]);
            // Play the highest double
            playTile(gameState, highestDouble, 'right');
            return; // Exit the function after playing
        }
    }
    // --- END: Enforce highest double on first play for AI ---

    let bestMove = { tile: null, end: null, score: -Infinity };

    const validMoves = getValidMoves(playerHand, board);

    if (validMoves.length === 0) {
        return;
    }
    
    for (const move of validMoves) {
        let score = 0;
        const { tile, end } = move;

        const simBoard = simulatePlay(board, tile, end);
        const simPlayers = JSON.parse(JSON.stringify(players));
        const tileIndex = simPlayers[currentPlayer].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
        simPlayers[currentPlayer].splice(tileIndex, 1);

        if (simPlayers[currentPlayer].length === 0) {
            score = 1000000; 
            bestMove = { tile, end, score };
            break;
        }

        const isBlock = !isPlayableForAnyone(simPlayers, simBoard);
        
        if (isBlock) {
            const simValues = computePlayerValues(simPlayers);
            const myValue = simValues[currentPlayer];
            const minValue = Math.min(...simValues);

            if (myValue <= minValue) {
                let hadNonBlockingAlternative = false;
                for (const otherMove of validMoves) {
                    if (otherMove.tile === move.tile && otherMove.end === move.end) continue;
                    const otherSimBoard = simulatePlay(board, otherMove.tile, otherMove.end);
                    const otherSimPlayers = JSON.parse(JSON.stringify(players));
                    const otherTileIndex = otherSimPlayers[currentPlayer].findIndex(t => t.top === otherMove.tile.top && t.bottom === otherMove.tile.bottom);
                    otherSimPlayers[currentPlayer].splice(otherTileIndex, 1);
                    if (isPlayableForAnyone(otherSimPlayers, otherSimBoard)) {
                        hadNonBlockingAlternative = true;
                        break;
                    }
                }
                
                if (hadNonBlockingAlternative) {
                    score += 5000;
                } else {
                    score += 2500;
                }
            } else {
                score -= 10000;
            }
        } else {
            let tileValue = tile.top + tile.bottom;
            if (isDouble(tile)) {
                tileValue += 10;
            }
            score += tileValue * 10;

            const nextPlayerIndex = (playerOrder.indexOf(currentPlayer) + 1) % numPlayers;
            const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
            if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
                score += 200;
            }

            const pipsCount = countAllPips(players, roundHistory);
            const leftEndVal = simBoard.leftEnd.value;
            const rightEndVal = simBoard.rightEnd.value;
            score += (8 - pipsCount[leftEndVal]) * 5;
            score += (8 - pipsCount[rightEndVal]) * 5;
        }

        if (score > bestMove.score) {
            bestMove = { tile, end, score };
        }
    }

    if (bestMove.tile) {
        playTile(gameState, bestMove.tile, bestMove.end);
    } else {
         console.error("AI couldn't decide on a move. Playing first valid move.");
         if (validMoves.length > 0) {
            playTile(gameState, validMoves[0].tile, validMoves[0].end);
         }
    }
}

function calculatePlacement(board, end, tableRect, tile) {
    const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();
    const MARGIN = 0; 

    let e = board[end === 'left' ? 'leftEnd' : 'rightEnd'];
    let isLeftChain = end === 'left';
    let turnDir = isLeftChain ? 'up' : 'down';

    let p = {};
    let hdir = e.dir; // 'left' or 'right'
    let isDoubleTile = isDouble(tile);

    // New: For doubles, prioritize vertical
    let tryVerticalFirst = isDoubleTile;

    // --- FIXED #1: only trigger vertical for doubles if near the edge ---
    if (isDoubleTile) {
        const nearLeftEdge = e.x - FULL * 1.5 < MARGIN + FULL * 2;
        const nearRightEdge = e.x + FULL * 2.5 > tableRect.width - (MARGIN + FULL * 2);
        if ((isLeftChain && nearLeftEdge) || (!isLeftChain && nearRightEdge)) {
            tryVerticalFirst = true;
        } else {
            tryVerticalFirst = false; // stay horizontal if enough space
        }
    }

    // Try vertical first if double & near edge
    if (tryVerticalFirst) {
        if (turnDir === 'up') {
            p.x = e.x - OFFSET;
            p.y = e.y - (FULL + OFFSET);
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + OFFSET;
        } else {
            p.x = e.x - OFFSET;
            p.y = e.y + OFFSET;
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + FULL - OFFSET;
        }

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        p.boundCheck = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                        v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (!p.boundCheck) {
            let newHdir = hdir === 'left' ? 'right' : 'left';
            p.newHdir = newHdir;
            p.turnDir = turnDir;
            return p;
        } else {
            turnDir = isLeftChain ? 'up' : 'down';
        }
    }

    // Fallback/Try horizontal
    if (hdir === 'left') {
        p.x = e.x - (FULL + OFFSET);
        p.y = e.y - OFFSET;
        p.isHorizontal = true;
        p.width = H_W;
        p.height = H_H;
        p.nextEndX = p.x + OFFSET;
        p.nextEndY = p.y + OFFSET;
    } else {
        p.x = e.x + OFFSET;
        p.y = e.y - OFFSET;
        p.isHorizontal = true;
        p.width = H_W;
        p.height = H_H;
        p.nextEndX = p.x + FULL - OFFSET;
        p.nextEndY = p.y + OFFSET;
    }

    const eff_x = p.x + board.offsetX;
    const eff_y = p.y + board.offsetY;
    p.boundCheck = (eff_x < MARGIN || eff_x + p.width > tableRect.width - MARGIN ||
                    eff_y < MARGIN || eff_y + p.height > tableRect.height - MARGIN);

    if (!p.boundCheck) {
        return p;
    } else {
        // --- FIXED #2: non-doubles also turn vertical when actually out of bounds ---
        if (turnDir === 'up') {
            p.x = e.x - OFFSET;
            p.y = e.y - (FULL + OFFSET);
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + OFFSET;
        } else {
            p.x = e.x - OFFSET;
            p.y = e.y + OFFSET;
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + FULL - OFFSET;
        }

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        let v_bound = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                       v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (v_bound) {
            let shiftX = 0, shiftY = 0;
            if (v_eff_x < MARGIN) shiftX = MARGIN - v_eff_x;
            else if (v_eff_x + p.width > tableRect.width - MARGIN)
                shiftX = (tableRect.width - MARGIN) - (v_eff_x + p.width);
            if (v_eff_y < MARGIN) shiftY = MARGIN - v_eff_y;
            else if (v_eff_y + p.height > tableRect.height - MARGIN)
                shiftY = (tableRect.height - MARGIN) - (v_eff_y + p.height);
            board.offsetX += shiftX;
            board.offsetY += shiftY;
        }

        let newHdir = hdir === 'left' ? 'right' : 'left';
        p.newHdir = newHdir;
        p.turnDir = turnDir;
        return p;
    }
}



function rotateTile(tile) {
    return { top: tile.bottom, bottom: tile.top };
}

function handleTileClick(gameState, tileIndex, playButtons) {
    const { players, selectedIndex, board, isThisFirstGame } = gameState;
    const hand = players[0];
    const clickedTile = hand[tileIndex];

    if (selectedIndex === -1) {
        gameState.selectedIndex = tileIndex;
    } else if (selectedIndex === tileIndex) {
        // Don't rotate if it's first move with highest double requirement for overall first game
        if (board.tiles.length === 0 && isThisFirstGame) {
            const doubles = hand.filter(t => isDouble(t));
            if (doubles.length > 0) {
                const highestDouble = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
                if (clickedTile.top === highestDouble.top && clickedTile.bottom === highestDouble.bottom) {
                    return; // Don't rotate required highest double
                }
            }
        }
        hand[tileIndex] = rotateTile(clickedTile);
    } else {
        const selectedTile = hand[selectedIndex];
        hand[selectedIndex] = clickedTile;
        hand[tileIndex] = selectedTile;
        gameState.selectedIndex = -1;
    }

    renderGame(gameState);
}

function playTile(gameState, tile, end) {
    const { players, board, roundHistory, isThisFirstGame } = gameState;
    const playerHand = players[currentPlayer];
    const tileIndex = playerHand.findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
    
    if (tileIndex === -1 || !canPlayTile(tile, board)) {
        alert("Invalid move!");
        return false;
    }

    // Enforce highest double on first play only for overall first game
    if (board.tiles.length === 0 && isThisFirstGame) {
        const doubles = playerHand.filter(t => isDouble(t));
        if (doubles.length > 0) {
            const highestDouble = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
            if (tile.top !== highestDouble.top || tile.bottom !== highestDouble.bottom) {
                alert("Must play highest double first!");
                return false;
            }
        }
        // For non-first games, no enforcement
    }

    const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();

    gameState.prevBoard = board.leftEnd ? {
        leftEnd: {...board.leftEnd}, 
        rightEnd: {...board.rightEnd}
    } : null;

    const playedTile = playerHand.splice(tileIndex, 1)[0];
    
    // Reset selection if player 0 played
    if (currentPlayer === 0) {
        gameState.selectedIndex = -1;
    }
    
    // FIXED: Store minimal info in round history - we'll recalculate alternatives when needed
    if(roundHistory) {
        roundHistory.push({
            player: currentPlayer,
            playedTile: {...playedTile},
            end: end,
            boardBefore: gameState.prevBoard
        });
    }
    
    const tableDiv = document.getElementById('table');
    const tableRect = tableDiv.getBoundingClientRect();
    
    let x, y, isHorizontal, displayTop, displayBottom, displayLeft, displayRight;

    const isFirst = board.tiles.length === 0;
    let e, turnDir;
    let isLeftChain = end === 'left';
    turnDir = isLeftChain ? 'up' : 'down';

    if (isFirst) {
        const isFirstDouble = isDouble(playedTile);
        if (isFirstDouble) {
            isHorizontal = false;
            x = tableRect.width / 2 - V_W / 2;
            y = tableRect.height / 2 - V_H / 2;
            displayTop = playedTile.top;
            displayBottom = playedTile.bottom;
            const centerX = x + V_W / 2;
            const topY = y + OFFSET;
            const bottomY = y + V_H - OFFSET;
            board.leftEnd = { value: playedTile.top, x: centerX, y: topY, dir: 'left', openSide: 'up' };
            board.rightEnd = { value: playedTile.bottom, x: centerX, y: bottomY, dir: 'right', openSide: 'down' };
        } else {
            x = tableRect.width / 2 - H_W / 2;
            y = tableRect.height / 2 - H_H / 2;
            isHorizontal = true;
            displayTop = playedTile.bottom;
            displayBottom = playedTile.top;
            displayLeft = playedTile.top;
            displayRight = playedTile.bottom;
            board.leftEnd = { value: playedTile.top, x: x + OFFSET, y: y + OFFSET, dir: 'left', openSide: 'left' };
            board.rightEnd = { value: playedTile.bottom, x: x + FULL - OFFSET, y: y + OFFSET, dir: 'right', openSide: 'right' };
        }
    } else {
        e = (end === 'left') ? board.leftEnd : board.rightEnd;
        const placement = calculatePlacement(board, end, tableRect, playedTile);
        x = placement.x;
        y = placement.y;
        isHorizontal = placement.isHorizontal;
        e.x = placement.nextEndX;
        e.y = placement.nextEndY;

        const oldValue = e.value;
        let connectingValue, newEndValue;
        if (tile.top === oldValue) {
            connectingValue = tile.top;
            newEndValue = tile.bottom;
        } else {
            connectingValue = tile.bottom;
            newEndValue = tile.top;
        }
        e.value = newEndValue;

        if (isHorizontal) {
            if (e.dir === 'left') {
                displayTop = connectingValue;
                displayBottom = newEndValue;
            } else {
                displayTop = newEndValue;
                displayBottom = connectingValue;
            }
        } else {
            if (turnDir === 'up') {
                displayTop = newEndValue;
                displayBottom = connectingValue;
            } else {
                displayTop = connectingValue;
                displayBottom = newEndValue;
            }
        }

        if (placement.newHdir) {
            e.dir = placement.newHdir;
            e.openSide = placement.turnDir;
        } else {
            e.openSide = e.dir;
        }
    }

    let tileData;
    if (isHorizontal) {
        displayLeft = displayBottom;
        displayRight = displayTop;
        tileData = { left: displayLeft, right: displayRight };
    } else {
        tileData = { top: displayTop, bottom: displayBottom };
    }
    const tileDiv = document.createElement('div');
    tileDiv.className = 'table-tile';
    if (isHorizontal) tileDiv.classList.add('horizontal');
    tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
    tileDiv.style.left = `${x + board.offsetX}px`;
    tileDiv.style.top = `${y + board.offsetY}px`;
    
    tableDiv.appendChild(tileDiv);
    board.tiles.push({ tile: { top: displayTop, bottom: displayBottom }, x, y, isHorizontal });
    
    const pushedIndex = board.tiles.length - 1;
    if (board.tiles.length === 1) {
        board.leftEnd.tileIndex = pushedIndex;
        board.rightEnd.tileIndex = pushedIndex;
    } else {
        if (end === 'left') {
            board.leftEnd.tileIndex = pushedIndex;
        } else {
            board.rightEnd.tileIndex = pushedIndex;
        }
    }

    playSound();
    lastValidPlayer = currentPlayer;

    if (playerHand.length === 0) {
        handleNormalGameWin(gameState);
        return true;
    }

    const currentIndex = playerOrder.indexOf(currentPlayer);
    let firstSkipped = -1;
    let checkedPlayers = 0;
    let nextIndex = (currentIndex + 1) % numPlayers;
    let nextPlayer = playerOrder[nextIndex];

    if (!players[nextPlayer].some(t => canPlayTile(t, board))) {
        firstSkipped = nextPlayer;
        checkedPlayers = 1;
        nextIndex = (nextIndex + 1) % numPlayers;
        nextPlayer = playerOrder[nextIndex];
        while (checkedPlayers < numPlayers && !players[nextPlayer].some(t => canPlayTile(t, board))) {
            checkedPlayers++;
            nextIndex = (nextIndex + 1) % numPlayers;
            nextPlayer = playerOrder[nextIndex];
        }
    }

    if (checkedPlayers === numPlayers) {
        handleBlockedGame(gameState, lastValidPlayer, firstSkipped, playedTile, end);
        return true;
    }

    currentPlayer = nextPlayer;
    renderGame(gameState);
    
    if (!gameState.gameOver && currentPlayer !== 0) {
        setTimeout(() => playAI(gameState), 1500);
    }
    return true;
}

function getPreviousPlayer(p) {
    return (p - 1 + numPlayers) % numPlayers;
}

function updateScoresForWin(winner, gameState) {
    let values = computePlayerValues(gameState.players);
    let pot = 0;
    for (let i = 0; i < numPlayers; i++) {
        if (i !== winner) {
            let pay = values[i] * bet;
            pot += pay;
            scores[i] -= pay;
        }
    }
    scores[winner] += pot;
    nextGameStarter = winner;
    let message = `Player ${getPlayerNumber(winner)} wins ${abbreviate(pot)}\n\n`;
    for (let i = 0; i < numPlayers; i++) {
        if (i !== winner) {
            let pay = values[i] * bet;
            message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
        }
    }
    setTimeout(() => alert(message), 100);
}

function updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState) {
    let values = computePlayerValues(gameState.players);
    let minAll = Math.min(...values);
    let blockerValue = values[blocker];
let othersTotal = values.reduce((sum, val, idx) => idx === blocker ? sum : sum + val, 0);  // Only OTHER players
let payAmount = 2 * othersTotal * bet;
    let message;
    if (blockerValue <= minAll) {
        // blocker wins, assistant pays to blocker
        scores[assistant] -= payAmount;
        scores[blocker] += payAmount;
        message = `Player ${getPlayerNumber(blocker)} wins block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
        message += `Player ${getPlayerNumber(assistant)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(blocker)}`;
    } else {
        // blocker loses, blocker pays to assistant
        scores[blocker] -= payAmount;
        scores[assistant] += payAmount;
        message = `Player ${getPlayerNumber(blocker)} loses block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
        message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(assistant)}`;
    }
    nextGameStarter = blocker;
    setTimeout(() => alert(message), 100);
}

function updateScoresForIntentionalBlockNoAssist(blocker, gameState) {
    let values = computePlayerValues(gameState.players);
    let blockerValue = values[blocker];
    let othersValues = values.filter((_, i) => i !== blocker);
    let minOthers = Math.min(...othersValues);
    let totalTransfer = othersValues.reduce((a, b) => a + b, 0) * 2 * bet;
    let message;
    if (blockerValue <= minOthers) {
        // Blocker wins
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                scores[i] -= pay;
                scores[blocker] += pay;
            }
        }
        message = `Player ${getPlayerNumber(blocker)} wins block!\n\n`;
        message += `Player ${getPlayerNumber(blocker)} receives ${abbreviate(totalTransfer)}\n\n`;
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
            }
        }
    } else {
        // Blocker loses
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                scores[blocker] -= pay;
                scores[i] += pay;
            }
        }
        message = `Player ${getPlayerNumber(blocker)} loses block!\n\n`;
        message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(totalTransfer)} total\n\n`;
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                message += `Player ${getPlayerNumber(i)} receives ${abbreviate(pay)}\n`;
            }
        }
    }
    
    nextGameStarter = blocker;
    
    setTimeout(() => alert(message), 100);
}

function updateScoresForForceBlock(gameState) {
    let values = computePlayerValues(gameState.players);
    let minVal = Math.min(...values);
    let winners = [];
    let losers = [];
    for (let i = 0; i < numPlayers; i++) {
        if (values[i] === minVal) {
            winners.push(i);
        } else {
            losers.push(i);
        }
    }
    
    let message;
    if (winners.length === numPlayers) {
        // All tie
        message = `Force block! All players tie.\n\nNo payout.\nPlayer ${getPlayerNumber(nextGameStarter)} starts next game.`;
        nextGameStarter = playerOrder[(playerOrder.indexOf(lastValidPlayer) + 1) % numPlayers];
    } else {
        let total_pot = 0;
        losers.forEach(l => {
            let pay = values[l] * bet;
            scores[l] -= pay;
            total_pot += pay;
        });
        let share = total_pot / winners.length;
        winners.forEach(w => {
            scores[w] += share;
        });
        if (winners.length === 1) {
            nextGameStarter = winners[0];
            message = `Force block! Player ${getPlayerNumber(nextGameStarter)} has lowest hand.\n\n`;
            message += `Player ${getPlayerNumber(nextGameStarter)} wins ${abbreviate(total_pot)}\n\n`;
            losers.forEach(l => {
                let pay = values[l] * bet;
                message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
            });
        } else {
            nextGameStarter = playerOrder[(playerOrder.indexOf(lastValidPlayer) + 1) % numPlayers];
            message = `Force block! Tie between: ${winners.map(w => `Player ${getPlayerNumber(w)}`).join(', ')}\n\n`;
            message += `Winners share ${abbreviate(total_pot)} (${abbreviate(share)} each)\n\n`;
            losers.forEach(l => {
                let pay = values[l] * bet;
                message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
            });
        }
    }
    setTimeout(() => alert(message), 100);
}

function hasPreventingAlternative(hand, board, allPlayers, playerIndex, maxDepth = 0) {
    if (!board.leftEnd) return false;

    const playableTiles = hand.filter(tile => canPlayTile(tile, board));
    
    if (playableTiles.length < 1) return false;
    
    let hasNonBlockingMove = false;
    
    for (const tile of playableTiles) {
        const canPlayLeft = canPlayOnEnd(tile, board.leftEnd.value);
        const canPlayRight = canPlayOnEnd(tile, board.rightEnd.value);
        
        // Try playing on left
        if (canPlayLeft) {
            const simBoard = simulatePlay(board, tile, 'left');
            const simPlayers = JSON.parse(JSON.stringify(allPlayers));
            const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
            simPlayers[playerIndex].splice(tileIdx, 1);
            if (!isInevitableBlock(simBoard, simPlayers, playerIndex, 1, maxDepth)) {
                hasNonBlockingMove = true;
                break;
            }
        }
        
        // Try playing on right (skip if double and already tried left)
        if (canPlayRight && (!isDouble(tile) || !canPlayLeft)) {
            const simBoard = simulatePlay(board, tile, 'right');
            const simPlayers = JSON.parse(JSON.stringify(allPlayers));
            const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
            simPlayers[playerIndex].splice(tileIdx, 1);
            if (!isInevitableBlock(simBoard, simPlayers, playerIndex, 1, maxDepth)) {
                hasNonBlockingMove = true;
                break;
            }
        }
    }
    
    // Only has alternative if: multiple playable tiles OR can play 1 tile on both ends
    const hasMultipleOptions = playableTiles.length > 1 || 
        (playableTiles.length === 1 && 
         canPlayOnEnd(playableTiles[0], board.leftEnd.value) && 
         canPlayOnEnd(playableTiles[0], board.rightEnd.value));
    
    return hasMultipleOptions && hasNonBlockingMove;
}

function isInevitableBlock(board, players, currentPlayer, depth, maxDepth) {
    if (!board.leftEnd) return false;

    if (depth > maxDepth) return false;

    if (!isPlayableForAnyone(players, board)) {
        return true;
    }

    const nextPlayerIndex = (playerOrder.indexOf(currentPlayer) + 1) % numPlayers;
    const nextPlayer = playerOrder[nextPlayerIndex];
    const nextHand = players[nextPlayer];
    const validMoves = getValidMoves(nextHand, board);
    if (validMoves.length === 0) {
        return isInevitableBlock(board, players, nextPlayer, depth + 1, maxDepth);
    }

    let allLeadToBlock = true;
    for (const move of validMoves) {
        const simBoard = simulatePlay(board, move.tile, move.end);
        const simPlayers = JSON.parse(JSON.stringify(players));
        const tileIdx = simPlayers[nextPlayer].findIndex(t => t.top === move.tile.top && t.bottom === move.tile.bottom);
        simPlayers[nextPlayer].splice(tileIdx, 1);
        if (simPlayers[nextPlayer].length === 0) {
            allLeadToBlock = false;
            break;
        }
        if (!isInevitableBlock(simBoard, simPlayers, nextPlayer, depth + 1, maxDepth)) {
            allLeadToBlock = false;
            break;
        }
    }
    return allLeadToBlock;
}

function handleNormalGameWin(gameState) {
    gameState.gameOver = true;
    updateScoresForWin(currentPlayer, gameState);
    renderGame(gameState);
    showNewGameButton();
}

function handleBlockedGame(gameState, lastPlayerWhoPlayed, firstSkipped, lastPlayedTile, lastPlayedEnd) {
    gameState.gameOver = true;
    const { players, board, roundHistory } = gameState;
    
    const prevBoard = gameState.prevBoard;
    if (!prevBoard) {
        updateScoresForForceBlock(gameState);
        renderGame(gameState);
        showNewGameButton();
        return;
    }
    
    // Reconstruct last player's hand before their move
    const lastPlayerHandBefore = [...players[lastPlayerWhoPlayed], lastPlayedTile];
    const playersAtLast = JSON.parse(JSON.stringify(players));
    playersAtLast[lastPlayerWhoPlayed].push({...lastPlayedTile});
    
    const lastHadNonBlockingAlt = hasPreventingAlternative(
        lastPlayerHandBefore, 
        prevBoard, 
        playersAtLast, 
        lastPlayerWhoPlayed,
        0
    );
    
    let blocker = lastPlayerWhoPlayed;
    let assistant = -1;
    
    if (lastHadNonBlockingAlt) {
        // Last player chose to block intentionally
        // Check if immediate previous player SET UP this block
        if (roundHistory.length >= 2) {
            const prevMove = roundHistory[roundHistory.length - 2];
            const prevPlayer = prevMove.player;
            
            if (prevPlayer === getPreviousPlayer(lastPlayerWhoPlayed)) {
                const prevHandBefore = [...players[prevPlayer], prevMove.playedTile];
                const prevBoardBefore = prevMove.boardBefore;
                
                if (prevBoardBefore && prevBoardBefore.leftEnd) {
                    const playersAtPrev = JSON.parse(JSON.stringify(players));
                    for (let i = roundHistory.length - 2; i < roundHistory.length; i++) {
                        const move = roundHistory[i];
                        playersAtPrev[move.player].push({...move.playedTile});
                    }
                    
                    // FIXED: Check if prev player had NON-BLOCKING alternative
                    // If they could have avoided setting up the block, they're the assistant
                    const prevHadNonBlockingAlt = hasPreventingAlternative(
                        prevHandBefore,
                        prevBoardBefore,
                        playersAtPrev,
                        prevPlayer,
                        0
                    );
                    
                    if (prevHadNonBlockingAlt) {
                        assistant = prevPlayer;
                    }
                }
            }
        }
        
        if (assistant !== -1) {
            updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState);
        } else {
            updateScoresForIntentionalBlockNoAssist(blocker, gameState);
        }
    } else {
        // Last player was forced to block
        if (roundHistory.length >= 2) {
            const prevMove = roundHistory[roundHistory.length - 2];
            const prevPlayer = prevMove.player;
            
            if (prevPlayer === getPreviousPlayer(lastPlayerWhoPlayed)) {
                const prevHandBefore = [...players[prevPlayer], prevMove.playedTile];
                const prevBoardBefore = prevMove.boardBefore;
                
                if (prevBoardBefore && prevBoardBefore.leftEnd) {
                    const playersAtPrev = JSON.parse(JSON.stringify(players));
                    for (let i = roundHistory.length - 2; i < roundHistory.length; i++) {
                        const move = roundHistory[i];
                        playersAtPrev[move.player].push({...move.playedTile});
                    }
                    
                    // Check if prev player had NON-BLOCKING alternative
                    // If yes, they forced last player into blocking
                    const prevHadNonBlockingAlt = hasPreventingAlternative(
                        prevHandBefore,
                        prevBoardBefore,
                        playersAtPrev,
                        prevPlayer,
                        0
                    );
                    
                    if (prevHadNonBlockingAlt) {
                        blocker = prevPlayer;
                        updateScoresForIntentionalBlockNoAssist(blocker, gameState);
                        return;
                    }
                }
            }
        }
        // Check for remote blocker (2 moves back)
        if (roundHistory.length >= 3) {
            const grandMove = roundHistory[roundHistory.length - 3];
            const grandPlayer = grandMove.player;
            const grandBoardBefore = grandMove.boardBefore;
            if (grandBoardBefore && grandBoardBefore.leftEnd) {
                const grandHandBefore = [...players[grandPlayer], grandMove.playedTile];
                const playersAtGrand = JSON.parse(JSON.stringify(players));
                for (let i = roundHistory.length - 3; i < roundHistory.length; i++) {
                    const move = roundHistory[i];
                    playersAtGrand[move.player].push({...move.playedTile});
                }
                const grandHadPreventingAlt = hasPreventingAlternative(
                    grandHandBefore,
                    grandBoardBefore,
                    playersAtGrand,
                    grandPlayer,
                    2
                );
                if (grandHadPreventingAlt) {
                    blocker = grandPlayer;
                    updateScoresForIntentionalBlockNoAssist(blocker, gameState);
                    return;
                }
            }
        }
        // If no intentional by prev or grand, it's force block
        updateScoresForForceBlock(gameState);
    }
    
    renderGame(gameState);
    showNewGameButton();
}

function getPlayerNumber(index) {
    return index + 1;
}

function showNewGameButton() {
    const newGameBtn = document.getElementById('new-game');
    newGameBtn.style.display = 'block';
    newGameBtn.onclick = () => {
        initAudioContext();
        newGameBtn.style.display = 'none';
        gameState = setupGame();
        renderGame(gameState);
        if (!gameState.gameOver && currentPlayer !== 0) {
            setTimeout(() => playAI(gameState), 1500);
        }
    };
}

function renderGame(gameState) {
    const {players, board, gameOver, selectedIndex, isThisFirstGame} = gameState;
    const tableDiv = document.getElementById('table');
    
    tableDiv.innerHTML = '';
    board.tiles.forEach(({tile, x, y, isHorizontal}, index) => {
        const tileDiv = document.createElement('div');
        tileDiv.className = 'table-tile';
        if (isHorizontal) tileDiv.classList.add('horizontal');
        if (board.tiles.length === 1 && index === 0 && isDouble(tile)) {
            tileDiv.classList.add('first-double');
        }
        
        if (!gameOver) {
            let isLeftEnd = index === (board.leftEnd ? board.leftEnd.tileIndex : -1);
            let isRightEnd = index === (board.rightEnd ? board.rightEnd.tileIndex : -1);
            let isDoubleEnd = isDouble(tile); // Check if end tile is double
            if (isLeftEnd) {
                const openSide = board.leftEnd.openSide;
                if (isHorizontal) {
                    if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
                    else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
                } else {
                    if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
                    else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
                }
            }
            if (isRightEnd) {
                const openSide = board.rightEnd.openSide;
                if (isHorizontal) {
                    if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
                    else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
                } else {
                    if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
                    else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
                }
            }
        }
        
        let tileData = isHorizontal ? { left: tile.bottom, right: tile.top } : tile;
        tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
        tileDiv.style.left = `${x + board.offsetX}px`;
        tileDiv.style.top = `${y + board.offsetY}px`;
        tableDiv.appendChild(tileDiv);
    });

    let leftPlaceholder = null;
    let rightPlaceholder = null;

    if (!gameOver && currentPlayer === 0 && board.tiles.length > 0) {
        const dummyTile = {top: 0, bottom: 0};
        const tableRect = tableDiv.getBoundingClientRect();
        const hand = players[0];

        if (hand.some(tile => canPlayOnEnd(tile, board.leftEnd.value))) {
            const leftPlacement = calculatePlacement(board, 'left', tableRect, dummyTile);
            leftPlaceholder = document.createElement('div');
            leftPlaceholder.className = 'table-tile placeholder';
            if (leftPlacement.isHorizontal) leftPlaceholder.classList.add('horizontal');
            leftPlaceholder.style.left = `${leftPlacement.x + board.offsetX}px`;
            leftPlaceholder.style.top = `${leftPlacement.y + board.offsetY}px`;
            leftPlaceholder.style.border = '2px dashed #6a6a6a';
            tableDiv.appendChild(leftPlaceholder);

            leftPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.leftEnd.value)) leftPlaceholder.style.border = '2px dashed yellow'; };
            leftPlaceholder.ondragleave = () => { leftPlaceholder.style.border = '2px dashed #6a6a6a'; };
            leftPlaceholder.ondrop = (e) => { e.preventDefault(); leftPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.leftEnd.value)) playTile(gameState, tileData, 'left'); } catch (err) {} };
            leftPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.leftEnd.value)) playTile(gameState, selectedTile, 'left'); } };
        }

        if (hand.some(tile => canPlayOnEnd(tile, board.rightEnd.value))) {
            const rightPlacement = calculatePlacement(board, 'right', tableRect, dummyTile);
            rightPlaceholder = document.createElement('div');
            rightPlaceholder.className = 'table-tile placeholder';
            if (rightPlacement.isHorizontal) rightPlaceholder.classList.add('horizontal');
            rightPlaceholder.style.left = `${rightPlacement.x + board.offsetX}px`;
            rightPlaceholder.style.top = `${rightPlacement.y + board.offsetY}px`;
            rightPlaceholder.style.border = '2px dashed #6a6a6a';
            tableDiv.appendChild(rightPlaceholder);

            rightPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.rightEnd.value)) rightPlaceholder.style.border = '2px dashed yellow'; };
            rightPlaceholder.ondragleave = () => { rightPlaceholder.style.border = '2px dashed #6a6a6a'; };
            rightPlaceholder.ondrop = (e) => { e.preventDefault(); rightPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.rightEnd.value)) playTile(gameState, tileData, 'right'); } catch (err) {} };
            rightPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.rightEnd.value)) playTile(gameState, selectedTile, 'right'); } };
        }
    }

    if (!gameOver && currentPlayer === 0) {
        if (board.tiles.length === 0) {
            tableDiv.ondragover = (e) => e.preventDefault();
            tableDiv.ondrop = (e) => { e.preventDefault(); try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); playTile(gameState, tileData, 'right'); } catch (err) {} };
            tableDiv.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; playTile(gameState, selectedTile, 'right'); } };
        }
    }

    document.querySelectorAll('.player-hand').forEach((hand, index) => {
        hand.innerHTML = '';
        const scoreDiv = document.createElement('div');
        scoreDiv.className = 'score';
// AFTER
const scoreValue = scores[index];
const scoreText = scoreValue < 0 ? '-$' + Math.abs(scoreValue) : '$' + scoreValue;
const scoreLength = scoreText.length;
const numCoins = Math.max(3, Math.ceil(scoreLength / 2)) ;
const coinsHtml = '<span class="coin">🪙</span>'.repeat(numCoins);
let coinColorClass = 'yellow';
if (scoreValue >= 1000000000) {
  coinColorClass = 'red';
} else if (scoreValue >=500000000) {
  coinColorClass = 'orange';
} else if (scoreValue >= 100000000) {
  coinColorClass = 'violet';
}
 else if (scoreValue <= -1) {
  coinColorClass = 'silver';
}
scoreDiv.innerHTML = `<span class="score-arrow">${!gameOver && index === currentPlayer ? '➤' : ''}</span><span class="score-text">[P${getPlayerNumber(index)}]</span><div class="score-number"><div class="coins-container ${coinColorClass}">${coinsHtml}</div><span class="score-text" style="position: absolute; top: 50%; left: 50%;top: -1px; transform: translate(calc(-50% - 10px), calc(-50% + 3px)); z-index: 2; color: black;">${scoreText}</span></div>`;
		
        const tilesContainer = document.createElement('div');
        tilesContainer.className = 'tiles-container';
        let playButtons;
        
        let highestDoubleInHand = null;
        if (!gameOver && index === 0 && board.tiles.length === 0 && isThisFirstGame) {
            const doubles = players[0].filter(t => isDouble(t));
            if (doubles.length > 0) {
                highestDoubleInHand = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
            }
        }

        if (!gameOver && index === 0) { 
            playButtons = document.createElement('div');
            playButtons.className = 'play-buttons';
            playButtons.innerHTML = `<button class="play-left">Play Left</button><button class="play-right">Play Right</button>`;
            playButtons.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
        }
        
      // Inside renderGame, replace the tile creation section for player 0:
players[index].forEach((tile, tileIdx) => {
    const tileDiv = document.createElement('div');
    tileDiv.className = 'tile';
    if (!gameOver && index !== 0 && tileMode === 'Close') {
        tileDiv.innerHTML = generateBackTileSvg(false);
    } else {
        tileDiv.innerHTML = generateTileSvg(false, tile);
        tileDiv.dataset.top = tile.top;
        tileDiv.dataset.bottom = tile.bottom;
        
        if (!gameOver && index === 0) {
            let isPlayable = false;
            if (board.tiles.length === 0) {
                if (isThisFirstGame) {
                    const doubles = players[0].filter(t => isDouble(t));
                    if (doubles.length > 0) {
                        if (highestDoubleInHand) {
                            if (tile.top === highestDoubleInHand.top && tile.bottom === highestDoubleInHand.bottom) {
                                isPlayable = true;
                            }
                        } else {
                            isPlayable = true;
                        }
                    } else {
                        isPlayable = true;
                    }
                } else {
                    isPlayable = true;
                }
            } else {
                isPlayable = canPlayTile(tile, board);
            }

            if (isPlayable && currentPlayer === 0) {
                tileDiv.classList.add('draggable');
                tileDiv.draggable = true;
                
                // FIXED: Clear selection on dragstart to prevent "Invalid move"
                tileDiv.ondragstart = (e) => { 
                    initAudioContext(); 
                    if (!soundLocked) canPlaySound = true;
                    draggedTile = tile;
                    // Clear selection when starting drag
                    gameState.selectedIndex = -1;
                    e.dataTransfer.setData('text/plain', JSON.stringify(tile)); 
                };
                
                tileDiv.addEventListener('touchstart', (e) => {
                    initAudioContext();
                   if (!soundLocked) canPlaySound = true;
                    draggedTile = tile;
                    // Clear selection when starting touch drag
                    gameState.selectedIndex = -1;
                    
                    const touch = e.touches[0];
                    const ghost = tileDiv.cloneNode(true);
                    ghost.style.position = 'fixed';
                    ghost.style.pointerEvents = 'none';
                    ghost.style.zIndex = 1000;
                    document.body.appendChild(ghost);
                    ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
                    ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;
                    let moved = false;
                    const onTouchMove = (ev) => {
                        ev.preventDefault();
                        if (ev.touches.length === 1) {
                            moved = true;
                            const t = ev.touches[0];
                            ghost.style.left = `${t.clientX - ghost.offsetWidth / 2}px`;
                            ghost.style.top = `${t.clientY - ghost.offsetHeight / 2}px`;
                            if (board.tiles.length > 0) {
                                if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                                if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                                const dropX = t.clientX;
                                const dropY = t.clientY;
                                if (leftPlaceholder) {
                                    const leftRect = leftPlaceholder.getBoundingClientRect();
                                    if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                                        if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                                            leftPlaceholder.style.border = '2px dashed yellow';
                                        }
                                    }
                                }
                                if (rightPlaceholder) {
                                    const rightRect = rightPlaceholder.getBoundingClientRect();
                                    if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                                        if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                                            rightPlaceholder.style.border = '2px dashed yellow';
                                        }
                                    }
                                }
                            }
                        }
                    };
                    const onTouchEnd = (ev) => {
                        document.removeEventListener('touchmove', onTouchMove);
                        document.removeEventListener('touchend', onTouchEnd);
                        ghost.remove();
                        if (board.tiles.length > 0) {
                            if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                            if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                        }
                        if (!moved) {
                            draggedTile = null;
                            return;
                        }
                        if (moved) {
                            tileDiv.dataset.justMoved = 'true';
                        }
                        const dropTouch = ev.changedTouches[0] || {clientX: 0, clientY: 0};
                        let dropped = false;
                        const dropX = dropTouch.clientX;
                        const dropY = dropTouch.clientY;
                        if (board.tiles.length === 0) {
                            const tableRect = tableDiv.getBoundingClientRect();
                            if (dropX > tableRect.left && dropX < tableRect.right && dropY > tableRect.top && dropY < tableRect.bottom) {
                                playTile(gameState, draggedTile, 'right');
                                dropped = true;
                            }
                        } else {
                            if (leftPlaceholder) {
                                const leftRect = leftPlaceholder.getBoundingClientRect();
                                if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                                    if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                                        playTile(gameState, draggedTile, 'left');
                                        dropped = true;
                                    }
                                }
                            }
                            if (rightPlaceholder) {
                                const rightRect = rightPlaceholder.getBoundingClientRect();
                                if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                                    if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                                        playTile(gameState, draggedTile, 'right');
                                        dropped = true;
                                    }
                                }
                            }
                        }
                        draggedTile = null;
                    };
                    document.addEventListener('touchmove', onTouchMove, {passive: false});
                    document.addEventListener('touchend', onTouchEnd, {passive: false});
                });
            }
            
            tileDiv.onclick = (e) => { initAudioContext(); if (!soundLocked) canPlaySound = true; e.stopPropagation(); if (tileDiv.dataset.justMoved === 'true') { delete tileDiv.dataset.justMoved; return; } handleTileClick(gameState, tileIdx, playButtons); };
            if (selectedIndex === tileIdx) tileDiv.classList.add('selected');
        }
    }
    tilesContainer.appendChild(tileDiv);
});
        if (index === 2) { hand.appendChild(tilesContainer); hand.appendChild(scoreDiv); } 
        else if (index === 0) { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); } 
        else { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); }
        
        if (playButtons) {
            hand.appendChild(playButtons);
            if (currentPlayer === 0 && selectedIndex !== -1) {
                const selectedTileData = players[0][selectedIndex];
                const leftBtn = playButtons.querySelector('.play-left');
                const rightBtn = playButtons.querySelector('.play-right');
                leftBtn.style.display = 'none';
                rightBtn.style.display = 'none';

                if (board.tiles.length === 0) {
                    if (isThisFirstGame) {
                        const doubles = players[0].filter(t => isDouble(t));
                        if (doubles.length > 0) {
                            if (highestDoubleInHand ? (selectedTileData.top === highestDoubleInHand.top && selectedTileData.bottom === highestDoubleInHand.bottom) : true) {
                                rightBtn.style.display = 'inline-block';
                                rightBtn.textContent = `Play First`;
                                rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                            }
                        } else {
                            rightBtn.style.display = 'inline-block';
                            rightBtn.textContent = `Play First`;
                            rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                        }
                    } else {
                        rightBtn.style.display = 'inline-block';
                        rightBtn.textContent = `Play First`;
                        rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                    }
                } else {
                    const leftEnd = board.leftEnd.value;
                    const rightEnd = board.rightEnd.value;
                    if (canPlayOnEnd(selectedTileData, leftEnd)) {
                        leftBtn.style.display = 'inline-block';
                        leftBtn.textContent = `Play Left (${leftEnd})`;
                        leftBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'left'); };
                    }
                    if (canPlayOnEnd(selectedTileData, rightEnd)) {
                        rightBtn.style.display = 'inline-block';
                        rightBtn.textContent = `Play Right (${rightEnd})`;
                        rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                    }
                }
            }
        }
    });
}

let gameState = setupGame();

document.getElementById('options-button').onclick = () => {
    const menu = document.getElementById('options-menu');
    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
};

document.getElementById('tileMode').onchange = (e) => {
    tileMode = e.target.value;
    renderGame(gameState);
};

document.getElementById('backgroundColor').onchange = (e) => {
    backgroundColor = e.target.value;
    renderGame(gameState);
};

document.getElementById('funVoice').onchange = (e) => {
    funVoice = e.target.value === 'On';
};
document.getElementById('bets').addEventListener('change', function(e) {
    bet = parseInt(e.target.value);
});

document.addEventListener('DOMContentLoaded', () => {
  const soundSelect = document.getElementById('sound');
  soundSelect.addEventListener('change', (e) => {
    if (e.target.value === 'Off') {
      canPlaySound = false;
      soundLocked = true; // lock sound state
      console.log('Sound OFF (locked)');
    } else {
      canPlaySound = true;
      soundLocked = false; // allow automatic sound again
      console.log('Sound ON (unlocked)');
    }
  });
});


renderGame(gameState);

// Optional: Show a brief prompt if AI starts first
if (!gameState.gameOver && currentPlayer !== 0) {
    const prompt = document.createElement('div');
    prompt.id = 'aiPrompt';
    prompt.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0, 255, 0, 0.8); color: black; padding: 20px; border-radius: 10px;
        z-index: 1000; font-size: 18px; text-align: center;
    `;
    prompt.textContent = 'Click/Touch anywhere to start AI turn';
    document.body.appendChild(prompt);

    const startAIGame = () => {
        document.removeEventListener('click', startAIGame);
        initAudioContext();
        prompt.style.display = 'none';  // Hide prompt
        playAI(gameState);
    };
    document.addEventListener('click', startAIGame, {once: true});
}
document.addEventListener('DOMContentLoaded', () => {
  const bgSelect = document.getElementById('backgroundColor');

  // Set initial background
  document.body.style.background = bgSelect.value;

  // Listen for changes
  bgSelect.addEventListener('change', (e) => {
    const color = e.target.value;

    // If user picks custom color code (#444, etc.)
    document.body.style.background = color;

    // Optional: change text or border colors for readability
    if (color === '#444') {
      document.body.style.color = '#fff';
    } 
	  else {
      document.body.style.color = '#000';
    }
  });
}); 
function centerTilesOnResize() {
  const table = document.getElementById('table');
  const tiles = table.querySelectorAll('.table-tile');
  if (!tiles.length) return;

  // Get current table center
  const tableRect = table.getBoundingClientRect();
  const centerX = tableRect.width / 2;
  const centerY = tableRect.height / 2;

  // Find the bounding box of all tiles
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  tiles.forEach(tile => {
    const rect = tile.getBoundingClientRect();
    const tableBox = table.getBoundingClientRect();
    const left = rect.left - tableBox.left;
    const top = rect.top - tableBox.top;
    minX = Math.min(minX, left);
    minY = Math.min(minY, top);
    maxX = Math.max(maxX, left + rect.width);
    maxY = Math.max(maxY, top + rect.height);
  });

  // Calculate tiles' visual center
  const tilesCenterX = (minX + maxX) / 2;
  const tilesCenterY = (minY + maxY) / 2;

  // Compute offset to move them to table center
  const offsetX = centerX - tilesCenterX;
  const offsetY = centerY - tilesCenterY;

  // Apply offset
  tiles.forEach(tile => {
    const left = parseFloat(tile.style.left || 0);
    const top = parseFloat(tile.style.top || 0);
    tile.style.left = `${left + offsetX}px`;
    tile.style.top = `${top + offsetY}px`;
  });
}

// Call it on window resize
window.addEventListener('resize', centerTilesOnResize);

</script>
</body>
</html>