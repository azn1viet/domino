<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="description" content="Domino Game - Vietnamese Style">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Domino">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="logo.png">
  <meta name="theme-color" content="#444444">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="256x256" href="logo.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <title>Block Dominoes - Vietnamese Style</title>
  <style>
   :root {
    --tile-width: 30px; /* Updated to match tile width */
    --tile-height: 60px; /* Updated to match tile height */
    --tile-gap: 2px;
  }

  .player-south .tiles-container {
    max-width: calc(100vw - 20px); /* Fit within screen width with padding */
    z-index: 110; /* Higher z-index for Player South */
  }

  .player-north .tiles-container {
    max-width: calc(100vw - 20px);
    z-index: 100; /* Lower than South */
  }

  .player-east .tiles-container,
  .player-west .tiles-container {
    min-height: calc(100vh - 20px);
    z-index: 100; /* Lower than South */
  }

  .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    box-shadow: -2px 0 4px rgba(255, 255, 255, 0.5);
  }

  .tiles-container.overlapped.vertical > .tile:not(:first-child) {
    box-shadow: 0 -2px 4px rgba(255, 255, 255, 0.5);
  }

    * {
      box-sizing: border-box;
    }

    button,
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border: none;
      outline: none;
      background: #0f0;
      color: black;
      border-radius: 6px;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 14px;
      padding: 8px 15px;
      cursor: pointer;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: background 0.2s, transform 0.1s;
    }

    button:hover,
    select:hover {
      background: #0c0;
      transform: scale(1.05);
    }

    button:active,
    select:active {
      transform: scale(0.98);
    }

    select {
      background-image: linear-gradient(45deg, transparent 50%, black 50%),
                        linear-gradient(135deg, black 50%, transparent 50%);
      background-position: calc(100% - 15px) calc(50% - 4px),
                           calc(100% - 10px) calc(50% - 4px);
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 30px;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      background-color: #444;
      position: fixed;
      overflow: hidden;
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-weight: 400;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }

    #player-selection-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    #player-selection-modal.hidden {
      display: none;
    }

    .modal-content {
	 width: 95%;
      background: #333;
      padding: 30px;
      border-radius: 15px;
      border: 3px solid #0f0;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }

    .modal-content h2 {
      color: #0f0;
      margin: 0 0 20px 0;
      font-size: 24px;
    }

    .modal-content p {
      color: #add8e6;
      margin: 0 0 25px 0;
      font-size: 16px;
    }

    .player-options {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .player-option {
      background: #444;
      color: #fff;
      border: 2px solid #666;
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .player-option:hover {
      background: #555;
      border-color: #0f0;
      transform: scale(1.05);
    }

    .player-option.selected {
      background: #0f0;
      color: black;
      border-color: #0f0;
    }

    #game-container {
      position: absolute;
	  top: 0;
      left: 0;
    /*top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);*/
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      overflow: visible;
      pointer-events: none;
    }
	
#table {
  position: absolute;
  left: 50%;
  top: calc(50% - 50px);
  transform: translate(-50%, -50%);
  
  width: 80%;
  height: calc(100% - 260px);
  
  display: block;
  pointer-events: all;
}
    .player-hand {
      position: fixed;
      text-align: center;
      z-index: 100;
      padding: 5px;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
/*
 /* SOUTH ‚Äî score below tiles, near screen bottom edge */
.player-south {
 bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  flex-direction: column;
}
.player-south .score {
  position: absolute;
  bottom: 69px; /* move closer or further from bottom edge */
  left: 50%;
  transform: translateX(-50%);
}*/

.player-south {
  position: fixed;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100vw;
  height: 150px; /* fixed area for player hand */
  display: flex;
  justify-content: center;
  align-items: flex-end;
}

.player-south .tiles-container {
  position: absolute;
  bottom: 80px; /* your designed height above bottom */
  left: 50%;
  transform: translateX(-50%);
}

.player-south .score {
  position: absolute;
  bottom: 68px; /* below the tiles */
  left: 50%;
  transform: translateX(-50%);
}


/* NORTH ‚Äî score above tiles, near top edge */
.player-north {
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  flex-direction: column-reverse;
}
.player-north .score {
  position: absolute;
  top: -74px;
  left: 50%;
  transform: translateX(-50%);
}

/* EAST ‚Äî score on far right edge */
.player-east {
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  flex-direction: row;
}
.player-east .score {
  position: absolute;
  right: -55px; /* distance outside right edge */
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
}
/* WEST ‚Äî score on far left edge */
.player-west {
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  flex-direction: row-reverse;
}
.player-west .score {
  position: absolute;
  left: -55px;
  top: 50%;
  transform: translateY(-50%) rotate(90deg);
}

    .tiles-container {
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2px;
      min-height: 80px;
    }

 /*.player-south .tiles-container,*/
.player-north .tiles-container {
  max-width: calc(var(--tile-width) * 7 + var(--tile-gap) * 6);
  margin-top: 7px;
}

.player-east .tiles-container,
.player-west .tiles-container {
  flex-direction: column;
  min-height: calc(var(--tile-height) * 7 + var(--tile-gap) * 6);
  min-width: 40px;
}

  /*  .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    margin-left: -10px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .player-south .tiles-container.overlapped.horizontal > .tile:not(:first-child) {
    margin-left: -17.5px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .player-south .tiles-container.overlapped.horizontal.many-tiles > .tile:not(:first-child) {
    margin-left: -11.67px;
    box-shadow: -2px 0 4px rgba(255,255,255, 0.5);
  }

  .tiles-container.overlapped.vertical > .tile:not(:first-child) {
    margin-top: -20px;
    box-shadow: 0 -2px 4px rgba(255,255,255, 0.5);
  }
  */

    .tile {
      display: block;
     width: var(--tile-width);
     height: var(--tile-height);
      border: 2px solid black;
      cursor: pointer;
      border-radius: 8px;
      background-color: black;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }

    .tile svg,
    .table-tile svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .selected {
      border: 3px solid yellow;
      box-shadow: 0 0 10px yellow;
    }

    .draggable {
      border: 2px dashed #6a6a6a;
    }

    .table-tile {
      position: absolute;
      width: var(--tile-width);
      height: var(--tile-height);
      border: 2px solid #666;
      border-radius: 6px;
      background-color: #1a1a1a;
      z-index: 15;
      transition: border-color 0.3s;
    }

    .table-tile.horizontal {
      width: var(--tile-height);
      height: var(--tile-width);
    }

    .table-tile.match-drop::before,
    .table-tile.match-drop::after {
      border-style: dashed !important;
    }

    .table-tile.placeholder {
      z-index: 20;
      pointer-events: auto;
      background-color: transparent;
    }

    .table-tile.end-top::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-top: 2px solid #0ff;
      border-left: 2px solid #0ff;
      border-right: 2px solid #0ff;
      border-radius: 6px 6px 0 0;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-bottom::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-bottom: 2px solid #0ff;
      border-left: 2px solid #0ff;
      border-right: 2px solid #0ff;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-left::before {
      content: '';
      position: absolute;
      left: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-left: 2px solid #0ff;
      border-top: 2px solid #0ff;
      border-bottom: 2px solid #0ff;
      border-radius: 6px 0 0 6px;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.end-right::after {
      content: '';
      position: absolute;
      right: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-right: 2px solid #0ff;
      border-top: 2px solid #0ff;
      border-bottom: 2px solid #0ff;
      border-radius: 0 6px 6px 0;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.double-end-top::before,
    .table-tile.double-end-bottom::after,
    .table-tile.double-end-left::before,
    .table-tile.double-end-right::after {
      content: '';
      position: absolute;
      border: 2px solid #0ff;
      box-shadow: 0 0 10px #0ff;
      pointer-events: none;
      z-index: 16;
    }

    .table-tile.double-end-top::before {
      top: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-radius: 6px 6px 0 0;
    }

    .table-tile.double-end-bottom::after {
      bottom: -2px;
      left: -2px;
      right: -2px;
      height: calc(50% + 2px);
      border-radius: 0 0 6px 6px;
    }

    .table-tile.double-end-left::before {
      left: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-radius: 6px 0 0 6px;
    }

    .table-tile.double-end-right::after {
      right: -2px;
      top: -2px;
      bottom: -2px;
      width: calc(50% + 2px);
      border-radius: 0 6px 6px 0;
    }

    .tile:hover {
      border: 3px solid #0f0;
      box-shadow: 0 0 8px #0f0;
    }

    .score {
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      margin: 3px 0;
      z-index: 201;
      text-shadow: 0 0 5px #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 100px;
      pointer-events: none;
	  bottom: 2px;
    }

    .score-arrow {
      width: 25px;
      display: inline-block;
      text-align: center;
      color: #0f0;
    }

    .score-text {
      white-space: nowrap;
      margin-left: 10px;
      color: #0f0;
    }

    .score-number {
      position: relative;
      display: inline-block;
      margin-left: 50px;
    }

    .coins-container {
      position: absolute;
      z-index: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      height: 20px;
      pointer-events: none;
      display: flex;
      align-items: center;
    }

    .coins-container .coin {
      font-size: 18px;
      margin-left: -8px;
      opacity: 0.5;
    }

    .coins-container .coin:first-child {
      margin-left: 0;
    }

    .coins-container.yellow .coin {
      filter: none;
    }

    .coins-container.violet .coin {
      filter: brightness(0) saturate(100%) invert(69%) sepia(23%) saturate(1988%) hue-rotate(248deg) brightness(104%) contrast(87%);
    }

    .coins-container.orange .coin {
      filter: brightness(0) saturate(50%) invert(52%) sepia(50%) saturate(1120%) hue-rotate(6deg) brightness(50%) contrast(97%);
    }

    .coins-container.red .coin {
      filter: brightness(0) saturate(100%) invert(35%) sepia(71%) saturate(6921%) hue-rotate(350deg) brightness(88%) contrast(133%);
    }

    .coins-container.silver .coin {
      filter: brightness(0) saturate(100%) invert(88%) sepia(3%) saturate(0%) hue-rotate(193deg) brightness(95%) contrast(90%);
    }

    .play-buttons {
      margin-top: 35px;
      display: flex;
      gap: 5px;
      justify-content: center;
      align-items: center;
      min-height: 40px;
      pointer-events: auto;
    }

    .play-buttons button {
      padding: 6px 10px;
      background: #0f0;
      color: black;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      display: none;
	  flex: 0 0 auto; /* don‚Äôt shrink */
	  white-space: nowrap;
    }

    .play-buttons button:hover {
      background: #0c0;
      transform: scale(1.05);
    }

    #new-game {
      position: fixed;
      bottom: -6px;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 3px 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #0f0;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      z-index: 999;
      font-size: 18px;
      font-weight: bold;
    }

    #new-game:hover {
      background: #090;
    }

    #bets {
      position: fixed;
      bottom: 10px;
      right: 3px;
      z-index: 100;
      background: #444;
      color: #add8e6;
      border: 1px solid #0f0;
      padding: 5px;
      font-size: 14px;
    }

    .table-tile.first-double {
      border: 2px solid #0ff !important;
      box-shadow: 0 0 10px #0ff !important;
    }

#options-button:active {
  transform: scale(0.95); /* Immediate visual feedback */
  background: #0a0;
}

#options-button {
  position: fixed;
  bottom: 10px;
  left: 3px;
  z-index: 100;
  background: #444;
  color: #add8e6;
  border: 1px solid #0f0;
  padding: 5px;
  font-size: 14px;
  cursor: pointer;
  touch-action: manipulation;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  pointer-events: auto;
  transition: all 0.1s ease; /* Smooth transition */
}

    #options-button:hover {
      background: #0c0;
      transform: scale(1.05);
    }


    #options-menu {
      position: fixed;
      bottom: 50px;
      left: 10px;
      background: #444;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 10px;
      z-index: 201;
      display: none;
      color: #add8e6;
      font-size: 12px;
      pointer-events: auto;
    }

    #options-menu select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: #333;
      color: #add8e6;
      border: 1px solid #0f0;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 12px;
      line-height: 1.4;
      outline: none;
      cursor: pointer;
      width: auto;
      background-image: none;
      box-shadow: none;
    }

    #options-menu select:focus {
      border-color: #0c0;
      outline: none;
    }

    #options-menu label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0;
    }

    .close-btn {
      position: absolute;
      top: -4px;
      right: 2px;
      cursor: pointer;
      color: #0f0;
      font-size: 18px;
      font-weight: bold;
      transition: 0.2s ease;
    }

    .close-btn:hover {
      color: #fff;
      transform: scale(1.2);
    }

    #boneyard {
      position: fixed;
      top: 1px;
      left: 1px;
      padding: 1px;
      display: none;
    }

    #installBtn {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.5);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      z-index: 9999;
      display: none;
      box-shadow: 0 0 10px #0f08;
    }
  </style>
</head>
<body>
  <!-- === Player Selection Modal === -->
<div id="player-selection-modal">
  <div class="modal-content">
    <h2>Welcome to Block Dominoes!</h2>
    <p>Select number of players to start:</p>
    <div class="player-options">
      <button class="player-option selected" data-players="2">2 Players</button>
      <button class="player-option" data-players="3">3 Players</button>
      <button class="player-option" data-players="4">4 Players</button>
    </div>
    <button id="start-game-btn" disabled
      style="background: gray; color: black; padding: 12px 30px; font-size: 16px; opacity: 0.6;">
      Loading AI...
    </button>
  </div>
</div>

  <button id="installBtn">üì≤ Install App</button>

  <div id="game-container">
    <div id="table"></div>
  </div>
  <button id="new-game">New Game</button>
  <div id="players">
    <div class="player-hand player-south" data-player="0"></div>
    <div class="player-hand player-east" data-player="1"></div>
    <div class="player-hand player-north" data-player="2"></div>
    <div class="player-hand player-west" data-player="3"></div>
  </div>
  <div id="boneyard">
    <div id="boneyard-tiles" style="display: grid; grid-template-columns: repeat(7, auto); gap: 1px;"></div>
  </div>
  <button id="options-button">Options</button>

  <div id="options-menu">
    <span id="close-options" class="close-btn">&times;</span>
    <label>Players
      <select id="numPlayers">
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4" selected>4</option>
      </select>
    </label>
    <label>Tile Mode
      <select id="tileMode">
        <option value="Open">Open</option>
        <option value="Close" selected>Close</option>
      </select>
    </label>
    <label>Background Color &nbsp;
      <select id="backgroundColor">
        <option value="white">White</option>
        <option value="olive">Olive</option>
        <option value="teal">Teal</option>
        <option value="indigo">Indigo</option>
        <option value="gold">Gold</option>
        <option value="#444" selected>Grey</option>
      </select>
    </label>
    <label>Sound
      <select id="sound">
        <option value="On" selected>On</option>
        <option value="Off">Off</option>
      </select>
    </label>
    <label>Fun Voice
      <select id="funVoice">
        <option value="On">On</option>
        <option value="Off" selected>Off</option>
      </select>
    </label>
  </div>
  <select id="bets">
    <option value="1000">1000</option>
    <option value="10000" selected>10000</option>
    <option value="50000">50000</option>
    <option value="100000">100000</option>
    <option value="500000">500000</option>
    <option value="1000000">1000000</option>
  </select>
  <div style="position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%); color: #ccc; font-size: 14px; opacity: 0.8; pointer-events: none;">Version 4.2.3</div>

<script>
  // PWA Install Script
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'block';
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const choice = await deferredPrompt.userChoice;
      if (choice.outcome === 'accepted') {
        installBtn.style.display = 'none';
        localStorage.setItem('pwaInstalled', 'true');
      }
      deferredPrompt = null;
    });

    window.addEventListener('appinstalled', () => {
      installBtn.style.display = 'none';
      localStorage.setItem('pwaInstalled', 'true');
    });

    if (!localStorage.getItem('pwaInstalled')) {
      navigator.serviceWorker.getRegistrations().then(regs => regs.forEach(r => r.unregister()));
      caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
    }

    document.addEventListener('click', () => {
      if (!deferredPrompt && installBtn.style.display === 'none') {
        setTimeout(() => {
          if (deferredPrompt) installBtn.style.display = 'block';
        }, 1000);
      }
    });
  </script>

<script>
// Additional: Ensure bets is enabled initially (before first game start)
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('bets').disabled = false; // Enabled before any game starts
});
</script>

<script>
let trainingMode = false;
    // Game Variables
    let audioContext = null;
    let canPlaySound = true;
    let soundLocked = false;
    let funVoice = false;
    let tileMode = 'Close';
    let backgroundColor = '#444';
    let bet = 10000;
    let draggedTile = null;
    let numPlayersVar = 4;
    let gameState = null;
    let currentActivePlayerTurn = 0;
    let nextGameStarter = 0;
    let lastValidPlayer = 0;
	
	
    // Updated global variables and initialization
let scores = [10000000, 10000000, 10000000, 10000000];
///
let isOverallFirstGame = true;
let isTrueFirstGame = true; // ‚≠ê NEW: Track if it's the very first game ever
///
// === UNIFIED TRAINING MODE SYSTEM ===
// Place this BEFORE any game code (after variable declarations)
(function initTrainingMode() {
  window.trainingMode = false;
  
  // Store original functions
  const original = {
    alert: window.alert,
    setTimeout: window.setTimeout,
    requestAnimationFrame: window.requestAnimationFrame
  };

  // Override alert
  window.alert = function(msg) {
    if (!window.trainingMode) {
      original.alert.call(window, msg);
    }
  };

  // Override setTimeout - ALLOW delays of 0 or very short during training
  window.setTimeout = function(fn, delay, ...args) {
    if (window.trainingMode && delay > 10) {
      // Block long delays during training, but allow yield delays (0-10ms)
      return null;
    }
    return original.setTimeout.call(window, fn, delay, ...args);
  };

  // Override requestAnimationFrame
  window.requestAnimationFrame = function(callback) {
    if (window.trainingMode) {
      return null; // Block all RAF during training
    }
    return original.requestAnimationFrame.call(window, callback);
  };

  // Restore functions if needed
  window.restoreOriginalFunctions = function() {
    window.alert = original.alert;
    window.setTimeout = original.setTimeout;
    window.requestAnimationFrame = original.requestAnimationFrame;
  };
})();
///

// Load persisted data from localStorage
const storedScores = localStorage.getItem('dominoScores');
if (storedScores) {
  scores = JSON.parse(storedScores);
}
const storedBet = localStorage.getItem('dominoBet');
if (storedBet) {
  bet = parseInt(storedBet, 10);
}
document.getElementById('bets').value = bet; // Sync select with loaded bet
// Updated bets change listener
document.getElementById('bets').addEventListener('change', function(e) {
  if (gameState && !gameState.gameOver) {
    safeAlert('Cannot change bet during game!');
    e.target.value = bet; // Revert to previous bet value
    return;
  }
  bet = parseInt(e.target.value, 10);
  localStorage.setItem('dominoBet', bet);
});

    const tiles = [
      {top: 6, bottom: 6}, {top: 6, bottom: 5}, {top: 6, bottom: 4}, {top: 6, bottom: 3}, {top: 6, bottom: 2}, {top: 6, bottom: 1}, {top: 6, bottom: 0},
      {top: 5, bottom: 5}, {top: 5, bottom: 4}, {top: 5, bottom: 3}, {top: 5, bottom: 2}, {top: 5, bottom: 1}, {top: 5, bottom: 0},
      {top: 4, bottom: 4}, {top: 4, bottom: 3}, {top: 4, bottom: 2}, {top: 4, bottom: 1}, {top: 4, bottom: 0},
      {top: 3, bottom: 3}, {top: 3, bottom: 2}, {top: 3, bottom: 1}, {top: 3, bottom: 0},
      {top: 2, bottom: 2}, {top: 2, bottom: 1}, {top: 2, bottom: 0},
      {top: 1, bottom: 1}, {top: 1, bottom: 0},
      {top: 0, bottom: 0}
    ];

    const numTiles = 7;

// Player Selection Modal Logic
const modal = document.getElementById('player-selection-modal');
const playerOptions = document.querySelectorAll('.player-option');
const startGameBtn = document.getElementById('start-game-btn');

// Initialize selectedPlayers from any option already marked `.selected` in markup,
// otherwise fall back to 4 (or whatever default you want).
let selectedPlayers = (() => {
  const pre = document.querySelector('.player-option.selected');
  return pre ? parseInt(pre.dataset.players, 10) : 4;
})();

// Click handler for options ‚Äî keeps selectedPlayers in sync with UI
playerOptions.forEach(option => {
  option.addEventListener('click', () => {
    playerOptions.forEach(opt => opt.classList.remove('selected'));
    option.classList.add('selected');

    // parseInt with radix and guard fallback
    const n = parseInt(option.dataset.players, 10);
    selectedPlayers = Number.isFinite(n) ? n : 4;
  });
});


    startGameBtn.addEventListener('click', () => {
      numPlayersVar = selectedPlayers;
      document.getElementById('numPlayers').value = numPlayersVar;
      modal.classList.add('hidden');
      initAudioContext();
      startNewGame();
    });

    // Helper Functions
    function abbreviate(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      else if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      else if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      else return num.toString();
    }

    function formatPayout(amount) {
      return abbreviate(Math.abs(amount)) + (amount < 0 ? ' loss' : ' gain');
    }

 function initAudioContext() {
  if (window.trainingMode) return;
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}
function playSound() {
  if (window.trainingMode || !canPlaySound) return;
  
  try {
    initAudioContext();
    let oscillator = audioContext.createOscillator();
    let gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = 523.25;
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
  } catch (e) {
    // Silently fail during training
  }
}
	// --- Prevent early AudioContext errors ---
document.addEventListener("click", resumeAudioContext, { once: true });
document.addEventListener("touchstart", resumeAudioContext, { once: true });

function resumeAudioContext() {
  if (window.trainingMode || !canPlaySound) return;
  
  try {
    if (typeof audioContext !== "undefined" && audioContext && audioContext.state === "suspended") {
      audioContext.resume().then(() => {
        console.log("üîä AudioContext resumed after user gesture");
      });
    } else {
      initAudioContext();
      console.log("üîä AudioContext initialized after user gesture");
    }
  } catch (e) {
    // Silently fail
  }
}
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function generateBackTileSvg(isHorizontal) {
      let svg;
      if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
      } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
      }
      svg += "</svg>";
      return svg;
    }

    function generateTileSvg(isHorizontal, tileData) {
      const colors = ["", "red", "gold", "white", "red", "seagreen", "white"];
      let svg;
      if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
        const { top, bottom } = tileData;
        if (top > 0) {
          svg += `<g class='dots' fill='${colors[top]}'>`;
          const tops = {
            1: "<circle cx='25' cy='20' r='5' />",
            2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
            3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
            4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
          };
          svg += tops[top] + "</g>";
        }
        if (bottom > 0) {
          svg += `<g class='dots' fill='${colors[bottom]}'>`;
          const bottoms = {
            1: "<circle cx='25' cy='80' r='5' />",
            2: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='85' r='5' />",
            3: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='85' r='5' />",
            4: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
            5: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
            6: "<circle cx='15' cy='65' r='5' /><circle cx='15' cy='77' r='5' /><circle cx='15' cy='89' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='35' cy='77' r='5' /><circle cx='35' cy='89' r='5' />"
          };
          svg += bottoms[bottom] + "</g>";
        }
        svg += "<line x1='0' y1='50%' x2='100%' y2='50%' stroke='#666' stroke-width='2' />";
      } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
        const { left, right } = tileData;
        svg += "<line x1='50%' y1='0' x2='50%' y2='100%' stroke='#666' stroke-width='2' />";
        if (left > 0) {
          svg += `<g class='dots' fill='${colors[left]}'>`;
          const leftPatterns = {
            1: "<circle cx='25' cy='20' r='5' />",
            2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
            3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
            4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
            6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
          };
          svg += leftPatterns[left] + "</g>";
        }
        if (right > 0) {
          svg += `<g class='dots' fill='${colors[right]}'>`;
          const rightPatterns = {
            1: "<circle cx='75' cy='30' r='5' />",
            2: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='35' r='5' />",
            3: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='35' r='5' />",
            4: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
            5: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
            6: "<circle cx='65' cy='15' r='5' /><circle cx='65' cy='27' r='5' /><circle cx='65' cy='39' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='85' cy='27' r='5' /><circle cx='85' cy='39' r='5' />"
          };
          svg += rightPatterns[right] + "</g>";
        }
      }
      svg += "</svg>";
      return svg;
    }

    function getTileSizes() {
      const rootStyle = getComputedStyle(document.documentElement);
      const tw = parseFloat(rootStyle.getPropertyValue('--tile-width'));
      const th = parseFloat(rootStyle.getPropertyValue('--tile-height'));
      return { V_W: tw, V_H: th, H_W: th, H_H: tw, FULL: th, OFFSET: th / 4 };
    }

    function isDouble(tile) {
      return tile.top === tile.bottom;
    }

    function canPlayTile(tile, board) {
      if (!board.leftEnd) return true;
      const leftEnd = board.leftEnd.value;
      const rightEnd = board.rightEnd.value;
      return tile.top === leftEnd || tile.bottom === leftEnd || tile.top === rightEnd || tile.bottom === rightEnd;
    }

    function canPlayOnEnd(tile, endValue) {
      return tile.top === endValue || tile.bottom === endValue;
    }

    function getPlayerNumber(index) {
      return index + 1;
    }

    function rotateTile(tile) {
      return { top: tile.bottom, bottom: tile.top };
    }
///
function setupGame() {
  const gameTiles = [...tiles];
  shuffle(gameTiles);
  let players = Array(4).fill().map(() => []);
  let boneyard = [];
  let playerOrder = numPlayersVar === 2 ? [0, 2] : numPlayersVar === 3 ? [0, 1, 2] : [0, 1, 2, 3];
  
// ‚≠ê FIX: Force "highest double" rule if player count changes and winner is invalid
  if (!playerOrder.includes(nextGameStarter)) {
    nextGameStarter = 0;
    isOverallFirstGame = true; // This re-engages the highest double rule
    isTrueFirstGame = true; // Also reset this to be consistent
  }
  
  for (let p of playerOrder) {
    players[p] = gameTiles.splice(0, numTiles);
  }
  boneyard = gameTiles;

  const board = {
    tiles: [],
    leftEnd: null,
    rightEnd: null,
    offsetX: 0,
    offsetY: 0
  };

  let highestDouble = null;
  let starter = 0;
  
  for (let p of playerOrder) {
    const doubles = players[p].filter(t => isDouble(t));
    if (doubles.length > 0) {
      const playerHighest = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
      if (!highestDouble || playerHighest.top > highestDouble.top) {
        highestDouble = playerHighest;
        starter = p;
      }
    }
  }

  const isThisFirstGame = isOverallFirstGame;
  if (isThisFirstGame) {
    currentActivePlayerTurn = starter;
    isOverallFirstGame = false;
    isTrueFirstGame = false; // ‚≠ê Mark that we're past the true first game
  } else {
    if (playerOrder.includes(nextGameStarter)) {
      currentActivePlayerTurn = nextGameStarter;
    } else {
      currentActivePlayerTurn = starter;
    }
  }

  const roundHistory = [];

  return {
    players, 
    boneyard, 
    board, 
    prevBoard: null, 
    gameOver: false, 
    roundHistory, 
    selectedIndex: -1, 
    isThisFirstGame, 
    playerOrder, 
    highestDouble
  };
}

///
function startNewGame() {
  isOverallFirstGame = true;
  isTrueFirstGame = true; // ‚≠ê Reset to true when explicitly starting new game
  currentActivePlayerTurn = 0;
  nextGameStarter = 0;
  lastValidPlayer = 0;
  
  document.getElementById('new-game').style.display = 'none';
  gameState = setupGame();
  renderGame(gameState);
  
  if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
    setTimeout(() => playAI(gameState), 1500);
  }
}
///
    document.getElementById('close-options').addEventListener('click', () => {
      document.getElementById('options-menu').style.display = 'none';
    });

// Options button - immediate response
const optionsButton = document.getElementById('options-button');
const optionsMenu = document.getElementById('options-menu');

optionsButton.addEventListener('click', (e) => {
  e.stopPropagation();
  
  // Toggle menu immediately
  const isHidden = optionsMenu.style.display === 'none' || optionsMenu.style.display === '';
  optionsMenu.style.display = isHidden ? 'block' : 'none';
  
  // Visual feedback
  optionsButton.style.transform = 'scale(0.95)';
  setTimeout(() => {
    optionsButton.style.transform = 'scale(1)';
  }, 100);
});

// Close button
document.getElementById('close-options').addEventListener('click', (e) => {
  e.stopPropagation();
  optionsMenu.style.display = 'none';
});

// Close menu when clicking outside
document.addEventListener('click', (e) => {
  if (optionsMenu.style.display === 'block' && 
      !optionsMenu.contains(e.target) && 
      !optionsButton.contains(e.target)) {
    optionsMenu.style.display = 'none';
  }
});
///
document.getElementById('numPlayers').onchange = async (e) => {
  if (gameState && !gameState.gameOver) {
    safeAlert('Cannot change number of Players during game!');
    e.target.value = numPlayersVar;
    return;
  }
  
  const newPlayerCount = parseInt(e.target.value);
  
  document.getElementById('options-menu').style.display = 'none';
  
  await trainAIForMode(newPlayerCount);
  
// ‚≠ê FIX: Force "highest double" rule if player count changes and winner is invalid
  const newPlayerOrder = newPlayerCount === 2 ? [0, 2] : 
                         newPlayerCount === 3 ? [0, 1, 2] : 
                         [0, 1, 2, 3];

  if (!newPlayerOrder.includes(nextGameStarter)) {
    nextGameStarter = 0;
    isOverallFirstGame = true; // This re-engages the highest double rule
    isTrueFirstGame = true; // Also reset this to be consistent
  }
  
  numPlayersVar = newPlayerCount;
  
  document.getElementById('new-game').style.display = 'none';
  gameState = setupGame();
  renderGame(gameState);
  
  if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
    setTimeout(() => playAI(gameState), 1500);
  }
};
///
    document.getElementById('tileMode').onchange = (e) => {
      tileMode = e.target.value;
      if (gameState) renderGame(gameState);
    };

    document.getElementById('backgroundColor').onchange = (e) => {
      backgroundColor = e.target.value;
      document.body.style.background = backgroundColor;
      if (backgroundColor === '#444') {
        document.body.style.color = '#fff';
      } else {
        document.body.style.color = '#000';
      }
    };

    document.getElementById('funVoice').onchange = (e) => {
      funVoice = e.target.value === 'On';
    };

    document.getElementById('sound').addEventListener('change', (e) => {
      if (e.target.value === 'Off') {
        canPlaySound = false;
        soundLocked = true;
      } else {
        canPlaySound = true;
        soundLocked = false;
      }
    });
///
function calculatePlacement(board, end, tableRect, tile) {
  const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();
  const MARGIN = 0;

  let e = board[end === 'left' ? 'leftEnd' : 'rightEnd'];
  let isLeftChain = end === 'left';
  let turnDir = isLeftChain ? 'up' : 'down';

  let p = {};
  let hdir = e.dir;
  let isDoubleTile = isDouble(tile);
  let tryVerticalFirst = false;

  if (board.forceHorizontalNext) {
    tryVerticalFirst = false;
    board.forceHorizontalNext = false;
  } else {
    if (isDoubleTile && !e.isVertical) {
      // ‚≠ê FIX: Only turn vertical when VERY close to edge (within 1 tile width)
      const nearLeftEdge = e.x - FULL < MARGIN;
      const nearRightEdge = e.x + FULL > tableRect.width - MARGIN;
      if ((isLeftChain && nearLeftEdge) || (!isLeftChain && nearRightEdge)) {
        tryVerticalFirst = true;
      }
    }
  }

  if (tryVerticalFirst) {
    if (turnDir === 'up') {
      p.x = e.x - OFFSET;
      p.y = e.y - (FULL + OFFSET);
      p.nextEndX = p.x + OFFSET;
      p.nextEndY = p.y + OFFSET;
    } else {
      p.x = e.x - OFFSET;
      p.y = e.y + OFFSET;
      p.nextEndX = p.x + OFFSET;
      p.nextEndY = p.y + FULL - OFFSET;
    }
    p.isHorizontal = false;
    p.isVertical = true;
    p.width = V_W;
    p.height = V_H;

    const v_eff_x = p.x + board.offsetX;
    const v_eff_y = p.y + board.offsetY;
    p.boundCheck = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                    v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

    if (!p.boundCheck) {
      let newHdir = hdir === 'left' ? 'right' : 'left';
      p.newHdir = newHdir;
      p.turnDir = turnDir;
      
      // ‚≠ê FIX: Update edge detection for force horizontal
      const nearLeftEdge = v_eff_x - FULL < MARGIN;
      const nearRightEdge = v_eff_x + FULL > tableRect.width - MARGIN;
      if (nearLeftEdge || nearRightEdge) {
        board.forceHorizontalNext = true;
      }
      return p;
    }
  }

  // Try horizontal placement
  if (hdir === 'left') {
    p.x = e.x - (FULL + OFFSET);
    p.nextEndX = p.x + OFFSET;
  } else {
    p.x = e.x + OFFSET;
    p.nextEndX = p.x + FULL - OFFSET;
  }
  p.y = e.y - OFFSET;
  p.isHorizontal = true;
  p.isVertical = false;
  p.width = H_W;
  p.height = H_H;
  p.nextEndY = p.y + OFFSET;

  const eff_x = p.x + board.offsetX;
  const eff_y = p.y + board.offsetY;
  p.boundCheck = (eff_x < MARGIN || eff_x + p.width > tableRect.width - MARGIN ||
                  eff_y < MARGIN || eff_y + p.height > tableRect.height - MARGIN);

  if (!p.boundCheck) {
    return p;
  } else {
    // Horizontal doesn't fit, turn vertical
    if (turnDir === 'up') {
      p.y = e.y - (FULL + OFFSET);
      p.nextEndY = p.y + OFFSET;
    } else {
      p.y = e.y + OFFSET;
      p.nextEndY = p.y + FULL - OFFSET;
    }
    p.x = e.x - OFFSET;
    p.isHorizontal = false;
    p.isVertical = true;
    p.width = V_W;
    p.height = V_H;
    p.nextEndX = p.x + OFFSET;

    const v_eff_x = p.x + board.offsetX;
    const v_eff_y = p.y + board.offsetY;
    let v_bound = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                   v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

    if (v_bound) {
      let shiftX = 0, shiftY = 0;
      if (v_eff_x < MARGIN) shiftX = MARGIN - v_eff_x;
      else if (v_eff_x + p.width > tableRect.width - MARGIN)
        shiftX = (tableRect.width - MARGIN) - (v_eff_x + p.width);
      if (v_eff_y < MARGIN) shiftY = MARGIN - v_eff_y;
      else if (v_eff_y + p.height > tableRect.height - MARGIN)
        shiftY = (tableRect.height - MARGIN) - (v_eff_y + p.height);
      board.offsetX += shiftX;
      board.offsetY += shiftY;
    }

    let newHdir = hdir === 'left' ? 'right' : 'left';
    p.newHdir = newHdir;
    p.turnDir = turnDir;
    
    // ‚≠ê FIX: Update edge detection for force horizontal
    const nearLeftEdge = v_eff_x - FULL < MARGIN;
    const nearRightEdge = v_eff_x + FULL > tableRect.width - MARGIN;
    if (nearLeftEdge || nearRightEdge) {
      board.forceHorizontalNext = true;
    }
    return p;
  }
}
///
function computePlayerValues(players) {
  const values = [];
  
  // Count zeros on the table (from played tiles)
  let zerosOnTable = 0;
  if (gameState && gameState.roundHistory) {
    for (let move of gameState.roundHistory) {
      const tile = move.playedTile;
      if (tile.top === 0) zerosOnTable++;
      if (tile.bottom === 0) zerosOnTable++;
    }
  }
  
  // If 6 zeros visible, the 7th zero is in [0-0] ‚Üí value = 13
  // Otherwise [0-0] = 0
  const doubleZeroValue = (zerosOnTable >= 6) ? 13 : 0;
  
  for (let p = 0; p < 4; p++) {
    let sum = 0;
    for (let tile of players[p]) {
      let pips = tile.top + tile.bottom;
      
      // Special case: [0-0]
      if (pips === 0) {
        pips = doubleZeroValue;
      }
      
      sum += pips;
    }
    values[p] = sum;
  }
  
  return values;
}
///

    function simulatePlay(board, tile, end) {
      if (!board.leftEnd) {
        return {
          leftEnd: { value: tile.top },
          rightEnd: { value: tile.bottom }
        };
      }

      let simLeftEnd = { ...board.leftEnd };
      let simRightEnd = { ...board.rightEnd };
      if (end === 'left') {
        const oldValue = simLeftEnd.value;
        if (tile.top === oldValue) {
          simLeftEnd.value = tile.bottom;
        } else {
          simLeftEnd.value = tile.top;
        }
      } else {
        const oldValue = simRightEnd.value;
        if (tile.top === oldValue) {
          simRightEnd.value = tile.bottom;
        } else {
          simRightEnd.value = tile.top;
        }
      }
      return { leftEnd: simLeftEnd, rightEnd: simRightEnd };
    }
	
    function isPlayableForAnyone(players, boneyard, board, playerOrder) {
      if (!board.leftEnd) return true;
      for (const p of playerOrder) {
        if (players[p].some(tile => canPlayTile(tile, board))) {
          return true;
        }
      }
      if (boneyard.length === 0) return false;
      const left = board.leftEnd.value;
      const right = board.rightEnd.value;
      return boneyard.some(tile => tile.top === left || tile.bottom === left || tile.top === right || tile.bottom === right);
    }

    function countAllPips(players, roundHistory) {
      const counts = [0, 0, 0, 0, 0, 0, 0];
      const allKnownTiles = [];
      allKnownTiles.push(...players[currentActivePlayerTurn]);
      if (roundHistory) {
        for (const move of roundHistory) {
          allKnownTiles.push(move.playedTile);
        }
      }
      for (const tile of allKnownTiles) {
        counts[tile.top]++;
        counts[tile.bottom]++;
      }
      return counts;
    }

    function getValidMoves(hand, board) {
      const validMoves = [];
      if (!board.leftEnd) {
        hand.forEach(tile => validMoves.push({ tile, end: 'right' }));
      } else {
        hand.forEach(tile => {
          const canLeft = canPlayOnEnd(tile, board.leftEnd.value);
          const canRight = canPlayOnEnd(tile, board.rightEnd.value);
          if (canLeft) {
            validMoves.push({ tile, end: 'left' });
          }
          if (canRight) {
            if (!isDouble(tile) || !canLeft) {
              validMoves.push({ tile, end: 'right' });
            }
          }
        });
      }
      return validMoves;
    }

    function drawUntilMatch(gameState, player) {
      const { players, board, boneyard } = gameState;
      const hand = players[player];
      while (boneyard.length > 0 && getValidMoves(hand, board).length === 0) {
        const idx = Math.floor(Math.random() * boneyard.length);
        const drawn = boneyard.splice(idx, 1)[0];
        hand.push(drawn);
      }
      if (player === 0 && hand.length > 0) {
        const lastDrawn = hand[hand.length - 1];
        if (canPlayTile(lastDrawn, board)) {
          gameState.selectedIndex = hand.length - 1;
        }
      }
    }

    function isInevitableBlock(board, players, boneyard, currentActivePlayerTurn, depth, maxDepth, playerOrder) {
      if (!board.leftEnd) return false;
      if (depth > maxDepth) return false;
      if (!isPlayableForAnyone(players, boneyard, board, playerOrder)) {
        return true;
      }

      const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
      const nextPlayer = playerOrder[nextPlayerIndex];
      const nextHand = players[nextPlayer];
      const validMoves = getValidMoves(nextHand, board);
      if (validMoves.length === 0) {
        return isInevitableBlock(board, players, boneyard, nextPlayer, depth + 1, maxDepth, playerOrder);
      }

      let allLeadToBlock = true;
      for (const move of validMoves) {
        const simBoard = simulatePlay(board, move.tile, move.end);
		
        //const simPlayers = JSON.parse(JSON.stringify(players));
		const simPlayers = players.map(hand => hand.slice());

        const tileIdx = simPlayers[nextPlayer].findIndex(t => t.top === move.tile.top && t.bottom === move.tile.bottom);
        simPlayers[nextPlayer].splice(tileIdx, 1);
        if (simPlayers[nextPlayer].length === 0) {
          allLeadToBlock = false;
          break;
        }
        if (!isInevitableBlock(simBoard, simPlayers, boneyard, nextPlayer, depth + 1, maxDepth, playerOrder)) {
          allLeadToBlock = false;
          break;
        }
      }
      return allLeadToBlock;
    }

    function hasPreventingAlternative(hand, board, allPlayers, playerIndex, maxDepth = 0) {
      if (!board.leftEnd) return false;

      const playableTiles = hand.filter(tile => canPlayTile(tile, board));
      if (playableTiles.length < 1) return false;

      let hasNonBlockingMove = false;

      for (const tile of playableTiles) {
        const canPlayLeft = canPlayOnEnd(tile, board.leftEnd.value);
        const canPlayRight = canPlayOnEnd(tile, board.rightEnd.value);

        if (canPlayLeft) {
          const simBoard = simulatePlay(board, tile, 'left');
          const simPlayers = JSON.parse(JSON.stringify(allPlayers));
          const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
          simPlayers[playerIndex].splice(tileIdx, 1);
          if (!isInevitableBlock(simBoard, simPlayers, [], playerIndex, 1, maxDepth)) {
            hasNonBlockingMove = true;
            break;
          }
        }

        if (canPlayRight && (!isDouble(tile) || !canPlayLeft)) {
          const simBoard = simulatePlay(board, tile, 'right');
          const simPlayers = JSON.parse(JSON.stringify(allPlayers));
          const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
          simPlayers[playerIndex].splice(tileIdx, 1);
          if (!isInevitableBlock(simBoard, simPlayers, [], playerIndex, 1, maxDepth)) {
            hasNonBlockingMove = true;
            break;
          }
        }
      }

      const hasMultipleOptions = playableTiles.length > 1 ||
        (playableTiles.length === 1 &&
         canPlayOnEnd(playableTiles[0], board.leftEnd.value) &&
         canPlayOnEnd(playableTiles[0], board.rightEnd.value));

      return hasMultipleOptions && hasNonBlockingMove;
    }
	///
async function trainAIForMode(playerCount) {
  const trainingKey = `Domino_AI_Trained_${playerCount}P`;
  const alreadyTrained = localStorage.getItem(trainingKey);
  
  if (!alreadyTrained) {
    // Show loading message
    const loadingMsg = document.createElement('div');
    loadingMsg.id = 'ai-training-msg';
    loadingMsg.style.cssText = 'position:fixed; width:90%;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#0f0;padding:30px 15px;border:2px solid #0f0;border-radius:10px;z-index:10001;font-size:18px;text-align:center;';
    loadingMsg.innerHTML = `ü§ñ Training AI for ${playerCount}-player mode...<br><br><br><span style="font-size:14px;color:#add8e6;">Progress: 0/2000 games (0%)</span>`;
    document.body.appendChild(loadingMsg);
    
    // Progress callback to update UI
    const updateProgress = (gamesCompleted) => {
      if (loadingMsg && loadingMsg.parentNode) {
        const percent = Math.floor((gamesCompleted / 2000) * 100);
        loadingMsg.innerHTML = `ü§ñ Training AI for ${playerCount}-player mode...<br><br><br><span style="font-size:14px;color:#add8e6;">Progress: ${gamesCompleted}/2000 games (${percent}%)</span>`;
      }
    };
    
    try {
      // Small delay to show message
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Temporarily set numPlayersVar for training
      const originalPlayerCount = numPlayersVar;
      numPlayersVar = playerCount;
      
      // Train AI on selected mode
      console.log(`ü§ñ Starting AI training for ${playerCount}-player mode...`);
      window.trainingMode = true;
      ///
	  const renderGameBackup = window.renderGame;
window.renderGame = function() {}; // disable rendering
	  ///
      await aiBrain.selfTrainAI(2000, 500, updateProgress);
      
	  ///
	  window.renderGame = renderGameBackup;
///
      window.trainingMode = false;
      
      // Restore original player count
      numPlayersVar = originalPlayerCount;
      
      // Mark as trained
      localStorage.setItem(trainingKey, 'true');
      console.log(`‚úÖ AI training complete for ${playerCount}-player mode!`);
      
      return true; // Trained successfully
      
    } catch (error) {
      console.error(`‚ùå Training failed for ${playerCount}-player mode:`, error);
      
      // Update message to show error
      if (loadingMsg && loadingMsg.parentNode) {
        loadingMsg.innerHTML = `‚ùå Training failed!<br><span style="font-size:14px;color:#ff6b6b;">Error: ${error.message}</span>`;
        setTimeout(() => {
          if (loadingMsg && loadingMsg.parentNode) {
            loadingMsg.remove();
          }
        }, 3000);
      }
      
      return false; // Training failed
      
    } finally {
      // Ensure training mode is reset
      window.trainingMode = false;
      
      // Remove loading message after delay
      setTimeout(() => {
        if (loadingMsg && loadingMsg.parentNode) {
          loadingMsg.remove();
        }
      }, 1000);
    }
    
  } else {
    console.log(`‚úÖ AI already trained for ${playerCount}-player mode`);
    try {
      const qSize = Object.keys(aiBrain.exportQ ? JSON.parse(aiBrain.exportQ()) : {}).length;
      console.log(`üìä Current Q-table has ${qSize} learned states`);
    } catch (e) {
      console.log(`üìä Q-table exists but size couldn't be determined`);
    }
    return false; // Already trained
  }
}
	
	///
	/* ===== Domino AI Brain (Q-learning) - insert ABOVE playAI() =====
   Stores Q-table in localStorage ("Domino_AI_Q").
   Works with your existing functions:
     - getValidMoves(hand, board)   -> returns array of validMoves { tile, end } or similar
     - playTile(gameState, tile, end) -> updates gameState (or use playMove if your project uses that)
     - setupGame(), renderGame(), etc.
   If your play function is named differently, replace playTile(...) calls below with your function.
*/
// --- Suppress all alerts while training ---
(function() {
  const originalAlert = window.alert;
  window.alert = function(msg) {
    if (!window.trainingMode) originalAlert(msg);
    // else ignore silently during AI self-training
  };
})();
///

const aiBrain = (function () {
  const LS_KEY = "Domino_AI_Q";
  const alpha = 0.12;
  const gamma = 0.9;
  const epsilonDefault = 0.12;
  
  // ‚≠ê SEPARATE CONTROLS
  const TRAINING_THRESHOLD = 0.02;  // Keep learning during training (LOW)
  const NORMAL_CLEANING = 0.50;     // Light periodic cleaning during training
  const FINAL_CLEANING = 0.65;      // Final aggressive clean (MODERATE)
  
  // Cleaning thresholds
  const ACTION_THRESHOLD_NORMAL = NORMAL_CLEANING * 0.12;      // = 0.06
  const ACTION_THRESHOLD_AGGRESSIVE = FINAL_CLEANING * 0.20;   // = 0.13 (not too high!)
  const STATE_AVG_THRESHOLD_NORMAL = NORMAL_CLEANING * 0.08;   // = 0.04
  const STATE_AVG_THRESHOLD_AGGRESSIVE = FINAL_CLEANING * 0.15; // = 0.098
  
  let Q = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
  let saveCounter = 0;
  let updateCounter = 0;
///
function cleanQTable(Q, aggressive = false) {
  const stats = {
    originalStates: Object.keys(Q).length,
    originalActions: 0,
    skippedEmpty: 0,
    skippedWeak: 0,
    skippedLowValue: 0,
    keptStates: 0,
    keptActions: 0
  };
  
  for (const actions of Object.values(Q)) {
    stats.originalActions += Object.keys(actions || {}).length;
  }
  
  const cleaned = {};
  
  // Use pre-calculated thresholds based on CLEANING_AGGRESSIVENESS
  const ACTION_THRESHOLD = aggressive ? ACTION_THRESHOLD_AGGRESSIVE : ACTION_THRESHOLD_NORMAL;
  const STATE_AVG_THRESHOLD = aggressive ? STATE_AVG_THRESHOLD_AGGRESSIVE : STATE_AVG_THRESHOLD_NORMAL;
  const MIN_ACTIONS_PER_STATE = aggressive ? 2 : 1;
  
  for (const [state, actions] of Object.entries(Q)) {
    if (!actions || Object.keys(actions).length === 0) {
      stats.skippedEmpty++;
      continue;
    }
    
    const filteredActions = {};
    let totalQ = 0;
    let strongActions = 0;
    
    for (const [action, qValue] of Object.entries(actions)) {
      const absQ = Math.abs(qValue);
      
      if (absQ >= ACTION_THRESHOLD) {
        filteredActions[action] = qValue;
        totalQ += absQ;
        strongActions++;
        stats.keptActions++;
      } else {
        stats.skippedWeak++;
      }
    }
    
    if (strongActions < MIN_ACTIONS_PER_STATE) {
      stats.skippedLowValue++;
      continue;
    }
    
    const avgQ = strongActions > 0 ? totalQ / strongActions : 0;
    if (avgQ < STATE_AVG_THRESHOLD) {
      stats.skippedLowValue++;
      continue;
    }
    
    cleaned[state] = filteredActions;
    stats.keptStates++;
  }
  
  const reduction = stats.originalStates > 0 
    ? ((1 - stats.keptStates / stats.originalStates) * 100).toFixed(1)
    : 0;
  
  if (!window.trainingMode) {
    console.log(`üßπ Q-table cleaned (aggressiveness: ${(CLEANING_AGGRESSIVENESS * 100).toFixed(0)}%): ${stats.originalStates}‚Üí${stats.keptStates} states (${reduction}% reduction)`);
    console.log(`   üìä Actions: ${stats.originalActions}‚Üí${stats.keptActions}`);
    console.log(`   üóëÔ∏è  Removed: ${stats.skippedEmpty} empty, ${stats.skippedWeak} weak actions, ${stats.skippedLowValue} low-value states`);
  }
  
  return { cleaned, stats };
}

///
function saveQ(force = false) {
  saveCounter++;
  
  // Fast: just save, no cleaning
  if (force || saveCounter % 100 === 0) {
    localStorage.setItem(LS_KEY, JSON.stringify(Q));
  }
}
///  
function getQValue(gameState, playerIndex, actionMove) {
  const k = stateKey(gameState, playerIndex);
  if (!Q[k] || typeof Q[k] !== 'object') return 0;
  
  try {
    const ak = actionKey(actionMove);
    return Q[k][ak] ?? 0;
  } catch (e) {
    return 0;
  }
}
///

  // Create a compact but descriptive state key
  function stateKey(gameState, playerIndex) {
    try {
      const board = gameState.board || {};
      const left = board.leftEnd ? board.leftEnd.value ?? board.leftEnd : (board.leftEnd ?? "N");
      const right = board.rightEnd ? board.rightEnd.value ?? board.rightEnd : (board.rightEnd ?? "N");
      const hand = (gameState.players && Array.isArray(gameState.players[playerIndex]))
        ? gameState.players[playerIndex].map(t => `${t.top}${t.bottom}`).sort().join(',')
        : "H";
      return `${left}_${right}|P${playerIndex}|${hand}`;
    } catch (e) {
      return "ERR";
    }
  }

  // Turn a move object into an action key string
  function actionKey(move) {
    if (!move) return "PASS";
    if (typeof move === "string") return move;
    const t = Array.isArray(move.tile) ? move.tile.join(':') : JSON.stringify(move.tile);
    const end = move.end || "";
    return `${t}@${end}`;
  }

  // Œµ-greedy choice from validMoves
  function chooseMove(gameState, playerIndex, validMoves, epsilon = epsilonDefault) {
    if (!Array.isArray(validMoves) || validMoves.length === 0) return null;
    const key = stateKey(gameState, playerIndex);
    if (!Q[key]) Q[key] = {};

    // Exploration
    if (Math.random() < epsilon) {
      return validMoves[Math.floor(Math.random() * validMoves.length)];
    }

    // Exploitation: choose highest Q
    let best = validMoves[0];
    let bestScore = -Infinity;
    for (const m of validMoves) {
      const ak = actionKey(m);
      const val = Q[key][ak] ?? 0;
      if (val > bestScore) { bestScore = val; best = m; }
    }
    return best;
  }

  // Get max Q for a given state
  ///
function maxQForStateKey(k) {
  if (!Q[k] || typeof Q[k] !== 'object') return 0;
  
  try {
    const vals = Object.values(Q[k]);
    if (vals.length === 0) return 0;
    return Math.max(...vals);
  } catch (e) {
    return 0;
  }
}
///
  // Update Q-table with immediate weak-value filtering
  ///
function updateQ(gameState, playerIndex, actionMove, reward, nextGameState) {
  const s = stateKey(gameState, playerIndex);
  const s2 = stateKey(nextGameState, playerIndex);
  
  if (!Q[s] || typeof Q[s] !== 'object') Q[s] = {};
  if (!Q[s2] || typeof Q[s2] !== 'object') Q[s2] = {};

  const a = actionKey(actionMove);
  const old = Q[s][a] ?? 0;
  const maxNext = maxQForStateKey(s2);
  const updated = old + alpha * (reward + gamma * maxNext - old);
  
  // ‚≠ê USE LOW THRESHOLD DURING TRAINING (keep most learning)
  if (Math.abs(updated) >= TRAINING_THRESHOLD) {
    Q[s][a] = updated;
  } else if (Q[s][a] !== undefined) {
    delete Q[s][a];
  }
  
  // ‚≠ê Only remove TRULY empty states during training
  try {
    if (Q[s] && typeof Q[s] === 'object' && Object.keys(Q[s]).length === 0) {
      delete Q[s];
    }
    if (Q[s2] && typeof Q[s2] === 'object' && Object.keys(Q[s2]).length === 0) {
      delete Q[s2];
    }
  } catch (e) {
    // Silently ignore
  }
  
  saveQ();
}
///
  // Reward function with [0-0] = 13 rule
// Reward function with 0-0=13 rule and adaptive win/loss/defensive logic
function calculateReward(gameStateBefore, playerIndex, actionMove, gameStateAfter) {
  let r = 0.5; // base reward

  // Penalize PASS
  if (!actionMove || actionMove === "PASS") r -= 0.1;

  // Reward double tiles
  try {
    const t = actionMove && actionMove.tile ? actionMove.tile : null;
    if (t && t.top === t.bottom) r += 0.4;
  } catch (e) {}

  // --- Check players and hands ---
  const playersAfter = gameStateAfter?.players || [];
  const me = playersAfter[playerIndex];
  if (!me) return r;

  const myHand = me.hand || me; // support both array or object form
  const myTiles = myHand.length || 0;
  const myPipSum = myHand.reduce?.((a, t) => a + (t.top + t.bottom), 0) || 0;

  // Opponent stats
  const oppData = playersAfter
    .map((p, i) => (i === playerIndex ? null : p))
    .filter(Boolean)
    .map(p => ({
      pips: p.hand?.reduce?.((a, t) => a + (t.top + t.bottom), 0) || 0,
      tiles: p.hand?.length || 0
    }));

  const oppAvgPip = oppData.length ? oppData.reduce((a, o) => a + o.pips, 0) / oppData.length : 0;
  const oppMinPip = oppData.length ? Math.min(...oppData.map(o => o.pips)) : 0;
  const oppTotalTiles = oppData.reduce((a, o) => a + o.tiles, 0);

  const winnerIndex = gameStateAfter.winnerIndex;
  const gameBlocked = !!gameStateAfter.blocked;
  const canPlayMore = !!gameStateAfter.availableMoves?.length;

  // --- Win / Lose scaling ---
  if (winnerIndex === playerIndex) {
    // Won the round
    const diff = oppAvgPip - myPipSum;
    r += 8 + diff * 0.05; // base + margin bonus
  } else if (gameStateAfter.gameOver) {
    // Game ended (loss or block)
    const relativePerformance = 1 - (myPipSum / (oppAvgPip + 1)); // 0..1
    r += 2 + relativePerformance * 2; // reward small if loss is mild
  }

  // --- Defensive Block Awareness ---
  if (gameBlocked && winnerIndex === null) {
    const pipGap = myPipSum - oppMinPip;
    const heavyHand = myTiles > oppTotalTiles / oppData.length + 2;

    if (!canPlayMore) {
      // Forced block (no one can move)
      const defensiveValue = Math.max(0, 1 - (myPipSum / (oppAvgPip + 1)));
      r += defensiveValue * 2;
    } else if (heavyHand) {
      // Intentional block with heavy hand: may reduce total loss
      const lossMitigation = Math.max(0, 1 - (pipGap / 40));
      r += 1 + lossMitigation * 1.5;
    } else {
      // Early block with light hand = bad choice
      r += 0.1;
    }
  }

  // --- Endgame penalties for leftover pips (kept from your code) ---
  if (gameStateAfter.gameOver && myTiles > 0) {
    try {
      const actualValues = computePlayerValues(playersAfter);
      const actualHandValue = actualValues[playerIndex];
      r -= Math.min(3, actualHandValue / 15);
    } catch (e) {}
  }

  // --- Normalize reward ---
  if (r < 0) r = 0;
  if (r > 15) r = 15;
  return r;
}
///
  // ‚≠ê NEW: Manual cleaning function
  function manualClean(aggressive = true) {
    const { cleaned, stats } = cleanQTable(Q, aggressive);
    Q = cleaned;
    localStorage.setItem(LS_KEY, JSON.stringify(cleaned));
    return stats;
  }

  // ‚≠ê NEW: Get Q-table statistics
  function getStats() {
    const states = Object.keys(Q).length;
    const actions = Object.values(Q).reduce((sum, a) => sum + Object.keys(a || {}).length, 0);
    const avgActionsPerState = states > 0 ? (actions / states).toFixed(2) : 0;
    
    return {
      states,
      actions,
      avgActionsPerState
    };
  }

  // Expose API
  return {
    chooseMove,
    updateQ,
    getQValue,
    calculateReward,
    save: () => { saveQ(true); },
    load: () => { Q = JSON.parse(localStorage.getItem(LS_KEY) || "{}"); },
    exportQ: () => JSON.stringify(Q),
    importQ: (json) => { Q = JSON.parse(json || "{}"); saveQ(true); },
    clean: manualClean, // ‚≠ê NEW
    getStats: getStats, // ‚≠ê NEW
    LS_KEY,
async selfTrainAI(iterations = 2000, showEvery = 200, progressCallback = null) {
  // Setup code
  if (window.trainingMode) {
    console.warn("‚ö†Ô∏è Training already in progress. Force resetting...");
    window.trainingMode = false;
    window.lastTrainingStartTime = null;
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  window.trainingMode = true;
  window.lastTrainingStartTime = Date.now();
  console.log(`ü§ñ selfTrainAI: starting ${iterations} games for ${numPlayersVar}-player mode`);
  
  const initialStats = getStats();
  console.log(`üìä Initial Q-table: ${initialStats.states} states, ${initialStats.actions} actions`);

  let consecutiveErrors = 0;
  const MAX_CONSECUTIVE_ERRORS = 100;

  try {
    // ========== TRAINING LOOP ==========
    for (let g = 0; g < iterations; g++) {
      try {
        let gs = setupGame();
        if (typeof gs.gameOver === 'undefined') gs.gameOver = false;

        let safety = 200;
        let turnCount = 0;

        while (!gs.gameOver && safety-- > 0 && turnCount < 200) {
          turnCount++;
          
          const p = (typeof currentActivePlayerTurn === 'number') ? currentActivePlayerTurn
                    : (typeof gs.currentPlayer === 'number' ? gs.currentPlayer
                    : (typeof gs.turnIndex === 'number' ? gs.turnIndex : 0));

          if (!gs.players || !Array.isArray(gs.players) || !gs.players[p]) {
            throw new Error("Invalid game state players or player index");
          }

          const playerHand = gs.players[p];
          const validMoves = (typeof getValidMoves === "function") ? getValidMoves(playerHand, gs.board) : [];

          const stateBefore = {
            players: gs.players.map(hand => hand.slice()),
            board: gs.board ? {
              leftEnd: gs.board.leftEnd ? {...gs.board.leftEnd} : null,
              rightEnd: gs.board.rightEnd ? {...gs.board.rightEnd} : null
            } : null
          };

          let chosen;
          if (!validMoves || validMoves.length === 0) {
            if (typeof drawUntilMatch === "function") {
              try { drawUntilMatch(gs, p); } catch (e) { /* ignore */ }
            }
            chosen = "PASS";
          } else {
            chosen = aiBrain.chooseMove(gs, p, validMoves, 0.25);

            if (!chosen || !chosen.tile) {
              chosen = validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            if (typeof playTile === "function") {
              const played = playTile(gs, chosen.tile, chosen.end);
              if (!played) {
                gs.gameOver = true;
                break;
              }
            } else {
              throw new Error("No playTile function found for training.");
            }
          }

          const stateAfter = {
            players: gs.players.map(hand => hand.slice()),
            board: gs.board ? {
              leftEnd: gs.board.leftEnd ? {...gs.board.leftEnd} : null,
              rightEnd: gs.board.rightEnd ? {...gs.board.rightEnd} : null
            } : null,
            gameOver: gs.gameOver
          };

          try {
            const reward = aiBrain.calculateReward(stateBefore, p, chosen, stateAfter);
            aiBrain.updateQ(stateBefore, p, chosen, reward, stateAfter);
          } catch (e) {
            // Silently ignore learning errors during training
          }

          if (gs.gameOver) break;
        }

        consecutiveErrors = 0;
        gs = null;

        // Progress logging
        if (g % 500 === 0 || g === iterations - 1) {
          window.lastTrainingStartTime = Date.now();
          
          const stats = getStats();
          console.log(`üéÆ Training: ${g}/${iterations} games | Q-table: ${stats.states} states, ${stats.actions} actions (${stats.avgActionsPerState} avg/state)`);
          
          if (progressCallback && typeof progressCallback === 'function') {
            try {
              progressCallback(g);
            } catch (e) {
              console.warn("Progress callback failed:", e);
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, 0));
        }
        
        // Save checkpoint
        if (g % 1000 === 0 && g > 0) {
          try { 
            saveQ(true); 
            console.log(`üíæ Checkpoint save at ${g} games`);
          } catch (e) { 
            console.warn("Save failed:", e);
          }
        }

      } catch (err) {
        consecutiveErrors++;
        
        if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
          console.error(`‚ùå Too many consecutive errors (${consecutiveErrors}). Stopping training.`);
          throw new Error("Training failed: too many consecutive errors");
        }
        
        if (g % 1000 === 0) {
          console.warn(`‚ö†Ô∏è Game ${g} failed (${consecutiveErrors} consecutive):`, err.message || err);
        }
        continue;
      }
    }
    // ========== END OF TRAINING LOOP ==========

    // ‚≠ê‚≠ê‚≠ê CRITICAL: FINAL CLEAN MUST BE HERE (AFTER the for loop, BEFORE catch block)
    console.log(`üßπ Training complete. Starting final aggressive clean...`);
    
    // Final progress callback
    if (progressCallback && typeof progressCallback === 'function') {
      try {
        progressCallback(iterations);
      } catch (e) {
        console.warn("Progress callback failed:", e);
      }
    }

    // Final aggressive clean
    const beforeClean = Object.keys(Q).length;
    console.log(`üìä Q-table before final clean: ${beforeClean} states`);
    
    const finalCleanStats = manualClean(true); // Use aggressive=true
    
    console.log(`‚úÖ Final clean complete: ${finalCleanStats.originalStates}‚Üí${finalCleanStats.keptStates} states (${((1 - finalCleanStats.keptStates / finalCleanStats.originalStates) * 100).toFixed(1)}% reduction)`);
    console.log(`   üìä Actions: ${finalCleanStats.originalActions}‚Üí${finalCleanStats.keptActions}`);
    
    // Final save
    try { 
      saveQ(true); 
      console.log(`üíæ Final save completed`);
    } catch (e) { 
      console.error("Final save failed:", e);
    }
    
    // Show final stats
    const finalStats = getStats();
    console.log(`‚úÖ Training complete! Final Q-table: ${finalStats.states} states, ${finalStats.actions} actions`);
    console.log(`üìà Learning efficiency: ${(finalStats.actions / iterations).toFixed(2)} meaningful actions per game`);
    
    if (finalStats.states > 0) {
      const samples = Object.entries(Q).slice(0, 3).map(([state, actions]) => ({
        state: state.substring(0, 50) + '...',
        actions: Object.keys(actions).length,
        bestAction: Object.entries(actions).sort((a, b) => b[1] - a[1])[0]
      }));
      console.log(`üìä Sample Q-values:`, samples);
    }
    
  } catch (error) {
    console.error("‚ùå Training failed:", error);
    throw error;
  } finally {
    // ALWAYS reset training mode
    window.trainingMode = false;
    window.lastTrainingStartTime = null;
    console.log(`üíæ Q-table saved to localStorage key: ${LS_KEY}`);
  }
}
 };
})(); // end aiBrain


/* ===== End AI Brain ===== */
function safeAlert(msg) {
  if (window.trainingMode) {
    return; // Silently ignore during training
  }
  alert(msg);
}
	///
function playAI(gameState) {
// ‚≠ê FIX: Add a safety guard to never run AI logic for the human player (0)
  if (currentActivePlayerTurn === 0) {
    console.error("‚ö†Ô∏è playAI was incorrectly called for Player 0. Aborting.");
    return; 
  }
  ///
  const { players, board, roundHistory, isThisFirstGame, boneyard, playerOrder } = gameState; 

  // --- SAFETY CHECK FOR TURN INDEX ---
  if (typeof currentActivePlayerTurn !== 'number' || currentActivePlayerTurn < 0 || currentActivePlayerTurn >= players.length) {
    console.error('‚ö†Ô∏è playAI: invalid currentActivePlayerTurn =', currentActivePlayerTurn, 'players length =', players.length);
    return;
  }

  const playerHand = players[currentActivePlayerTurn];
  if (!Array.isArray(playerHand)) {
    console.error('‚ö†Ô∏è playAI: playerHand is invalid', playerHand);
    return;
  }

  const has_boneyard = playerOrder.length < 4;
  const bet = gameState.bet || 1; // fall-back if not provided

  // ===== small helpers (embedded so you don't need external changes) =====
  const TOTAL_PIP_TILES = 7; // double-six set: each pip (0..6) appears on 7 tiles (0..6 paired with pip)

  function clone(obj) { return JSON.parse(JSON.stringify(obj)); }

  // Count pip occurrences we have actually seen: board tiles + played tiles (roundHistory) + our own hand
  function countSeenPips() {
    const counts = Array(7).fill(0);

function addTile(t) {
      if (!t) return;
      
      if (t.top === t.bottom) {
        // If it's a double, only count it once
        counts[t.top] = (counts[t.top] || 0) + 1;
      } else {
        // Otherwise, count both pips
        counts[t.top] = (counts[t.top] || 0) + 1;
        counts[t.bottom] = (counts[t.bottom] || 0) + 1;
      }
    }
	
    // Board tiles (visible)
    if (board && Array.isArray(board.tiles)) {
      board.tiles.forEach(addTile);
    }

    // Round history: tiles that were played earlier (if structure exists)
    if (Array.isArray(roundHistory)) {
      roundHistory.forEach(entry => {
        if (entry && entry.tile) addTile(entry.tile);
      });
    }

    // Our own hand (we know them)
    playerHand.forEach(addTile);

    // Note: we do NOT count opponents' hidden hands or unknown boneyard tiles here.
    return counts;
  }

  // Remaining possible tiles for a pip given seen counts
  function remainingPipCounts(seenCounts) {
    const remaining = Array(7).fill(0);
    for (let p = 0; p <= 6; p++) {
      remaining[p] = Math.max(0, TOTAL_PIP_TILES - (seenCounts[p] || 0));
    }
    return remaining;
  }

  // After playing `tile`, what will remaining counts look like (simulate removing its pips from seen)
  function remainingAfterPlaying(seenCounts, tile) {
    const next = seenCounts.slice();
    next[tile.top] = Math.max(0, next[tile.top] - 1);
    next[tile.bottom] = Math.max(0, next[tile.bottom] - 1);
    return remainingPipCounts(next);
  }

  // Utility: measure how "closed" an end is (0 remaining => closed; 1 => nearly closed)
  function closureScoreForValue(remainingCounts, val) {
    const r = remainingCounts[val];
    if (r === 0) return 100; // effectively closed
    if (r === 1) return 60;
    if (r === 2) return 30;
    if (r === 3) return 15;
    return 0;
  }

  // ===== NEW HELPER FUNCTION =====
  function checkOpponentWinningBlock(simBoard, simPlayers, boneyard, boneyardEmpty, playerOrder, currentActivePlayerTurn, winningOpponents) {
    let opponentCanCreateWinningBlock = false;
    for (const opponent of winningOpponents) {
      const oppPlayer = opponent.player;
      const oppHand = simPlayers[oppPlayer];
      const oppMoves = getValidMoves(oppHand, simBoard);

      if (oppMoves.length > 0) {
        for (const oppMove of oppMoves) {
          const oppSimBoard = simulatePlay(simBoard, oppMove.tile, oppMove.end);
          const oppSimPlayers = clone(simPlayers);
          const oppTileIdx = oppSimPlayers[oppPlayer].findIndex(t =>
            t.top === oppMove.tile.top && t.bottom === oppMove.tile.bottom
          );
          if (oppTileIdx === -1) continue;
          oppSimPlayers[oppPlayer].splice(oppTileIdx, 1);

          const oppIsBlock = !isPlayableForAnyone(oppSimPlayers, boneyard, oppSimBoard, playerOrder);
          if (oppIsBlock && boneyardEmpty) {
            const oppSimValues = computePlayerValues(oppSimPlayers);
            const oppValue = oppSimValues[oppPlayer];
            const othersValues = playerOrder.filter(p => p !== oppPlayer).map(p => oppSimValues[p]);
            const minOthers = Math.min(...othersValues);
            if (oppValue <= minOthers) {
              opponentCanCreateWinningBlock = true;
              break;
            }
          }
        }
      }
      if (opponentCanCreateWinningBlock) break;
    }
    return opponentCanCreateWinningBlock;
  }

  // ===== TILE COUNT & HAND VALUE ANALYSIS =====
  const myTileCount = playerHand.length;
  const opponentTileCounts = playerOrder
    .filter(p => p !== currentActivePlayerTurn)
    .map(p => players[p].length);
  const minOpponentTiles = opponentTileCounts.length ? Math.min(...opponentTileCounts) : 0;
  const tileCountDisadvantage = myTileCount - minOpponentTiles;

  const isInDanger = tileCountDisadvantage >= 2;
  const isAtRisk = tileCountDisadvantage >= 1;

  const currentValues = computePlayerValues(players);
  const myCurrentValue = currentValues[currentActivePlayerTurn];
  const opponentValues = playerOrder.filter(p => p !== currentActivePlayerTurn).map(p => currentValues[p]);
  const minOpponentValue = opponentValues.length ? Math.min(...opponentValues) : Infinity;
  const maxOpponentValue = opponentValues.length ? Math.max(...opponentValues) : -Infinity;

  // ===== OPPONENT THREAT ASSESSMENT =====
  const opponentThreats = playerOrder
    .filter(p => p !== currentActivePlayerTurn)
    .map(p => ({
      player: p,
      tileCount: players[p].length,
      handValue: currentValues[p],
      isWinningPosition: currentValues[p] <= myCurrentValue
    }));
  
  const winningOpponents = opponentThreats.filter(o => o.isWinningPosition);
  const hasWinningOpponent = winningOpponents.length > 0;
  const mostDangerousOpponent = opponentThreats
    .filter(opp => opp.isWinningPosition)
    .sort((a, b) => a.handValue - b.handValue)[0] || null;
    
  // Find opponents who can win *next turn* (1 tile left)
  const runOutThreats = playerOrder.filter(p =>
    p !== currentActivePlayerTurn && players[p].length === 1
  );

  // ===== Precompute pip visibility =====
  const seenPips = countSeenPips();
  const remainingPipsGlobal = remainingPipCounts(seenPips); // how many of each pip left unknown

  // Enforce highest double on first play (your original rule)
  if (!board.leftEnd && isThisFirstGame) {
    if (gameState.highestDouble && playerHand.some(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom)) {
      const tileToPlay = playerHand.find(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom);
      playTile(gameState, tileToPlay, 'right');
      return;
    }
  }

  // snapshot before evaluation for learning
  const stateBefore = clone(gameState);

  let bestMove = { tile: null, end: null, score: -Infinity };
  const validMoves = getValidMoves(playerHand, board);

  if (validMoves.length === 0) return;

  // collect moveScores so aiBrain can choose among top candidates
  const moveScores = [];

  for (const move of validMoves) {
    let score = 0;
    const { tile, end } = move;

    const simBoard = simulatePlay(board, tile, end);
    const simPlayers = clone(players);
    const tileIndex = simPlayers[currentActivePlayerTurn].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
    
    // Safety check: if tile not found, this move is invalid
    if (tileIndex === -1) continue; 
    
    simPlayers[currentActivePlayerTurn].splice(tileIndex, 1);

    // ===== PRIORITY 0: WINNING MOVE =====
    if (simPlayers[currentActivePlayerTurn].length === 0) {
      // Strong preference to go out immediately
      score = 1_000_000;
      bestMove = { tile, end, score };
      // still push into moveScores and break evaluation loop
      moveScores.push({ move, score });
      break;
    }
    
    // ===== ‚≠êÔ∏è NEW: PRIORITY -1: AVOID OPPONENT WIN (RUN-OUT) ‚≠êÔ∏è =====
    let opponentCanWinNext = false;
    if (runOutThreats.length > 0) {
      for (const oppPlayer of runOutThreats) {
        const oppHand = players[oppPlayer];
        const oppMoves = getValidMoves(oppHand, simBoard);
        if (oppMoves.length > 0) {
          opponentCanWinNext = true;
          break;
        }
      }
    }

    if (opponentCanWinNext) {
      score = -500_000;
      if (score > bestMove.score) bestMove = { tile, end, score };
      moveScores.push({ move, score });
      continue;
    }
    // =============================================================

    const simValues = computePlayerValues(simPlayers);
    const mySimValue = simValues[currentActivePlayerTurn];

    const remainingIfPlayed = remainingAfterPlaying(seenPips, tile);

    const leftVal = simBoard.leftEnd.value;
    const rightVal = simBoard.rightEnd.value;
    const leftClosureScore = closureScoreForValue(remainingIfPlayed, leftVal);
    const rightClosureScore = closureScoreForValue(remainingIfPlayed, rightVal);

    const isBlock = !isPlayableForAnyone(simPlayers, boneyard, simBoard, playerOrder);
    const boneyardEmpty = has_boneyard ? boneyard.length === 0 : true;

    if (isBlock && boneyardEmpty) {
      const simOpponentValues = playerOrder.filter(p => p !== currentActivePlayerTurn).map(p => simValues[p]);
      const minSimOpponent = Math.min(...simOpponentValues);

      if (mySimValue <= minSimOpponent) {
        score += 8000;
        const valueDifference = minSimOpponent - mySimValue;
        score += valueDifference * 100;
      } else {
        score -= 2000;
        const valueDifference = mySimValue - minSimOpponent;
        score -= valueDifference * 100;
      }
    }

    // PIP AVAILABILITY & BLOCK FORECASTING
    const affectsLeft = (end === 'left') || (move.ends && move.ends.includes('left')) || (simBoard.leftEnd.value === tile.top || simBoard.leftEnd.value === tile.bottom);
    const affectsRight = (end === 'right') || (move.ends && move.ends.includes('right')) || (simBoard.rightEnd.value === tile.top || simBoard.rightEnd.value === tile.bottom);

    if (affectsLeft && leftClosureScore >= 60) {
      if (mySimValue <= minOpponentValue) score += 3000;
      else score -= 2500;
    }

    if (affectsRight && rightClosureScore >= 60) {
      if (mySimValue <= minOpponentValue) score += 3000;
      else score -= 2500;
    }

    // PRIORITY BRANCHING: DANGER MODE vs NORMAL MODE
    if (isInDanger || isAtRisk) {
      let tileValue = tile.top + tile.bottom;
// ‚≠ê NEW: Check if playing this tile will trigger [0-0] = 13 rule
if (tileValue === 0) { // It's [0-0]
  // Count zeros currently visible (before playing this tile)
  let zerosOnTable = 0;
  if (board && Array.isArray(board.tiles)) {
    board.tiles.forEach(t => {
      if (t.tile.top === 0) zerosOnTable++;
      if (t.tile.bottom === 0) zerosOnTable++;
    });
  }
  if (Array.isArray(roundHistory)) {
    roundHistory.forEach(entry => {
      if (entry && entry.playedTile) {
        const t = entry.playedTile;
        if (t.top === 0) zerosOnTable++;
        if (t.bottom === 0) zerosOnTable++;
      }
    });
  }
  
  // If 6+ zeros already visible, playing [0-0] means it's worth 13
  if (zerosOnTable >= 6) {
    tileValue = 13;
  }
}
      if (isInDanger) {
        score += tileValue * 150;
        if (tileValue >= 10) score += 2500;
        if (tileValue >= 9) score += 1500;
        if (tileValue >= 8) score += 800;
      } else if (isAtRisk) {
        score += tileValue * 80;
        if (tileValue >= 9) score += 1500;
        if (tileValue >= 7) score += 800;
        if (tileValue >= 5) score += 400;
      }

      const remAfter = remainingIfPlayed;
      const closureImpactLeft = closureScoreForValue(remAfter, leftVal);
      const closureImpactRight = closureScoreForValue(remAfter, rightVal);
      const closureImpact = Math.max(closureImpactLeft, closureImpactRight);
      if (closureImpact >= 100) {
        if (hasWinningOpponent) {
          const oppCouldWinBlock = checkOpponentWinningBlock(
            simBoard, simPlayers, boneyard, boneyardEmpty,
            playerOrder, currentActivePlayerTurn, winningOpponents
          );
          if (oppCouldWinBlock) {
            score -= 6000;
          }
        }
      }

      if (!isBlock && mostDangerousOpponent) {
        const nextPlayerIdx = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
        const nextPlayer = playerOrder[nextPlayerIdx];
        if (nextPlayer === mostDangerousOpponent.player) {
          const nextHand = simPlayers[nextPlayer];
          const nextMoves = getValidMoves(nextHand, simBoard);
          let remoteBlockThreat = false;
          for (const nextMove of nextMoves) {
            const nextSimBoard = simulatePlay(simBoard, nextMove.tile, nextMove.end);
            const nextSimPlayers = clone(simPlayers);
            const nextTileIdx = nextSimPlayers[nextPlayer].findIndex(t =>
              t.top === nextMove.tile.top && t.bottom === nextMove.tile.bottom
            );
            if(nextTileIdx === -1) continue;
            
            nextSimPlayers[nextPlayer].splice(nextTileIdx, 1);
            const stillPlayable = isPlayableForAnyone(nextSimPlayers, boneyard, nextSimBoard, playerOrder);
            if (!stillPlayable && boneyardEmpty) {
              const nextSimValues = computePlayerValues(nextSimPlayers);
              const nextOppValue = nextSimValues[nextPlayer];
              const othersVals = playerOrder.filter(p => p !== nextPlayer).map(p => nextSimValues[p]);
              const minOthers = Math.min(...othersVals);
              if (nextOppValue <= minOthers) {
                remoteBlockThreat = true;
                break;
              }
            }
          }
          if (remoteBlockThreat) {
            score -= 3000;
          }
        }
      }

      if (boneyardEmpty || boneyard.length < 3) {
        const afterHand = simPlayers[currentActivePlayerTurn];
        const valuesLeft = new Set();
        afterHand.forEach(t => { valuesLeft.add(t.top); valuesLeft.add(t.bottom); });
        const diversityAfter = valuesLeft.size;
        score += (10 - diversityAfter) * 200;
        if (closureImpact >= 60) score += 1200;
      }

    } else {
      // NORMAL MODE: Full strategic play

      if (has_boneyard) {
        let tileValue = tile.top + tile.bottom;
		// ‚≠ê NEW: Check if playing this tile will trigger [0-0] = 13 rule
if (tileValue === 0) { // It's [0-0]
  // Count zeros currently visible (before playing this tile)
  let zerosOnTable = 0;
  if (board && Array.isArray(board.tiles)) {
    board.tiles.forEach(t => {
      if (t.tile.top === 0) zerosOnTable++;
      if (t.tile.bottom === 0) zerosOnTable++;
    });
  }
  if (Array.isArray(roundHistory)) {
    roundHistory.forEach(entry => {
      if (entry && entry.playedTile) {
        const t = entry.playedTile;
        if (t.top === 0) zerosOnTable++;
        if (t.bottom === 0) zerosOnTable++;
      }
    });
  }
  
  // If 6+ zeros already visible, playing [0-0] means it's worth 13
  if (zerosOnTable >= 6) {
    tileValue = 13;
  }
}
        if (isDouble(tile)) tileValue += 5;

        if (!isBlock) {
          if (hasWinningOpponent) {
            const oppCouldWinBlock = checkOpponentWinningBlock(
              simBoard, simPlayers, boneyard, boneyardEmpty,
              playerOrder, currentActivePlayerTurn, winningOpponents
            );
            if (oppCouldWinBlock) {
              score -= 7000;
            }
          }

          if (mySimValue < minOpponentValue) {
            const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
            const nextPlayer = playerOrder[nextPlayerIndex];
            const nextPlayerHand = simPlayers[nextPlayer];
            const nextPlayerMoves = getValidMoves(nextPlayerHand, simBoard);
            if (nextPlayerMoves.length > 0) {
              let nextPlayerCouldLoseBlock = false;
              for (const nextMove of nextPlayerMoves) {
                const nextSimBoard = simulatePlay(simBoard, nextMove.tile, nextMove.end);
                const nextSimPlayers = clone(simPlayers);
                const nextTileIdx = nextSimPlayers[nextPlayer].findIndex(t =>
                  t.top === nextMove.tile.top && t.bottom === nextMove.tile.bottom
                );
                if (nextTileIdx === -1) continue;
                
                nextSimPlayers[nextPlayer].splice(nextTileIdx, 1);
                const nextIsBlock = !isPlayableForAnyone(nextSimPlayers, boneyard, nextSimBoard, playerOrder);
                if (nextIsBlock && boneyardEmpty) {
                  const nextSimValues = computePlayerValues(nextSimPlayers);
                  const nextPlayerValue = nextSimValues[nextPlayer];
                  const othersVals = playerOrder.filter(p => p !== nextPlayer).map(p => nextSimValues[p]);
                  const minOthers = Math.min(...othersVals);
                  if (nextPlayerValue > minOthers) {
                    nextPlayerCouldLoseBlock = true;
                    break;
                  }
                }
              }
              if (nextPlayerCouldLoseBlock) score += 4500;
            }
          }

          const tilesPlayableAfterThisMove = simPlayers[currentActivePlayerTurn].filter(t =>
            canPlayTile(t, simBoard)
          ).length;
          const remainingTileCount = simPlayers[currentActivePlayerTurn].length;
          const playabilityRatio = remainingTileCount > 0 ? (tilesPlayableAfterThisMove / remainingTileCount) : 0;

          score += playabilityRatio * 1000;
          if (playabilityRatio >= 0.5) score += 800;

          const leftEndVal = simBoard.leftEnd.value;
          const rightEndVal = simBoard.rightEnd.value;

          const tilesMatchingLeft = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === leftEndVal || t.bottom === leftEndVal
          ).length;
          const tilesMatchingRight = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === rightEndVal || t.bottom === rightEndVal
          ).length;

          if (tilesMatchingLeft === 0 && tilesMatchingRight === 0) {
            score -= 1500;
          }

          const totalMatchingTiles = tilesMatchingLeft + tilesMatchingRight;
          if (totalMatchingTiles === 1) score -= 800;
          else if (totalMatchingTiles === 2) score -= 400;
          else if (totalMatchingTiles >= 4) score += 300;

          if (leftEndVal === rightEndVal) score -= 200;

          score += tileValue * 30;

          if (boneyard.length > 0) {
            const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
            const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
            if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
              score += 200;
            }
          }

          const leftRarity = TOTAL_PIP_TILES - remainingIfPlayed[leftEndVal];
          const rightRarity = TOTAL_PIP_TILES - remainingIfPlayed[rightEndVal];
          score += leftRarity * 20;
          score += rightRarity * 20;

          if (boneyard.length < 5) {
            score += tileValue * 15;
          }
        }

      } else {
        // 4-player logic largely preserved but enriched with pip heuristics
        if (!isBlock) {
          if (hasWinningOpponent) {
            const oppCouldWinBlock = checkOpponentWinningBlock(
              simBoard, simPlayers, boneyard, true,
              playerOrder, currentActivePlayerTurn, winningOpponents
            );
            if (oppCouldWinBlock) {
              score -= 7000;
            }
          }

          const tilesPlayableAfterThisMove = simPlayers[currentActivePlayerTurn].filter(t =>
            canPlayTile(t, simBoard)
          ).length;
          const remainingTileCount = simPlayers[currentActivePlayerTurn].length;
          const playabilityRatio = remainingTileCount > 0 ? (tilesPlayableAfterThisMove / remainingTileCount) : 0;

          score += playabilityRatio * 1200;
          if (playabilityRatio >= 0.6) score += 1000;

          const leftEndVal = simBoard.leftEnd.value;
          const rightEndVal = simBoard.rightEnd.value;

          const tilesMatchingLeft = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === leftEndVal || t.bottom === leftEndVal
          ).length;
          const tilesMatchingRight = simPlayers[currentActivePlayerTurn].filter(t =>
            t.top === rightEndVal || t.bottom === rightEndVal
          ).length;

          if (tilesMatchingLeft === 0 && tilesMatchingRight === 0) {
            score -= 2000;
          }

          const totalMatchingTiles = tilesMatchingLeft + tilesMatchingRight;
          if (totalMatchingTiles === 1) score -= 1000;
          else if (totalMatchingTiles === 2) score -= 500;
          else if (totalMatchingTiles >= 5) score += 400;

          if (leftEndVal === rightEndVal) score -= 300;

          const pipsInRemainingHand = new Set();
          simPlayers[currentActivePlayerTurn].forEach(t => {
            pipsInRemainingHand.add(t.top);
            pipsInRemainingHand.add(t.bottom);
          });
          const pipDiversity = pipsInRemainingHand.size;
          score += pipDiversity * 50;

          let tileValue = tile.top + tile.bottom;
		  // ‚≠ê NEW: Check if playing this tile will trigger [0-0] = 13 rule
if (tileValue === 0) { // It's [0-0]
  // Count zeros currently visible (before playing this tile)
  let zerosOnTable = 0;
  if (board && Array.isArray(board.tiles)) {
    board.tiles.forEach(t => {
      if (t.tile.top === 0) zerosOnTable++;
      if (t.tile.bottom === 0) zerosOnTable++;
    });
  }
  if (Array.isArray(roundHistory)) {
    roundHistory.forEach(entry => {
      if (entry && entry.playedTile) {
        const t = entry.playedTile;
        if (t.top === 0) zerosOnTable++;
        if (t.bottom === 0) zerosOnTable++;
      }
    });
  }
  
  // If 6+ zeros already visible, playing [0-0] means it's worth 13
  if (zerosOnTable >= 6) {
    tileValue = 13;
  }
}
          if (isDouble(tile)) tileValue += 10;
          score += tileValue * 10;

          const nextPlayerIndex = (playerOrder.indexOf(currentActivePlayerTurn) + 1) % playerOrder.length;
          const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
          if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
            score += 200;
          }

          const rarityLeft = TOTAL_PIP_TILES - remainingIfPlayed[leftEndVal];
          const rarityRight = TOTAL_PIP_TILES - remainingIfPlayed[rightEndVal];
          score += rarityLeft * 5;
          score += rarityRight * 5;
        } else {
          const minValue = Math.min(...playerOrder.map(p => simValues[p]));
          if (mySimValue <= minValue) {
            let hadNonBlockingAlternative = false;
            for (const otherMove of validMoves) {
              if (otherMove.tile === move.tile && otherMove.end === move.end) continue;
              const otherSimBoard = simulatePlay(board, otherMove.tile, otherMove.end);
              const otherSimPlayers = clone(players);
              const otherTileIndex = otherSimPlayers[currentActivePlayerTurn].findIndex(t =>
                t.top === otherMove.tile.top && t.bottom === otherMove.tile.bottom
              );
              if (otherTileIndex === -1) continue;

              otherSimPlayers[currentActivePlayerTurn].splice(otherTileIndex, 1);
              if (isPlayableForAnyone(otherSimPlayers, boneyard, otherSimBoard, playerOrder)) {
                hadNonBlockingAlternative = true;
                break;
              }
            }
            if (hadNonBlockingAlternative) score += 5000;
            else score += 2500;
          }
        }
      }
    }

    // FINAL: baseline tie-breakers
   // FINAL: baseline tie-breakers
if (myTileCount <= 3) {
  let tileValue = tile.top + tile.bottom;
  
  // ‚≠ê NEW: Check if playing this tile will trigger [0-0] = 13 rule
  if (tileValue === 0) { // It's [0-0]
    // Count zeros currently visible (before playing this tile)
    let zerosOnTable = 0;
    if (board && Array.isArray(board.tiles)) {
      board.tiles.forEach(t => {
        if (t.tile.top === 0) zerosOnTable++;
        if (t.tile.bottom === 0) zerosOnTable++;
      });
    }
    if (Array.isArray(roundHistory)) {
      roundHistory.forEach(entry => {
        if (entry && entry.playedTile) {
          const t = entry.playedTile;
          if (t.top === 0) zerosOnTable++;
          if (t.bottom === 0) zerosOnTable++;
        }
      });
    }
    
    // If 6+ zeros already visible, playing [0-0] means it's worth 13
    if (zerosOnTable >= 6) {
      tileValue = 13;
    }
  }
  
  score += -tileValue * 20; // Now uses correct value
  const afterHand = clone(simPlayers[currentActivePlayerTurn]);
  const setVals = new Set();
  afterHand.forEach(t => { setVals.add(t.top); setVals.add(t.bottom); });
  score += (10 - setVals.size) * 100;
}
///
// === NEW: Get AI Brain's opinion ===
    let qValue = 0;
    if (typeof aiBrain === 'object' && typeof aiBrain.getQValue === 'function') {
      // Use the new function to get the brain's learned score
      qValue = aiBrain.getQValue(stateBefore, currentActivePlayerTurn, move);
    }

    // === NEW: Combine scores ===
    // W_h = Heuristic Weight, W_q = Q-Learning Weight
    // We can "tune" these. Start by trusting the heuristic 100% and the brain 50%.
    const W_h = 1.0; 
    const W_q = 50.0; // Tunable: How much to trust the AI brain. 
                      // Needs to be high to compete with heuristic scores (like +8000)

    // The final score is a weighted sum of both "brains"
    const finalScore = (score * W_h) + (qValue * W_q);
    
    // Store the *combined* score
    moveScores.push({ move, score: finalScore }); 

    if (finalScore > bestMove.score) {
      bestMove = { tile, end, score: finalScore };
    }
  } // end for validMoves

///
// === SELECTION: Choose the best *combined* score ===
  // The 'bestMove' variable now holds the move with the highest combined score
  // from the Heuristic Engine AND the AI Brain.

  let chosenMove = { tile: bestMove.tile, end: bestMove.end };

  // We must still include "exploration" for the AI to learn.
  // This (epsilon) is the *real* job for aiBrain.chooseMove, not picking.
  // For simplicity, we can add a simple epsilon-greedy check here:
  const epsilon = 0.1; // 10% chance to explore a random move
  if (Math.random() < epsilon && validMoves.length > 0) {
     chosenMove = validMoves[Math.floor(Math.random() * validMoves.length)];
  }


  // --- Play the chosen move normally ---
  if (chosenMove && chosenMove.tile) {
    playTile(gameState, chosenMove.tile, chosenMove.end);
  } else {
    if (typeof drawUntilMatch === "function") drawUntilMatch(gameState, currentActivePlayerTurn);
  }

  // --- After move: learning update ---
  try {
    const stateAfter = clone(gameState);
    if (typeof aiBrain === 'object' && typeof aiBrain.updateQ === 'function' && typeof aiBrain.calculateReward === 'function') {
      const reward = aiBrain.calculateReward(stateBefore, currentActivePlayerTurn, chosenMove, stateAfter);
      aiBrain.updateQ(stateBefore, currentActivePlayerTurn, chosenMove, reward, stateAfter);
    }
  } catch (e) {
    console.warn("playAI learning update failed:", e);
  }
}

///

// UPDATED handleTileClick function - use currentActivePlayerTurn
function handleTileClick(gameState, tileIndex, playButtons) {
  const { players, selectedIndex, board, isThisFirstGame } = gameState;
  const hand = players[0];
  const clickedTile = hand[tileIndex];

  if (currentActivePlayerTurn === 0) {
    // ACTIVE TURN - Selection mode only (for playing tiles)
    if (selectedIndex === tileIndex) {
      // Click selected tile again - just deselect
      gameState.selectedIndex = -1;
    } else {
      // Click different tile - select it
      gameState.selectedIndex = tileIndex;
    }
  } else {
    // INACTIVE TURN - Full sorting mode (rotate + swap)
    if (selectedIndex === -1) {
      // No tile selected - select this one
      gameState.selectedIndex = tileIndex;
    } else if (selectedIndex === tileIndex) {
      // Click selected tile again - ROTATE it
      // Exception: Don't rotate required highest double in first game
      if (board.tiles.length === 0 && isThisFirstGame) {
        const doubles = hand.filter(t => isDouble(t));
        if (doubles.length > 0) {
          const highestDouble = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
          if (clickedTile.top === highestDouble.top && clickedTile.bottom === highestDouble.bottom) {
            // Don't rotate required highest double - just deselect
            gameState.selectedIndex = -1;
            renderGame(gameState);
            return;
          }
        }
      }
      // Rotate the tile
      hand[tileIndex] = rotateTile(clickedTile);
      gameState.selectedIndex = -1;
    } else {
      // Different tile clicked - SWAP positions
      const selectedTile = hand[selectedIndex];
      hand[selectedIndex] = clickedTile;
      hand[tileIndex] = selectedTile;
      gameState.selectedIndex = -1;
    }
  }

  renderGame(gameState);
}
///
// Fixed playTile function - Add drawing tracking to roundHistory
function playTile(gameState, tile, end) {
  const { players, board, roundHistory, isThisFirstGame, playerOrder, boneyard } = gameState;
  const playerHand = players[currentActivePlayerTurn];
  const tileIndex = playerHand.findIndex(t => t.top === tile.top && t.bottom === tile.bottom);

  if (tileIndex === -1 || !canPlayTile(tile, board)) {
    console.warn("Invalid move attempt:", tile, "on board:", board.leftEnd?.value, board.rightEnd?.value);
    if (!window.trainingMode) {
      renderGame(gameState);
    }
    return false;
  }

  if (board.tiles.length === 0 && isThisFirstGame) {
    if (gameState.highestDouble) {
      if (tile.top !== gameState.highestDouble.top || tile.bottom !== gameState.highestDouble.bottom) {
        if (currentActivePlayerTurn === 0 && !window.trainingMode) {
          safeAlert(`Must play the highest double [${gameState.highestDouble.top}-${gameState.highestDouble.bottom}] first!`);
        }
        return false;
      }
      if (currentActivePlayerTurn !== playerOrder.find(p => players[p].some(t => t.top === gameState.highestDouble.top && t.bottom === gameState.highestDouble.bottom))) {
        return false;
      }
    }
  }

  const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();

  gameState.prevBoard = board.leftEnd ? {
    leftEnd: {...board.leftEnd},
    rightEnd: {...board.rightEnd}
  } : null;

  const playedTile = playerHand.splice(tileIndex, 1)[0];

  if (currentActivePlayerTurn === 0) {
    gameState.selectedIndex = -1;
  }

  const handBeforePlay = [...playerHand, playedTile];

  if (roundHistory) {
    roundHistory.push({
      player: currentActivePlayerTurn,
      playedTile: {...playedTile},
      end: end,
      boardBefore: gameState.prevBoard,
      handBeforePlay: handBeforePlay.map(t => ({...t}))
    });
  }

  const tableDiv = document.getElementById('table');
  const tableRect = tableDiv.getBoundingClientRect();

  let x, y, isHorizontal, displayTop, displayBottom, displayLeft, displayRight;

  const isFirst = board.tiles.length === 0;
  let e, turnDir;
  let isLeftChain = end === 'left';
  turnDir = isLeftChain ? 'up' : 'down';

  if (isFirst) {
    const isFirstDouble = isDouble(playedTile);
    if (isFirstDouble) {
      isHorizontal = false;
      x = tableRect.width / 2 - V_W / 2;
      y = tableRect.height / 2 - V_H / 2;
      displayTop = playedTile.top;
      displayBottom = playedTile.bottom;
      const centerX = x + V_W / 2;
      const topY = y + OFFSET;
      const bottomY = y + V_H - OFFSET;
      board.leftEnd = { value: playedTile.top, x: centerX, y: topY, dir: 'left', openSide: 'up' };
      board.rightEnd = { value: playedTile.bottom, x: centerX, y: bottomY, dir: 'right', openSide: 'down' };
    } else {
      x = tableRect.width / 2 - H_W / 2;
      y = tableRect.height / 2 - H_H / 2;
      isHorizontal = true;
      displayTop = playedTile.bottom;
      displayBottom = playedTile.top;
      displayLeft = playedTile.top;
      displayRight = playedTile.bottom;
      board.leftEnd = { value: playedTile.top, x: x + OFFSET, y: y + OFFSET, dir: 'left', openSide: 'left' };
      board.rightEnd = { value: playedTile.bottom, x: x + FULL - OFFSET, y: y + OFFSET, dir: 'right', openSide: 'right' };
    }
  } else {
    e = (end === 'left') ? board.leftEnd : board.rightEnd;
    const placement = calculatePlacement(board, end, tableRect, playedTile);
    x = placement.x;
    y = placement.y;
    isHorizontal = placement.isHorizontal;
    e.x = placement.nextEndX;
    e.y = placement.nextEndY;
    e.isVertical = placement.isVertical;

    const oldValue = e.value;
    let connectingValue, newEndValue;
    if (tile.top === oldValue) {
      connectingValue = tile.top;
      newEndValue = tile.bottom;
    } else {
      connectingValue = tile.bottom;
      newEndValue = tile.top;
    }
    e.value = newEndValue;

    if (isHorizontal) {
      if (e.dir === 'left') {
        displayTop = connectingValue;
        displayBottom = newEndValue;
      } else {
        displayTop = newEndValue;
        displayBottom = connectingValue;
      }
    } else {
      if (turnDir === 'up') {
        displayTop = newEndValue;
        displayBottom = connectingValue;
      } else {
        displayTop = connectingValue;
        displayBottom = newEndValue;
      }
    }

    if (placement.newHdir) {
      e.dir = placement.newHdir;
      e.openSide = placement.turnDir;
    } else {
      e.openSide = e.dir;
    }
  }

  let tileData;
  if (isHorizontal) {
    displayLeft = displayBottom;
    displayRight = displayTop;
    tileData = { left: displayLeft, right: displayRight };
  } else {
    tileData = { top: displayTop, bottom: displayBottom };
  }
  
  // Only create DOM elements if NOT in training mode
  if (!window.trainingMode) {
    const tileDiv = document.createElement('div');
    tileDiv.className = 'table-tile';
    if (isHorizontal) tileDiv.classList.add('horizontal');
    tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
    tileDiv.style.left = `${x + board.offsetX}px`;
    tileDiv.style.top = `${y + board.offsetY}px`;
    tableDiv.appendChild(tileDiv);
  }
  
  board.tiles.push({ tile: { top: displayTop, bottom: displayBottom }, x, y, isHorizontal });

  const pushedIndex = board.tiles.length - 1;
  if (board.tiles.length === 1) {
    board.leftEnd.tileIndex = pushedIndex;
    board.rightEnd.tileIndex = pushedIndex;
  } else {
    if (end === 'left') {
      board.leftEnd.tileIndex = pushedIndex;
    } else {
      board.rightEnd.tileIndex = pushedIndex;
    }
  }

  playSound();
  lastValidPlayer = currentActivePlayerTurn;

  if (playerHand.length === 0) {
    handleNormalGameWin(gameState);
    return true;
  }

  const currentIndex = playerOrder.indexOf(currentActivePlayerTurn);
  let firstSkipped = -1;
  let checkedPlayers = 0;
  let nextIndex = (currentIndex + 1) % playerOrder.length;
  let nextPlayer = playerOrder[nextIndex];

  drawUntilMatch(gameState, nextPlayer);
  if (!players[nextPlayer].some(t => canPlayTile(t, board))) {
    firstSkipped = nextPlayer;
    checkedPlayers = 1;
    nextIndex = (nextIndex + 1) % playerOrder.length;
    nextPlayer = playerOrder[nextIndex];
    drawUntilMatch(gameState, nextPlayer);
    while (checkedPlayers < playerOrder.length && !players[nextPlayer].some(t => canPlayTile(t, board))) {
      checkedPlayers++;
      nextIndex = (nextIndex + 1) % playerOrder.length;
      nextPlayer = playerOrder[nextIndex];
      drawUntilMatch(gameState, nextPlayer);
    }
  }

  if (checkedPlayers === playerOrder.length) {
    handleBlockedGame(gameState, lastValidPlayer, firstSkipped, playedTile, end);
    return true;
  }

  currentActivePlayerTurn = nextPlayer;
  
  // Only render if NOT in training mode
  if (!window.trainingMode) {
    renderGame(gameState);
  }

  if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
    if (!window.trainingMode) {
      setTimeout(() => playAI(gameState), 1500);
    } else {
      // In training mode, play immediately without delay
      playAI(gameState);
    }
  }
  return true;
}
 ///   
	function getPreviousPlayer(p, playerOrder) {
      const idx = playerOrder.indexOf(p);
      return playerOrder[(idx - 1 + playerOrder.length) % playerOrder.length];
    }

function updateScoresForWin(winner, gameState) {
  // Skip score updates during training
  if (window.trainingMode) return;
  
  let values = computePlayerValues(gameState.players);
  let pot = 0;
  const { playerOrder } = gameState;
  for (let i of playerOrder) {
    if (i !== winner) {
      let pay = values[i] * bet;
      pot += pay;
      scores[i] -= pay;
    }
  }
  scores[winner] += pot;
  nextGameStarter = winner;
  
  let message = `Player ${getPlayerNumber(winner)} wins ${abbreviate(pot)}\n\n`;
  for (let i of playerOrder) {
    if (i !== winner) {
      let pay = values[i] * bet;
      message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
    }
  }
  setTimeout(() => safeAlert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}
function updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState) {
  // Skip score updates during training
  if (window.trainingMode) return;
  
  let values = computePlayerValues(gameState.players);
  let minAll = Math.min(...gameState.playerOrder.map(p => values[p]));
  let blockerValue = values[blocker];
  let othersTotal = gameState.playerOrder.reduce((sum, p) => p === blocker ? sum : sum + values[p], 0);
  let payAmount = 2 * othersTotal * bet;
  let message;
  
  if (blockerValue <= minAll) {
    scores[assistant] -= payAmount;
    scores[blocker] += payAmount;
    message = `Player ${getPlayerNumber(blocker)} wins block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
    message += `Player ${getPlayerNumber(assistant)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(blocker)}`;
  } else {
    scores[blocker] -= payAmount;
    scores[assistant] += payAmount;
    message = `Player ${getPlayerNumber(blocker)} loses block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
    message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(assistant)}`;
  }
  nextGameStarter = blocker;
  setTimeout(() => safeAlert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}
// Updated updateScoresForIntentionalBlockNoAssist (add localStorage save)
function updateScoresForIntentionalBlockNoAssist(blocker, gameState) {
  // Skip score updates during training
  if (window.trainingMode) return;
  
  let values = computePlayerValues(gameState.players);
  let blockerValue = values[blocker];
  let othersValues = gameState.playerOrder.filter(p => p !== blocker).map(p => values[p]);
  let minOthers = Math.min(...othersValues);
  let totalTransfer = othersValues.reduce((a, b) => a + b, 0) * 2 * bet;
  let message;
  
  if (blockerValue <= minOthers) {
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[i] -= pay;
        scores[blocker] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} wins block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} receives ${abbreviate(totalTransfer)}\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
      }
    }
  } else {
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        scores[blocker] -= pay;
        scores[i] += pay;
      }
    }
    message = `Player ${getPlayerNumber(blocker)} loses block!\n\n`;
    message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(totalTransfer)} total\n\n`;
    for (let i of gameState.playerOrder) {
      if (i !== blocker) {
        let pay = 2 * values[i] * bet;
        message += `Player ${getPlayerNumber(i)} receives ${abbreviate(pay)}\n`;
      }
    }
  }
  
  nextGameStarter = blocker;
  setTimeout(() => safeAlert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}

function handleNormalGameWin(gameState) {
  gameState.gameOver = true;
  updateScoresForWin(currentActivePlayerTurn, gameState);
  
  // Only render and show button if NOT in training mode
  if (!window.trainingMode) {
    renderGame(gameState);
    showNewGameButton();
  }
}
	
function hadAlternativeThatAvoidsBlock(playerIndex, boardBefore, handBefore, playersState, boneyard, playerOrder) {

  // Get all valid moves for this player at that board state
  const validMoves = getValidMoves(handBefore, boardBefore);
  
  if (validMoves.length <= 1) {
    // No alternatives (0 or 1 move only)
    return false;
  }

  // Check each alternative move
  for (const move of validMoves) {
    // Simulate playing this tile
    const simBoard = simulatePlay(boardBefore, move.tile, move.end);
    const simPlayers = JSON.parse(JSON.stringify(playersState));
    
    // Remove the played tile from simulated hand
    const tileIdx = simPlayers[playerIndex].findIndex(t => 
      t.top === move.tile.top && t.bottom === move.tile.bottom
    );
    simPlayers[playerIndex].splice(tileIdx, 1);

    // Check if this move leads to a playable state (not force block)
    if (isPlayableForAnyone(simPlayers, boneyard, simBoard, playerOrder)) {
      // Found an alternative that avoids force block
      return true;
    }
  }

  // All alternatives also lead to force block
  return false;
}

///new
function handleBlockedGame(gameState, lastValidPlayer, firstSkipped, lastPlayedTile, lastPlayedEnd) {
  gameState.gameOver = true;
  const { players, board, roundHistory, playerOrder, boneyard } = gameState;

  const prevBoard = gameState.prevBoard;
  if (!prevBoard) {
    updateScoresForForceBlock(gameState);
    if (!window.trainingMode) {
      renderGame(gameState);
      showNewGameButton();
    }
    return;
  }

  const lastMove = roundHistory[roundHistory.length - 1];
  const lastPlayerHandBefore = lastMove.handBeforePlay;
  const playersAtLast = JSON.parse(JSON.stringify(players));
  playersAtLast[lastValidPlayer].push({...lastPlayedTile});

  const lastHadAvoidingAlt = hadAlternativeThatAvoidsBlock(
    lastValidPlayer,
    prevBoard,
    lastPlayerHandBefore,
    playersAtLast,
    boneyard,
    playerOrder
  );

  if (lastHadAvoidingAlt) {
    const blockerIndex = playerOrder.indexOf(lastValidPlayer);
    const directBeforeIndex = (blockerIndex - 1 + playerOrder.length) % playerOrder.length;
    const directBeforePlayer = playerOrder[directBeforeIndex];
    
    let directAssistant = -1;
    
    for (let i = roundHistory.length - 2; i >= 0; i--) {
      const move = roundHistory[i];
      
      if (move.player === directBeforePlayer) {
        const handBefore = move.handBeforePlay;
        const playersAtMove = JSON.parse(JSON.stringify(players));
        
        for (let j = i; j < roundHistory.length; j++) {
          playersAtMove[roundHistory[j].player].push({...roundHistory[j].playedTile});
        }
        
        const boardBefore = move.boardBefore;
        if (boardBefore && boardBefore.leftEnd) {
          const hadAlt = hadAlternativeThatAvoidsBlock(
            directBeforePlayer,
            boardBefore,
            handBefore,
            playersAtMove,
            boneyard,
            playerOrder
          );
          
          if (hadAlt) {
            directAssistant = directBeforePlayer;
          }
        }
        break;
      }
    }
    
    if (directAssistant !== -1) {
      updateScoresForIntentionalBlockWithAssist(lastValidPlayer, directAssistant, gameState);
      if (!window.trainingMode) {
        renderGame(gameState);
        showNewGameButton();
      }
      return;
    }
    
    updateScoresForIntentionalBlockNoAssist(lastValidPlayer, gameState);
    if (!window.trainingMode) {
      renderGame(gameState);
      showNewGameButton();
    }
    return;
  }

  let remoteBlocker = -1;
  
  for (let i = roundHistory.length - 2; i >= 0; i--) {
    const move = roundHistory[i];
    const player = move.player;

    if (!playerOrder.includes(player)) {
      continue;
    }

    const handBefore = move.handBeforePlay;
    const playersAtMove = JSON.parse(JSON.stringify(players));
    
    for (let j = i; j < roundHistory.length; j++) {
      playersAtMove[roundHistory[j].player].push({...roundHistory[j].playedTile});
    }

    const boardBefore = move.boardBefore;
    
    if (!boardBefore || !boardBefore.leftEnd) {
      continue;
    }

    const hadAlt = hadAlternativeThatAvoidsBlock(
      player,
      boardBefore,
      handBefore,
      playersAtMove,
      boneyard,
      playerOrder
    );

    if (hadAlt) {
      remoteBlocker = player;
      break;
    }
  }

  if (remoteBlocker !== -1) {
    updateScoresForIntentionalBlockNoAssist(remoteBlocker, gameState);
    if (!window.trainingMode) {
      renderGame(gameState);
      showNewGameButton();
    }
    return;
  }

  updateScoresForForceBlock(gameState);
  if (!window.trainingMode) {
    renderGame(gameState);
    showNewGameButton();
  }
}
///

function updateScoresForForceBlock(gameState) {
  // Skip score updates during training
  if (window.trainingMode) return;
  
  let values = computePlayerValues(gameState.players);
  let minVal = Math.min(...gameState.playerOrder.map(p => values[p]));
  let winners = [];
  let losers = [];
  
  for (let i of gameState.playerOrder) {
    if (values[i] === minVal) {
      winners.push(i);
    } else {
      losers.push(i);
    }
  }

  let message;
  if (winners.length === gameState.playerOrder.length) {
    message = `Force block! All players tie.\n\nNo payout.\nPlayer ${getPlayerNumber(nextGameStarter)} starts next game.`;
    nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
  } else {
    let total_pot = 0;
    losers.forEach(l => {
      let pay = values[l] * bet;
      scores[l] -= pay;
      total_pot += pay;
    });
    let share = total_pot / winners.length;
    winners.forEach(w => {
      scores[w] += share;
    });
    
    if (winners.length === 1) {
      nextGameStarter = winners[0];
      message = `Force block! Player ${getPlayerNumber(nextGameStarter)} has lowest hand.\n\n`;
      message += `Player ${getPlayerNumber(nextGameStarter)} wins ${abbreviate(total_pot)}\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    } else {
      nextGameStarter = gameState.playerOrder[(gameState.playerOrder.indexOf(lastValidPlayer) + 1) % gameState.playerOrder.length];
      message = `Force block! Tie between: ${winners.map(w => `Player ${getPlayerNumber(w)}`).join(', ')}\n\n`;
      message += `Winners share ${abbreviate(total_pot)} (${abbreviate(share)} each)\n\n`;
      losers.forEach(l => {
        let pay = values[l] * bet;
        message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
      });
    }
  }
  
  setTimeout(() => safeAlert(message), 100);
  
  // Persist scores
  localStorage.setItem('dominoScores', JSON.stringify(scores));
}
///
function showNewGameButton() {
  // Skip UI updates during training
  if (window.trainingMode) return;
  
  const newGameBtn = document.getElementById('new-game');
  newGameBtn.style.display = 'block';
  newGameBtn.onclick = () => {
    initAudioContext();
    newGameBtn.style.display = 'none';
    gameState = setupGame();
    renderGame(gameState);
    if (!gameState.gameOver && currentActivePlayerTurn !== 0) {
      setTimeout(() => playAI(gameState), 1500);
    }
  };
}
///

// UPDATED renderGame function - use currentActivePlayerTurn
function renderGame(gameState) {
  // CRITICAL: Block ALL rendering during training
  if (window.trainingMode) return;
  
  requestAnimationFrame(() => {
    const {players, board, gameOver, selectedIndex, isThisFirstGame} = gameState;
    const tableDiv = document.getElementById('table');

    tableDiv.innerHTML = '';
    board.tiles.forEach(({tile, x, y, isHorizontal}, index) => {
      const tileDiv = document.createElement('div');
      tileDiv.className = 'table-tile';
      if (isHorizontal) tileDiv.classList.add('horizontal');
      if (board.tiles.length === 1 && index === 0 && isDouble(tile)) {
        tileDiv.classList.add('first-double');
      }

      if (!gameOver) {
        let isLeftEnd = index === (board.leftEnd ? board.leftEnd.tileIndex : -1);
        let isRightEnd = index === (board.rightEnd ? board.rightEnd.tileIndex : -1);
        let isDoubleEnd = isDouble(tile);
        if (isLeftEnd) {
          const openSide = board.leftEnd.openSide;
          if (isHorizontal) {
            if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
            else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
          } else {
            if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
            else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
          }
        }
        if (isRightEnd) {
          const openSide = board.rightEnd.openSide;
          if (isHorizontal) {
            if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
            else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
          } else {
            if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
            else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
          }
        }
      }

      let tileData;
      if (isHorizontal) {
        tileData = { left: tile.bottom, right: tile.top };
      } else {
        tileData = tile;
      }
      tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
      tileDiv.style.left = `${x + board.offsetX}px`;
      tileDiv.style.top = `${y + board.offsetY}px`;
      tableDiv.appendChild(tileDiv);
    });

    let leftPlaceholder = null;
    let rightPlaceholder = null;

    if (!gameOver && currentActivePlayerTurn === 0 && board.tiles.length > 0) {
      const dummyTile = {top: 0, bottom: 0};
      const tableRect = tableDiv.getBoundingClientRect();
      const hand = players[0];

      let tileToCheck = null;
      if (draggedTile) {
        tileToCheck = draggedTile;
      } else if (selectedIndex !== -1) {
        tileToCheck = hand[selectedIndex];
      }

      const shouldShowLeft = tileToCheck
        ? canPlayOnEnd(tileToCheck, board.leftEnd.value)
        : hand.some(tile => canPlayOnEnd(tile, board.leftEnd.value));

      const shouldShowRight = tileToCheck
        ? canPlayOnEnd(tileToCheck, board.rightEnd.value)
        : hand.some(tile => canPlayOnEnd(tile, board.rightEnd.value));

      if (shouldShowLeft) {
        const leftPlacement = calculatePlacement(board, 'left', tableRect, dummyTile);
        leftPlaceholder = document.createElement('div');
        leftPlaceholder.className = 'table-tile placeholder';
        if (leftPlacement.isHorizontal) leftPlaceholder.classList.add('horizontal');
        leftPlaceholder.style.left = `${leftPlacement.x + board.offsetX}px`;
        leftPlaceholder.style.top = `${leftPlacement.y + board.offsetY}px`;
        leftPlaceholder.style.border = '2px dashed #6a6a6a';
        tableDiv.appendChild(leftPlaceholder);

        leftPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.leftEnd.value)) leftPlaceholder.style.border = '2px dashed yellow'; };
        leftPlaceholder.ondragleave = () => { leftPlaceholder.style.border = '2px dashed #6a6a6a'; };
        leftPlaceholder.ondrop = (e) => { e.preventDefault(); leftPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.leftEnd.value)) playTile(gameState, tileData, 'left'); } catch (err) {} };
        leftPlaceholder.onclick = (e) => { e.stopPropagation(); if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.leftEnd.value)) playTile(gameState, selectedTile, 'left'); } };
      }

      if (shouldShowRight) {
        const rightPlacement = calculatePlacement(board, 'right', tableRect, dummyTile);
        rightPlaceholder = document.createElement('div');
        rightPlaceholder.className = 'table-tile placeholder';
        if (rightPlacement.isHorizontal) rightPlaceholder.classList.add('horizontal');
        rightPlaceholder.style.left = `${rightPlacement.x + board.offsetX}px`;
        rightPlaceholder.style.top = `${rightPlacement.y + board.offsetY}px`;
        rightPlaceholder.style.border = '2px dashed #6a6a6a';
        tableDiv.appendChild(rightPlaceholder);

        rightPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.rightEnd.value)) rightPlaceholder.style.border = '2px dashed yellow'; };
        rightPlaceholder.ondragleave = () => { rightPlaceholder.style.border = '2px dashed #6a6a6a'; };
        rightPlaceholder.ondrop = (e) => { e.preventDefault(); rightPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.rightEnd.value)) playTile(gameState, tileData, 'right'); } catch (err) {} };
        rightPlaceholder.onclick = (e) => { e.stopPropagation(); if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.rightEnd.value)) playTile(gameState, selectedTile, 'right'); } };
      }
    }

if (!gameOver && currentActivePlayerTurn === 0) {
  if (board.tiles.length === 0) {
    tableDiv.ondragover = (e) => e.preventDefault();
    tableDiv.ondrop = (e) => { e.preventDefault(); try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); playTile(gameState, tileData, 'right'); } catch (err) {} };
    tableDiv.onclick = (e) => { 
      // Only play if clicking directly on table (not a placeholder)
      if (e.target === tableDiv && gameState.selectedIndex !== -1) { 
        const selectedTile = players[0][gameState.selectedIndex]; 
        playTile(gameState, selectedTile, 'right'); 
      } 
    };
  } else {
    // Remove general table click handler when board has tiles
    tableDiv.onclick = null;
  }
}

    document.querySelectorAll('.player-hand').forEach((hand, index) => {
      if (!gameState.playerOrder.includes(index)) {
        hand.style.display = 'none';
        return;
      }
      hand.style.display = 'flex';
      hand.innerHTML = '';
      const scoreDiv = document.createElement('div');
      scoreDiv.className = 'score';
      const scoreValue = scores[index];
      const scoreText = scoreValue < 0 ? '-$' + Math.abs(scoreValue) : '$' + scoreValue;
      const scoreLength = scoreText.length;
      const numCoins = Math.max(3, Math.ceil(scoreLength / 2));
      const coinsHtml = '<span class="coin">ü™ô</span>'.repeat(numCoins);
      let coinColorClass = 'yellow';
      if (scoreValue >= 1000000000) {
        coinColorClass = 'red';
      } else if (scoreValue >=500000000) {
        coinColorClass = 'orange';
      } else if (scoreValue >= 100000000) {
        coinColorClass = 'violet';
      } else if (scoreValue <= -1) {
        coinColorClass = 'silver';
      }
      scoreDiv.innerHTML = `<span class="score-arrow">${!gameOver && index === currentActivePlayerTurn ? '‚û§' : ''}</span><span class="score-text">[P${getPlayerNumber(index)}]</span><div class="score-number"><div class="coins-container ${coinColorClass}">${coinsHtml}</div><span class="score-text" style="position: absolute; top: 50%; left: 50%;top: -1px; transform: translate(calc(-50% - 10px), calc(-50% + 3px)); z-index: 2; color: black;">${scoreText}</span></div>`;

      const tilesContainer = document.createElement('div');
      tilesContainer.className = 'tiles-container';
      let playButtons;

      let highestDoubleInHand = null;
      if (!gameOver && index === 0 && board.tiles.length === 0 && isThisFirstGame) {
        if (gameState.highestDouble) {
          highestDoubleInHand = gameState.highestDouble;
        }
      }

      const rootStyle = getComputedStyle(document.documentElement);
      const tileWidth = parseFloat(rootStyle.getPropertyValue('--tile-width'));
      const tileHeight = parseFloat(rootStyle.getPropertyValue('--tile-height'));
      const tileGap = parseFloat(rootStyle.getPropertyValue('--tile-gap'));

      const numTiles = players[index].length;
      let containerWidth = window.innerWidth - 20;
      let containerHeight = window.innerHeight - 20;
      let overlapStyle = '';

      if (index === 0 || index === 2) {
        const totalWidth = numTiles * tileWidth + (numTiles - 1) * tileGap;
        if (totalWidth > containerWidth) {
          tilesContainer.classList.add('overlapped', 'horizontal');
          const overlap = (totalWidth - containerWidth) / (numTiles - 1);
          overlapStyle = `margin-left: -${overlap.toFixed(2)}px;`;
        }
      } else {
        const totalHeight = numTiles * tileHeight + (numTiles - 1) * tileGap;
        if (totalHeight > containerHeight) {
          tilesContainer.classList.add('overlapped', 'vertical');
          const overlap = (totalHeight - containerHeight) / (numTiles - 1);
          overlapStyle = `margin-top: -${overlap.toFixed(2)}px;`;
        }
      }

      if (overlapStyle) {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
          .player-hand[data-player="${index}"] .tiles-container.overlapped > .tile:not(:first-child) {
            ${overlapStyle}
          }
        `;
        hand.appendChild(styleElement);
      }

      if (!gameOver && index === 0) {
        playButtons = document.createElement('div');
        playButtons.className = 'play-buttons';
        playButtons.innerHTML = `<button class="play-left">Play </button><button class="play-right">Play </button>`;
        playButtons.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
      }

      players[index].forEach((tile, tileIdx) => {
        const tileDiv = document.createElement('div');
        tileDiv.className = 'tile';
        
        if (!gameOver && index !== 0 && tileMode === 'Close') {
          tileDiv.innerHTML = generateBackTileSvg(false);
        } else {
          tileDiv.innerHTML = generateTileSvg(false, tile);
          tileDiv.dataset.top = tile.top;
          tileDiv.dataset.bottom = tile.bottom;

          if (!gameOver && index === 0) {
            tileDiv.style.cursor = 'pointer';
            
            tileDiv.onclick = (e) => {
              initAudioContext();
              if (!soundLocked) canPlaySound = true;
              e.stopPropagation();
              if (tileDiv.dataset.justMoved === 'true') {
                delete tileDiv.dataset.justMoved;
                return;
              }
              handleTileClick(gameState, tileIdx, playButtons);
            };
            
            if (selectedIndex === tileIdx) tileDiv.classList.add('selected');

            let isPlayable = false;
            if (board.tiles.length === 0) {
              if (isThisFirstGame) {
                if (gameState.highestDouble && (tile.top === gameState.highestDouble.top && tile.bottom === gameState.highestDouble.bottom)) {
                  isPlayable = true;
                }
              } else {
                isPlayable = true;
              }
            } else {
              isPlayable = canPlayTile(tile, board);
            }

            if (isPlayable && currentActivePlayerTurn === 0) {
              tileDiv.classList.add('draggable');
              tileDiv.draggable = true;

              tileDiv.ondragstart = (e) => {
                initAudioContext();
                if (!soundLocked) canPlaySound = true;
                draggedTile = tile;
                gameState.selectedIndex = -1;
                e.dataTransfer.setData('text/plain', JSON.stringify(tile));
              };

              tileDiv.addEventListener('touchstart', (e) => {
                initAudioContext();
                if (!soundLocked) canPlaySound = true;
                draggedTile = tile;
                gameState.selectedIndex = -1;

                const touch = e.touches[0];
                const ghost = tileDiv.cloneNode(true);
                ghost.style.position = 'fixed';
                ghost.style.pointerEvents = 'none';
                ghost.style.zIndex = 1000;
                document.body.appendChild(ghost);
                ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
                ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;
                let moved = false;
                
                const onTouchMove = (ev) => {
                  ev.preventDefault();
                  if (ev.touches.length === 1) {
                    moved = true;
                    const t = ev.touches[0];
                    ghost.style.left = `${t.clientX - ghost.offsetWidth / 2}px`;
                    ghost.style.top = `${t.clientY - ghost.offsetHeight / 2}px`;
                    if (board.tiles.length > 0) {
                      if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                      if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                      const dropX = t.clientX;
                      const dropY = t.clientY;
                      if (leftPlaceholder && canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                        const leftRect = leftPlaceholder.getBoundingClientRect();
                        if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                          leftPlaceholder.style.border = '2px dashed yellow';
                        }
                      }
                      if (rightPlaceholder && canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                        const rightRect = rightPlaceholder.getBoundingClientRect();
                        if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                          rightPlaceholder.style.border = '2px dashed yellow';
                        }
                      }
                    }
                  }
                };
                
                const onTouchEnd = (ev) => {
                  document.removeEventListener('touchmove', onTouchMove);
                  document.removeEventListener('touchend', onTouchEnd);
                  ghost.remove();
                  if (board.tiles.length > 0) {
                    if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                    if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                  }
                  if (!moved) {
                    draggedTile = null;
                    return;
                  }
                  if (moved) {
                    tileDiv.dataset.justMoved = 'true';
                  }
                  const dropTouch = ev.changedTouches[0] || {clientX: 0, clientY: 0};
                  let dropped = false;
                  const dropX = dropTouch.clientX;
                  const dropY = dropTouch.clientY;
                  if (board.tiles.length === 0) {
                    const tableRect = tableDiv.getBoundingClientRect();
                    if (dropX > tableRect.left && dropX < tableRect.right && dropY > tableRect.top && dropY < tableRect.bottom) {
                      playTile(gameState, draggedTile, 'right');
                      dropped = true;
                    }
                  } else {
                    if (leftPlaceholder) {
                      const leftRect = leftPlaceholder.getBoundingClientRect();
                      if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                        if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                          playTile(gameState, draggedTile, 'left');
                          dropped = true;
                        }
                      }
                    }
                    if (rightPlaceholder) {
                      const rightRect = rightPlaceholder.getBoundingClientRect();
                      if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                        if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                          playTile(gameState, draggedTile, 'right');
                          dropped = true;
                        }
                      }
                    }
                  }
                  draggedTile = null;
                };
                
                document.addEventListener('touchmove', onTouchMove, {passive: false});
                document.addEventListener('touchend', onTouchEnd, {passive: false});
              }, { passive: true });
            }
          }
        }
        tilesContainer.appendChild(tileDiv);
      });

      if (index === 2) { 
        hand.appendChild(scoreDiv); 
        hand.appendChild(tilesContainer); 
      } else {
        hand.appendChild(tilesContainer);
        hand.appendChild(scoreDiv);
      }

      if (playButtons) {
        hand.appendChild(playButtons);
        if (currentActivePlayerTurn === 0 && selectedIndex !== -1) {
          const selectedTileData = players[0][selectedIndex];
          const leftBtn = playButtons.querySelector('.play-left');
          const rightBtn = playButtons.querySelector('.play-right');
          leftBtn.style.display = 'none';
          rightBtn.style.display = 'none';

          if (board.tiles.length === 0) {
            if (isThisFirstGame) {
              if (gameState.highestDouble && (selectedTileData.top === gameState.highestDouble.top && selectedTileData.bottom === gameState.highestDouble.bottom)) {
                rightBtn.style.display = 'inline-block';
                rightBtn.textContent = `Play First`;
                rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
              }
            } else {
              rightBtn.style.display = 'inline-block';
              rightBtn.textContent = `Play First`;
              rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
            }
          } else {
            const leftEnd = board.leftEnd.value;
            const rightEnd = board.rightEnd.value;
            if (canPlayOnEnd(selectedTileData, leftEnd)) {
              leftBtn.style.display = 'inline-block';
              leftBtn.textContent = `Play Left ${leftEnd}`;
              leftBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'left'); };
            }
            if (canPlayOnEnd(selectedTileData, rightEnd)) {
              rightBtn.style.display = 'inline-block';
              rightBtn.textContent = `Play Right ${rightEnd}`;
              rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
            }
          }
        }
      }
    });

    const boneyardDiv = document.getElementById('boneyard');
    if (gameState.boneyard && gameState.boneyard.length > 0 && gameState.playerOrder.length < 4) {
      boneyardDiv.style.display = 'block';
      const tilesDiv = document.getElementById('boneyard-tiles');
      tilesDiv.innerHTML = '';
      for (let i = 0; i < gameState.boneyard.length; i++) {
        const rect = document.createElement('div');
        rect.style.width = '6px';
        rect.style.height = '12px';
        rect.style.background = 'black';
        rect.style.border = '1px solid #222';
        rect.style.borderRadius = '2px';
        tilesDiv.appendChild(rect);
      }
    } else {
      boneyardDiv.style.display = 'none';
    }
  }); 
}
 /// 
    function centerTilesOnResize() {
      if (!gameState || !gameState.board) return;
      const table = document.getElementById('table');
      const tiles = table.querySelectorAll('.table-tile');
      if (!tiles.length) return;

      const tableRect = table.getBoundingClientRect();
      const centerX = tableRect.width / 2;
      const centerY = tableRect.height / 2;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      tiles.forEach(tile => {
        const rect = tile.getBoundingClientRect();
        const tableBox = table.getBoundingClientRect();
        const left = rect.left - tableBox.left;
        const top = rect.top - tableBox.top;
        minX = Math.min(minX, left);
        minY = Math.min(minY, top);
        maxX = Math.max(maxX, left + rect.width);
        maxY = Math.max(maxY, top + rect.height);
      });

      const tilesCenterX = (minX + maxX) / 2;
      const tilesCenterY = (minY + maxY) / 2;

      const offsetX = centerX - tilesCenterX;
      const offsetY = centerY - tilesCenterY;

      tiles.forEach(tile => {
        const left = parseFloat(tile.style.left || 0);
        const top = parseFloat(tile.style.top || 0);
        tile.style.left = `${left + offsetX}px`;
        tile.style.top = `${top + offsetY}px`;
      });
    }

    window.addEventListener('resize', centerTilesOnResize);

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(() => console.log('‚úÖ Service worker registered'))
        .catch(err => console.error('SW registration failed:', err));
    }

startGameBtn.addEventListener('click', async () => {
  const selectedMode = selectedPlayers;
  
  numPlayersVar = selectedMode;
  document.getElementById('numPlayers').value = numPlayersVar;
  modal.classList.add('hidden');
  
  // Train AI if needed for this mode
  await trainAIForMode(selectedMode);
  
  // Start game
  initAudioContext();
  startNewGame();
});
 </script>
<!-- === AI Loader Script (Safe + Fixed Version) === -->
<script>
const LOCAL_Q_KEY        = "Domino_AI_Q";
const LOCAL_BASE_KEY     = "Domino_AI_Base";
const LOCAL_VERSION_KEY  = "Domino_AI_VERSION";

// --- Optional remote source (safe check) ---
let AI_REMOTE_URL = "https://azn1viet.github.io/domino/4K2P3P4P_v2.json";
if (typeof AI_REMOTE_URL === "undefined" || !AI_REMOTE_URL) {
  console.warn("‚ö†Ô∏è No AI_REMOTE_URL found ‚Äî skipping AI load.");
  AI_REMOTE_URL = null;
}

// --- Mark all modes as trained ONLY if AI JSON is successfully downloaded ---
function ensureTrainedFlags(aiLoaded) {
  if (!aiLoaded || AI_REMOTE_URL === null || AI_REMOTE_URL === undefined || AI_REMOTE_URL === "") {
    console.warn("‚ö†Ô∏è Skipping trained flags ‚Äî AI data not loaded or URL is null.");
    return;
  }
}

// --- Merge helper ---
function mergeBaseAndUserData(newBase, localData) {
  const merged = { ...localData, ...newBase };
  for (const key in localData) {
    if (!newBase.hasOwnProperty(key)) merged[key] = localData[key];
  }
  return merged;
}

// --- Loader core ---
async function loadPretrainedDominoAI() {
  let aiLoaded = false;
  const localData = JSON.parse(localStorage.getItem(LOCAL_Q_KEY) || "{}");

  if (!AI_REMOTE_URL) {
    console.warn("‚ö†Ô∏è AI_REMOTE_URL is missing. Skipping AI load.");
    window.aiQTable = {};
    ensureTrainedFlags(false);
    return {};
  }

  const currentVersion = AI_REMOTE_URL.split("/").pop();
  const cachedVersion  = localStorage.getItem(LOCAL_VERSION_KEY);

  try {
    if (cachedVersion === currentVersion && Object.keys(localData).length) {
      console.log(`‚úÖ Domino AI already loaded (${currentVersion}).`);
      aiLoaded = true;
      window.aiQTable = localData;
      ensureTrainedFlags(aiLoaded);
      return localData;
    }

    console.log(`‚¨áÔ∏è Fetching Domino AI from ${currentVersion}...`);
    const res = await fetch(AI_REMOTE_URL, { cache: "no-cache" });
    if (!res.ok) throw new Error(`Fetch failed (${res.status})`);

    const newBase = await res.json();
    aiLoaded = true;

    const oldBase = JSON.parse(localStorage.getItem(LOCAL_BASE_KEY) || "{}");
    const userLearned = {};
    for (const key in localData) {
      if (!oldBase.hasOwnProperty(key)) userLearned[key] = localData[key];
    }

    const merged = { ...userLearned, ...newBase };
    localStorage.setItem(LOCAL_BASE_KEY, JSON.stringify(newBase));
    localStorage.setItem(LOCAL_Q_KEY, JSON.stringify(merged));
    localStorage.setItem(LOCAL_VERSION_KEY, currentVersion);


    window.aiQTable = merged;
    ensureTrainedFlags(aiLoaded);
    console.log(`‚úÖ AI loaded (${Object.keys(merged).length} records).`);
		
  localStorage.setItem("Domino_AI_Trained_2P", "true");
  localStorage.setItem("Domino_AI_Trained_3P", "true");
  localStorage.setItem("Domino_AI_Trained_4P", "true");

  window.Domino_AI_Trained_2P = "true";
  window.Domino_AI_Trained_3P = "true";
  window.Domino_AI_Trained_4P = "true";

  console.log("üèÅ All training flags set to true (AI JSON loaded).");
  
    return merged;

  } catch (err) {
    console.warn("‚ö†Ô∏è AI load skipped:", err.message);
    const cached = localStorage.getItem(LOCAL_Q_KEY);
    if (cached) {
      console.log("‚ÑπÔ∏è Using new local train AI data.");
      window.aiQTable = JSON.parse(cached);
      aiLoaded = true;
    } else {
      window.aiQTable = {};
    }
    ensureTrainedFlags(aiLoaded);
    return window.aiQTable;
  }
}

///
function saveDominoAILearning(updatedQ) {
  localStorage.setItem(LOCAL_Q_KEY, JSON.stringify(updatedQ));
  console.log("üß† Domino AI updated locally.");
}

// --- UI integration ---
document.addEventListener("DOMContentLoaded", async () => {
  const startBtn = document.getElementById("start-game-btn");
  const playerOptions = document.querySelectorAll(".player-option");
  let selectedPlayers = 2;

  // Show loading state
  if (startBtn) {
    startBtn.disabled = true;
    startBtn.textContent = "Loading AI trained data...";
    startBtn.style.opacity = "0.7";
  }
  playerOptions.forEach(btn => btn.disabled = true);

  try {
    await loadPretrainedDominoAI();
  } catch (e) {
    console.warn("‚ö†Ô∏è Skipping AI initialization due to error:", e);
    window.aiQTable = {};
  }

  // ‚úÖ Always restore button state (even if error or missing AI)
  if (startBtn) {
    startBtn.disabled = false;
    startBtn.textContent = "Start Game";
    startBtn.style.background = "#0f0";
    startBtn.style.opacity = "1";
  }
  playerOptions.forEach(btn => btn.disabled = false);

  playerOptions.forEach(option => {
    option.addEventListener("click", () => {
      playerOptions.forEach(btn => btn.classList.remove("selected"));
      option.classList.add("selected");
      selectedPlayers = parseInt(option.dataset.players);
    });
  });
});
</script>

</body>
</html>