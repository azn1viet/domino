<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Dominoes</title>
    <style>
        :root {
            --tile-width: 25px;
            --tile-height: 50px;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #444;
            position: fixed;
            overflow: hidden;
        }
        #game-container {
            position: absolute;
            top: 113px;
            left: 50px;
            right: 50px;
            bottom: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
#table {
    width: 80%;
    height: 50%;
    position: fixed; /* stays centered even when scrolling */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 10px;
    min-width: 320px;
    min-height: 320px;
}

        .player-hand {
            position: fixed;
            text-align: center;
            z-index: 100;
            padding: 5px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .player-south { 
            bottom: -5px; 
            left: 50%; 
            transform: translateX(-50%); 
            width: 100vw;
            justify-content: center;
            height: 150px;
        }
        .player-east { 
            top: 50%; 
            right: -30px; 
            transform: translateY(-50%);
            height: 100vh;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            min-width: 150px;
        }
        .player-east .score {
            transform: rotate(-90deg) translateY(50%);
            margin-right: -30px;
        }
        .player-north { 
            top: 5px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 100vw;
            justify-content: center;
            height: 150px;
        }
		  .player-east .score {
            transform: rotate(-90deg) translateY(50%);
            margin-left: -25px;
        }
        .player-west { 
            top: 50%; 
            left: -25px; 
            transform: translateY(-50%);
            height: 100vh;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            justify-content: center;
            min-width: 150px;
        }
        .player-west .score {
            transform: rotate(90deg) translateY(-50%);
            margin-left: -45px;
        }
        .tiles-container {
            pointer-events: auto;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 3px;
            min-height: 80px;
        }
        .player-east .tiles-container,
        .player-west .tiles-container {
            flex-direction: column;
            min-height: calc(70px * 7 + 3px * 6);
            min-width: 40px;
        }
        .tile {
            display: block;
            width: 35px;
            height: 70px;
            border: 2px solid black;
            cursor: pointer;
            border-radius: 8px;
            background-color: black;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .tile svg, .table-tile svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .selected {
            border: 3px solid yellow;
            box-shadow: 0 0 10px yellow;
        }
        .draggable {
            border: 2px dashed #6a6a6a;
        }
        .table-tile {
            position: absolute;
            width: var(--tile-width);
            height: var(--tile-height);
            border: 2px solid #666;
            border-radius: 6px;
            background-color: #1a1a1a;
            z-index: 15;
            transition: border-color 0.3s;
        }
        .table-tile.horizontal {
            width: var(--tile-height);
            height: var(--tile-width);
        }
        .table-tile.match-drop::before,
        .table-tile.match-drop::after {
            border-style: dashed !important;
        }
        .table-tile.placeholder {
            z-index: 20;
            pointer-events: auto;
            background-color: transparent;
        }
        .table-tile.end-top::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-top: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 6px 6px 0 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-bottom::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-bottom: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-left::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-left: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 6px 0 0 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.end-right::after {
            content: '';
            position: absolute;
            right: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-right: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 0 6px 6px 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-top::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-top: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 6px 6px 0 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-bottom::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: -2px;
            right: -2px;
            height: calc(50% + 2px);
            border-bottom: 2px solid #0ff;
            border-left: 2px solid #0ff;
            border-right: 2px solid #0ff;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-left::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-left: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 6px 0 0 6px;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .table-tile.double-end-right::after {
            content: '';
            position: absolute;
            right: -2px;
            top: -2px;
            bottom: -2px;
            width: calc(50% + 2px);
            border-right: 2px solid #0ff;
            border-top: 2px solid #0ff;
            border-bottom: 2px solid #0ff;
            border-radius: 0 6px 6px 0;
            box-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 16;
        }
        .tile:hover {
            border: 3px solid #0f0;
            box-shadow: 0 0 8px #0f0;
        }
        .score {
            font-size: 14px;
            font-weight: bold;
            color: #add8e6;
            margin: 3px 0;
            z-index: 101;
            text-shadow: 0 0 5px #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 100px;
            pointer-events: none;
        }
        .score-arrow {
            width: 25px;
            display: inline-block;
            text-align: center;
            color: lime;
        }
        .score-text {
            white-space: nowrap;
        }
        .score-number {
            position: relative;
            display: inline-block;
            margin-left: 30px;
        }
        .coins-container {
            position: absolute;
            z-index: 1;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 20px;
            pointer-events: none;
        }
        .coins-container .coin {
            position: absolute;
            font-size: 18px;
        }
        .coins-container .coin:nth-child(1) {
            top: 0;
            left: 0;
        }
        .coins-container .coin:nth-child(2) {
            top: 0;
            left: 10px;
        }
        .coins-container .coin:nth-child(3) {
            top: 0;
            left: 20px;
        }
        .play-buttons {
            margin-top: 5px;
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            min-height: 40px;
            pointer-events: auto;
        }
        .play-buttons button {
            padding: 8px 15px;
            background: #0f0;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            display: none;
        }
        .play-buttons button:hover {
            background: #0c0;
            transform: scale(1.05);
        }
        #new-game {
            position: fixed;
            top: 75%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
			color: #fff;
           background: rgba(255, 255, 255, 0.5);
            border: 2px solid #0f0;
            border-radius: 10px;
            cursor: pointer;
            display: none;
            z-index: 999;
            font-size: 18px;
            font-weight: bold;
        }
        #new-game:hover {
            background: #0f0;
        }
        #tileMode {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 200;
            background: #444;
            color: #add8e6;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 14px;
        }
        #bets {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 200;
            background: #444;
            color: #add8e6;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 14px;
        }
/* New: Full glow for initial double tile */
    .table-tile.first-double {
        border: 2px solid #0ff !important;
        box-shadow: 0 0 10px #0ff !important;
    }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="table"></div>
    </div>
    <button id="new-game">New Game</button>
    <div id="players">
        <div class="player-hand player-south" data-player="0"></div>
        <div class="player-hand player-east" data-player="1"></div>
        <div class="player-hand player-north" data-player="2"></div>
        <div class="player-hand player-west" data-player="3"></div>
    </div>
    <select id="tileMode">
        <option value="Close">Close tiles</option>
        <option value="Open">Open tiles</option>
    </select>
    <select id="bets">
        <option value="1000">1000</option>
        <option value="10000" selected>10000</option>
        <option value="20000">20000</option>
        <option value="50000">50000</option>
        <option value="100000">100000</option>
        <option value="500000">500000</option>
        <option value="1000000">1000000</option>
    </select>
    <div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);color:#ccc;font-size:14px;opacity:0.8;pointer-events:none;">Version 1.0.6</div>

<script>
let audioContext = null;
let canPlaySound = false;
let tileMode = 'Close';
let bet = 10000;
let isFirstGameEver = true; // Flag for the very first game
let draggedTile = null;

function abbreviate(num) {
    if (num >= 1e9) {
        return (num / 1e9).toFixed(1) + 'B';
    } else if (num >= 1e6) {
        return (num / 1e6).toFixed(1) + 'M';
    } else if (num >= 1e3) {
        return (num / 1e3).toFixed(1) + 'K';
    } else {
        return num.toString();
    }
}

function formatPayout(amount) {
    return abbreviate(Math.abs(amount)) + (amount < 0 ? ' loss' : ' gain');
}

function initAudioContext() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
}

function playSound() {
    if (!canPlaySound) return;
    initAudioContext();
    let oscillator = audioContext.createOscillator();
    let gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = 523.25;
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
}

function generateBackTileSvg(isHorizontal) {
    let svg;
    if (!isHorizontal) {
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
    } else {
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
    }
    svg += "</svg>";
    return svg;
}

const tiles = [
    {top: 6, bottom: 6}, {top: 6, bottom: 5}, {top: 6, bottom: 4}, {top: 6, bottom: 3}, {top: 6, bottom: 2}, {top: 6, bottom: 1}, {top: 6, bottom: 0},
    {top: 5, bottom: 5}, {top: 5, bottom: 4}, {top: 5, bottom: 3}, {top: 5, bottom: 2}, {top: 5, bottom: 1}, {top: 5, bottom: 0},
    {top: 4, bottom: 4}, {top: 4, bottom: 3}, {top: 4, bottom: 2}, {top: 4, bottom: 1}, {top: 4, bottom: 0},
    {top: 3, bottom: 3}, {top: 3, bottom: 2}, {top: 3, bottom: 1}, {top: 3, bottom: 0},
    {top: 2, bottom: 2}, {top: 2, bottom: 1}, {top: 2, bottom: 0},
    {top: 1, bottom: 1}, {top: 1, bottom: 0},
    {top: 0, bottom: 0}
];

const numPlayers = 4;
const numTiles = 7;
let currentPlayer = 0;
let nextGameStarter = 0;
let lastValidPlayer = 0;
let scores = [10000000, 10000000, 10000000, 10000000];

const playerOrder = [0, 1, 2, 3];

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function generateTileSvg(isHorizontal, tileData) {
    const colors = ["", "red", "gold", "white", "red", "seagreen", "white"];
    let svg;
    if (!isHorizontal) {
        // Vertical
        svg = `<svg viewBox='0 0 50 100' xmlns='http://www.w3.org/2000/svg'>`;
        const { top, bottom } = tileData;
        if (top > 0) {
            svg += `<g class='dots' fill='${colors[top]}'>`;
            const tops = {
                1: "<circle cx='25' cy='20' r='5' />",
                2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
                3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
                4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
            };
            svg += tops[top] + "</g>";
        }
        if (bottom > 0) {
            svg += `<g class='dots' fill='${colors[bottom]}'>`;
            const bottoms = {
                1: "<circle cx='25' cy='80' r='5' />",
                2: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='85' r='5' />",
                3: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='85' r='5' />",
                4: "<circle cx='15' cy='65' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
                5: "<circle cx='15' cy='65' r='5' /><circle cx='25' cy='75' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='15' cy='85' r='5' /><circle cx='35' cy='85' r='5' />",
                6: "<circle cx='15' cy='65' r='5' /><circle cx='15' cy='77' r='5' /><circle cx='15' cy='89' r='5' /><circle cx='35' cy='65' r='5' /><circle cx='35' cy='77' r='5' /><circle cx='35' cy='89' r='5' />"
            };
            svg += bottoms[bottom] + "</g>";
        }
        svg += "<line x1='0' y1='50%' x2='100%' y2='50%' stroke='#666' stroke-width='2' />";
    } else {
        // Horizontal
        svg = `<svg viewBox='0 0 100 50' xmlns='http://www.w3.org/2000/svg'>`;
        const { left, right } = tileData;
        svg += "<line x1='50%' y1='0' x2='50%' y2='100%' stroke='#666' stroke-width='2' />";
        if (left > 0) {
            svg += `<g class='dots' fill='${colors[left]}'>`;
            const leftPatterns = {
                1: "<circle cx='25' cy='20' r='5' />",
                2: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='30' r='5' />",
                3: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='30' r='5' />",
                4: "<circle cx='15' cy='10' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                5: "<circle cx='15' cy='10' r='5' /><circle cx='25' cy='20' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='15' cy='30' r='5' /><circle cx='35' cy='30' r='5' />",
                6: "<circle cx='15' cy='10' r='5' /><circle cx='15' cy='22' r='5' /><circle cx='15' cy='34' r='5' /><circle cx='35' cy='10' r='5' /><circle cx='35' cy='22' r='5' /><circle cx='35' cy='34' r='5' />"
            };
            svg += leftPatterns[left] + "</g>";
        }
        if (right > 0) {
            svg += `<g class='dots' fill='${colors[right]}'>`;
            const rightPatterns = {
                1: "<circle cx='75' cy='30' r='5' />",
                2: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='35' r='5' />",
                3: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='35' r='5' />",
                4: "<circle cx='65' cy='15' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
                5: "<circle cx='65' cy='15' r='5' /><circle cx='75' cy='25' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='65' cy='35' r='5' /><circle cx='85' cy='35' r='5' />",
                6: "<circle cx='65' cy='15' r='5' /><circle cx='65' cy='27' r='5' /><circle cx='65' cy='39' r='5' /><circle cx='85' cy='15' r='5' /><circle cx='85' cy='27' r='5' /><circle cx='85' cy='39' r='5' />"
            };
            svg += rightPatterns[right] + "</g>";
        }
    }
    svg += "</svg>";
    return svg;
}

function getTileSizes() {
    const rootStyle = getComputedStyle(document.documentElement);
    const tw = parseFloat(rootStyle.getPropertyValue('--tile-width'));
    const th = parseFloat(rootStyle.getPropertyValue('--tile-height'));
    return { V_W: tw, V_H: th, H_W: th, H_H: tw, FULL: th, OFFSET: th / 4 };
}

function setupGame() {
    const gameTiles = [...tiles];
    shuffle(gameTiles);
    let players = [];
    let boneyard = [];

    for (let i = 0; i < numPlayers; i++) {
        players[i] = gameTiles.splice(0, numTiles);
    }
    boneyard = gameTiles;
	
  const board = {
        tiles: [],
        leftEnd: null,
        rightEnd: null,
        offsetX: 0,
        offsetY: 0
    };
    
    // Determine the starting player
    if (isFirstGameEver) {
        // For the very first game, find the player with the highest double
        let starter = 0;
        let found = false;
        for (let n = 6; n >= 0 && !found; n--) {
            for (let p = 0; p < numPlayers; p++) {
                if (players[p].some(t => t.top === n && t.bottom === n)) {
                    starter = p;
                    found = true;
                    break;
                }
            }
        }
        currentPlayer = starter;
        isFirstGameEver = false; // Ensure this logic only runs once
    } else {
        // For all subsequent games, the designated starter begins
        currentPlayer = nextGameStarter;
    }

    const roundHistory = [];


    return {players, boneyard, board, prevBoard: null, gameOver: false, roundHistory, selectedIndex: -1};
}
function isDouble(tile) {
    return tile.top === tile.bottom;
}

function canPlayTile(tile, board) {
    if (!board.leftEnd) return true;
    const leftEnd = board.leftEnd.value;
    const rightEnd = board.rightEnd.value;
    return tile.top === leftEnd || tile.bottom === leftEnd || tile.top === rightEnd || tile.bottom === rightEnd;
}

function canPlayOnEnd(tile, endValue) {
    return tile.top === endValue || tile.bottom === endValue;
}

function computePlayerValues(players) {
    const values = [];
    for (let p = 0; p < numPlayers; p++) {
        let sum = 0;
        for (let tile of players[p]) {
            let pips = tile.top + tile.bottom;
            if (pips === 0) {  // double blank
                // Check if other hands have any 0-pip tile
                let otherHasZero = false;
                for (let op = 0; op < numPlayers; op++) {
                    if (op === p) continue;
                    for (let otile of players[op]) {
                        if (otile.top === 0 || otile.bottom === 0) {
                            otherHasZero = true;
                            break;
                        }
                    }
                    if (otherHasZero) break;
                }
                pips = otherHasZero ? 0 : 13;
            }
            sum += pips;
        }
        values[p] = sum;
    }
    return values;
}

// Updated simulatePlay function to handle the first move correctly
function simulatePlay(board, tile, end) {
    // If board is empty, this is the first play
    if (!board.leftEnd) {
        return {
            leftEnd: { value: tile.top },
            rightEnd: { value: tile.bottom }
        };
    }

    // Simulate the ends after playing tile on end
    let simLeftEnd = { ...board.leftEnd };
    let simRightEnd = { ...board.rightEnd };
    if (end === 'left') {
        const oldValue = simLeftEnd.value;
        if (tile.top === oldValue) {
            simLeftEnd.value = tile.bottom;
        } else {
            simLeftEnd.value = tile.top;
        }
    } else { // 'right'
        const oldValue = simRightEnd.value;
        if (tile.top === oldValue) {
            simRightEnd.value = tile.bottom;
        } else {
            simRightEnd.value = tile.top;
        }
    }
    return { leftEnd: simLeftEnd, rightEnd: simRightEnd };
}

// Helper function to check if any player can make a move on the simulated board.
function isPlayableForAnyone(players, board) {
    if (!board.leftEnd) return true; // Before first move, anyone can play.
    for (const hand of players) {
        if (hand.some(tile => canPlayTile(tile, board))) {
            return true;
        }
    }
    return false;
}

// Helper function to count known pips to gauge rarity.
function countAllPips(players, roundHistory) {
    const counts = [0, 0, 0, 0, 0, 0, 0];
    const allKnownTiles = [];
    allKnownTiles.push(...players[currentPlayer]);
    if (roundHistory) {
        for (const move of roundHistory) {
            allKnownTiles.push(move.playedTile);
        }
    }
    for (const tile of allKnownTiles) {
        counts[tile.top]++;
        counts[tile.bottom]++;
    }
    return counts;
}

function playAI(gameState) {
    const { players, board, roundHistory } = gameState;
    const playerHand = players[currentPlayer];

    // --- START: Enforce highest double on first play for AI ---
    if (!board.leftEnd) {
        const doubles = playerHand.filter(tile => isDouble(tile));
        if (doubles.length > 0) {
            // Find the highest double
            let highestDouble = doubles.reduce((max, tile) => tile.top > max.top ? tile : max, doubles[0]);
            // Play the highest double
            playTile(gameState, highestDouble, 'right');
            return; // Exit the function after playing
        }
    }
    // --- END: Enforce highest double on first play for AI ---

    let bestMove = { tile: null, end: null, score: -Infinity };

    const validMoves = [];
    if (!board.leftEnd) {
        playerHand.forEach(tile => validMoves.push({ tile, end: 'right' }));
    } else {
        playerHand.forEach(tile => {
            const canPlayLeft = canPlayOnEnd(tile, board.leftEnd.value);
            const canPlayRight = canPlayOnEnd(tile, board.rightEnd.value);
            if (canPlayLeft) {
                validMoves.push({ tile, end: 'left' });
            }
            if (canPlayRight) {
                 // Prevent adding the same move twice for a double tile that can be played on either end
                if (!isDouble(tile) || !canPlayLeft) {
                    validMoves.push({ tile, end: 'right' });
                }
            }
        });
    }

    if (validMoves.length === 0) {
        return;
    }
    
    for (const move of validMoves) {
        let score = 0;
        const { tile, end } = move;

        const simBoard = simulatePlay(board, tile, end);
        const simPlayers = JSON.parse(JSON.stringify(players));
        const tileIndex = simPlayers[currentPlayer].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
        simPlayers[currentPlayer].splice(tileIndex, 1);

        if (simPlayers[currentPlayer].length === 0) {
            score = 1000000; 
            bestMove = { tile, end, score };
            break;
        }

        const isBlock = !isPlayableForAnyone(simPlayers, simBoard);
        
        if (isBlock) {
            const simValues = computePlayerValues(simPlayers);
            const myValue = simValues[currentPlayer];
            const minValue = Math.min(...simValues);

            if (myValue <= minValue) {
                let hadNonBlockingAlternative = false;
                for (const otherMove of validMoves) {
                    if (otherMove.tile === move.tile && otherMove.end === move.end) continue;
                    const otherSimBoard = simulatePlay(board, otherMove.tile, otherMove.end);
                    const otherSimPlayers = JSON.parse(JSON.stringify(players));
                    const otherTileIndex = otherSimPlayers[currentPlayer].findIndex(t => t.top === otherMove.tile.top && t.bottom === otherMove.tile.bottom);
                    otherSimPlayers[currentPlayer].splice(otherTileIndex, 1);
                    if (isPlayableForAnyone(otherSimPlayers, otherSimBoard)) {
                        hadNonBlockingAlternative = true;
                        break;
                    }
                }
                
                if (hadNonBlockingAlternative) {
                    score += 5000;
                } else {
                    score += 2500;
                }
            } else {
                score -= 10000;
            }
        } else {
            let tileValue = tile.top + tile.bottom;
            if (isDouble(tile)) {
                tileValue += 10;
            }
            score += tileValue * 10;

            const nextPlayerIndex = (playerOrder.indexOf(currentPlayer) + 1) % numPlayers;
            const nextPlayerHand = players[playerOrder[nextPlayerIndex]];
            if (!nextPlayerHand.some(t => canPlayTile(t, simBoard))) {
                score += 200;
            }

            const pipsCount = countAllPips(players, roundHistory);
            const leftEndVal = simBoard.leftEnd.value;
            const rightEndVal = simBoard.rightEnd.value;
            score += (8 - pipsCount[leftEndVal]) * 5;
            score += (8 - pipsCount[rightEndVal]) * 5;
        }

        if (score > bestMove.score) {
            bestMove = { tile, end, score };
        }
    }

    if (bestMove.tile) {
        playTile(gameState, bestMove.tile, bestMove.end);
    } else {
         console.error("AI couldn't decide on a move. Playing first valid move.");
         if (validMoves.length > 0) {
            playTile(gameState, validMoves[0].tile, validMoves[0].end);
         }
    }
}

function calculatePlacement(board, end, tableRect, tile) {
    const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();
    const MARGIN = 0; //35; was decrease the space left and right for larger turn area, smaller screen benefit

    let e = board[end === 'left' ? 'leftEnd' : 'rightEnd'];
    let isLeftChain = end === 'left';
    let turnDir = isLeftChain ? 'up' : 'down';

    let p = {};
    let hdir = e.dir; // 'left' or 'right'
    let isDoubleTile = isDouble(tile);

    // New: For doubles, prioritize vertical
    let tryVerticalFirst = isDoubleTile;

    // Try vertical first if double
    if (tryVerticalFirst) {
        if (turnDir === 'up') {
            p.x = e.x - OFFSET;
            p.y = e.y - (FULL + OFFSET);
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + OFFSET;
        } else {
            p.x = e.x - OFFSET;
            p.y = e.y + OFFSET;
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + FULL - OFFSET;
        }

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        p.boundCheck = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                        v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (!p.boundCheck) {
            // Vertical fits, use it
            let newHdir = hdir === 'left' ? 'right' : 'left';
            p.newHdir = newHdir;
            p.turnDir = turnDir;
            return p;
        } else {
            // Vertical doesn't fit, try horizontal and turn immediately
            turnDir = isLeftChain ? 'up' : 'down'; // Force turn
        }
    }

    // Fallback/Try horizontal (or after vertical fail)
    if (hdir === 'left') {
        p.x = e.x - (FULL + OFFSET);
        p.y = e.y - OFFSET;
        p.isHorizontal = true;
        p.width = H_W;
        p.height = H_H;
        p.nextEndX = p.x + OFFSET;
        p.nextEndY = p.y + OFFSET;
    } else { // 'right'
        p.x = e.x + OFFSET;
        p.y = e.y - OFFSET;
        p.isHorizontal = true;
        p.width = H_W;
        p.height = H_H;
        p.nextEndX = p.x + FULL - OFFSET;
        p.nextEndY = p.y + OFFSET;
    }

    const eff_x = p.x + board.offsetX;
    const eff_y = p.y + board.offsetY;
    p.boundCheck = (eff_x < MARGIN || eff_x + p.width > tableRect.width - MARGIN ||
                    eff_y < MARGIN || eff_y + p.height > tableRect.height - MARGIN);

    if (!p.boundCheck) {
        return p;
    } else {
        // Turn vertical (or for double after fail)
        if (turnDir === 'up') {
            p.x = e.x - OFFSET;
            p.y = e.y - (FULL + OFFSET);
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + OFFSET;
        } else { // down
            p.x = e.x - OFFSET;
            p.y = e.y + OFFSET;
            p.isHorizontal = false;
            p.width = V_W;
            p.height = V_H;
            p.nextEndX = p.x + OFFSET;
            p.nextEndY = p.y + FULL - OFFSET;
        }

        const v_eff_x = p.x + board.offsetX;
        const v_eff_y = p.y + board.offsetY;
        let v_bound = (v_eff_x < MARGIN || v_eff_x + p.width > tableRect.width - MARGIN ||
                       v_eff_y < MARGIN || v_eff_y + p.height > tableRect.height - MARGIN);

        if (v_bound) {
            let shiftX = 0;
            let shiftY = 0;
            if (v_eff_x < MARGIN) {
                shiftX = MARGIN - v_eff_x;
            } else if (v_eff_x + p.width > tableRect.width - MARGIN) {
                shiftX = (tableRect.width - MARGIN) - (v_eff_x + p.width);
            }
            if (v_eff_y < MARGIN) {
                shiftY = MARGIN - v_eff_y;
            } else if (v_eff_y + p.height > tableRect.height - MARGIN) {
                shiftY = (tableRect.height - MARGIN) - (v_eff_y + p.height);
            }
            board.offsetX += shiftX;
            board.offsetY += shiftY;
        }

        // Reverse hdir for next
        let newHdir = hdir === 'left' ? 'right' : 'left';
        p.newHdir = newHdir;
        p.turnDir = turnDir;

        return p;
    }
}

function rotateTile(tile) {
    return { top: tile.bottom, bottom: tile.top };
}

function handleTileClick(gameState, tileIndex, playButtons) {
    const { players, selectedIndex } = gameState;
    const hand = players[0];
    const clickedTile = hand[tileIndex];

    if (selectedIndex === -1) {
        // First click: select without rotate
        gameState.selectedIndex = tileIndex;
    } else if (selectedIndex === tileIndex) {
        // Click same: rotate
        hand[tileIndex] = rotateTile(clickedTile);
    } else {
        // Click different: swap and deselect
        const selectedTile = hand[selectedIndex];
        hand[selectedIndex] = clickedTile;
        hand[tileIndex] = selectedTile;
        gameState.selectedIndex = -1;
    }

    renderGame(gameState);
}

function playTile(gameState, tile, end) {
    const { players, board, roundHistory } = gameState;
    const playerHand = players[currentPlayer];
    const tileIndex = playerHand.findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
    
    if (tileIndex === -1 || !canPlayTile(tile, board)) {
        alert("Invalid move!");
        return false;
    }

    // Check if the current player had a non-blocking alternative BEFORE the move is made.
    const boardBeforePlay = board.leftEnd ? { leftEnd: {...board.leftEnd}, rightEnd: {...board.rightEnd} } : { leftEnd: null };
    const playersCopy = JSON.parse(JSON.stringify(players));
    const hadAlternativeMove = hasNonBlockingAlternative(playersCopy[currentPlayer], boardBeforePlay, playersCopy, currentPlayer);

    const { V_W, V_H, H_W, H_H, FULL, OFFSET } = getTileSizes();

    gameState.prevBoard = board.leftEnd ? {
        leftEnd: {...board.leftEnd}, 
        rightEnd: {...board.rightEnd}
    } : null;

    const playedTile = playerHand.splice(tileIndex, 1)[0];
    
    // Reset selection if player 0 played
    if (currentPlayer === 0) {
        gameState.selectedIndex = -1;
    }
    
    // Log the move to round history with the correct flag
    if(roundHistory) {
        roundHistory.push({
            player: currentPlayer,
            playedTile: {...playedTile},
            end: end,
            boardBefore: gameState.prevBoard,
            hadAlternativeMove: hadAlternativeMove
        });
    }
    
    const tableDiv = document.getElementById('table');
    const tableRect = tableDiv.getBoundingClientRect();
    
    let x, y, isHorizontal, displayTop, displayBottom, displayLeft, displayRight;

    const isFirst = board.tiles.length === 0;
    let e, turnDir;
    let isLeftChain = end === 'left';
    turnDir = isLeftChain ? 'up' : 'down';

    if (isFirst) {
        const isFirstDouble = isDouble(playedTile);
        if (isFirstDouble) {
            // Fixed: Place first double vertically
            isHorizontal = false;
            x = tableRect.width / 2 - V_W / 2;
            y = tableRect.height / 2 - V_H / 2;
            displayTop = playedTile.top;
            displayBottom = playedTile.bottom;
            const centerX = x + V_W / 2;
            const topY = y + OFFSET;
            const bottomY = y + V_H - OFFSET;
            board.leftEnd = { value: playedTile.top, x: centerX, y: topY, dir: 'left', openSide: 'up' };
            board.rightEnd = { value: playedTile.bottom, x: centerX, y: bottomY, dir: 'right', openSide: 'down' };
        } else {
            // Original horizontal for non-double first
            x = tableRect.width / 2 - H_W / 2;
            y = tableRect.height / 2 - H_H / 2;
            isHorizontal = true;
            displayTop = playedTile.bottom;
            displayBottom = playedTile.top;
            displayLeft = playedTile.top;
            displayRight = playedTile.bottom;
            board.leftEnd = { value: playedTile.top, x: x + OFFSET, y: y + OFFSET, dir: 'left', openSide: 'left' };
            board.rightEnd = { value: playedTile.bottom, x: x + FULL - OFFSET, y: y + OFFSET, dir: 'right', openSide: 'right' };
        }
    } else {
        e = (end === 'left') ? board.leftEnd : board.rightEnd;
        const placement = calculatePlacement(board, end, tableRect, playedTile); // Pass tile for double priority
        x = placement.x;
        y = placement.y;
        isHorizontal = placement.isHorizontal;
        e.x = placement.nextEndX;
        e.y = placement.nextEndY;

        const oldValue = e.value;
        let connectingValue, newEndValue;
        if (tile.top === oldValue) {
            connectingValue = tile.top;
            newEndValue = tile.bottom;
        } else {
            connectingValue = tile.bottom;
            newEndValue = tile.top;
        }
        e.value = newEndValue;

        if (isHorizontal) {
            if (e.dir === 'left') {
                displayTop = connectingValue;
                displayBottom = newEndValue;
            } else {
                displayTop = newEndValue;
                displayBottom = connectingValue;
            }
        } else {
            // Vertical turn
            if (turnDir === 'up') {
                displayTop = newEndValue;
                displayBottom = connectingValue;
            } else {
                displayTop = connectingValue;
                displayBottom = newEndValue;
            }
        }

        if (placement.newHdir) {
            e.dir = placement.newHdir;
            e.openSide = placement.turnDir;
        } else {
            e.openSide = e.dir;
        }
    }

    let tileData;
    if (isHorizontal) {
        displayLeft = displayBottom;
        displayRight = displayTop;
        tileData = { left: displayLeft, right: displayRight };
    } else {
        tileData = { top: displayTop, bottom: displayBottom };
    }
    const tileDiv = document.createElement('div');
    tileDiv.className = 'table-tile';
    if (isHorizontal) tileDiv.classList.add('horizontal');
    tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
    tileDiv.style.left = `${x + board.offsetX}px`;
    tileDiv.style.top = `${y + board.offsetY}px`;
    
    tableDiv.appendChild(tileDiv);
    board.tiles.push({ tile: { top: displayTop, bottom: displayBottom }, x, y, isHorizontal });
    
    // Set tileIndex for the ends
    const pushedIndex = board.tiles.length - 1;
    if (board.tiles.length === 1) {
        board.leftEnd.tileIndex = pushedIndex;
        board.rightEnd.tileIndex = pushedIndex;
    } else {
        if (end === 'left') {
            board.leftEnd.tileIndex = pushedIndex;
        } else {
            board.rightEnd.tileIndex = pushedIndex;
        }
    }

    playSound();
    lastValidPlayer = currentPlayer;

    if (playerHand.length === 0) {
        handleNormalGameWin(gameState);
        return true;
    }

    const currentIndex = playerOrder.indexOf(currentPlayer);
    let firstSkipped = -1;
    let checkedPlayers = 0;
    let nextIndex = (currentIndex + 1) % numPlayers;
    let nextPlayer = playerOrder[nextIndex];

    // Check if immediate next can play
    if (!players[nextPlayer].some(t => canPlayTile(t, board))) {
        firstSkipped = nextPlayer;
        checkedPlayers = 1;
        nextIndex = (nextIndex + 1) % numPlayers;
        nextPlayer = playerOrder[nextIndex];
        // Continue skipping
        while (checkedPlayers < numPlayers && !players[nextPlayer].some(t => canPlayTile(t, board))) {
            checkedPlayers++;
            nextIndex = (nextIndex + 1) % numPlayers;
            nextPlayer = playerOrder[nextIndex];
        }
    }

    if (checkedPlayers === numPlayers) {
        // Game is blocked - determine if it was intentional
        handleBlockedGame(gameState, lastValidPlayer, firstSkipped, playedTile, end);
        return true;
    }

    currentPlayer = nextPlayer;
    renderGame(gameState);
    
    if (!gameState.gameOver && currentPlayer !== 0) {
        setTimeout(() => playAI(gameState), 1500);
    }
    return true;
}

function getPreviousPlayer(p) {
    return (p - 1 + numPlayers) % numPlayers;
}

function updateScoresForWin(winner, gameState) {
    let values = computePlayerValues(gameState.players);
    let pot = 0;
    for (let i = 0; i < numPlayers; i++) {
        if (i !== winner) {
            let pay = values[i] * bet;
            pot += pay;
            scores[i] -= pay;
        }
    }
    scores[winner] += pot;
    nextGameStarter = winner;
    let message = `Normal win for Player ${getPlayerNumber(winner)}!\n\n`;
    message += `Player ${getPlayerNumber(winner)} wins ${abbreviate(pot)}\n\n`;
    for (let i = 0; i < numPlayers; i++) {
        if (i !== winner) {
            let pay = values[i] * bet;
            message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
        }
    }
    setTimeout(() => alert(message), 100);
}

function updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState) {
    let values = computePlayerValues(gameState.players);
    let minAll = Math.min(...values);
    let blockerValue = values[blocker];
    let totalValue = values.reduce((a, b) => a + b, 0);
    let payAmount = 2 * totalValue * bet;
    let message;
    if (blockerValue <= minAll) {
        // blocker wins, assistant pays to blocker
        scores[assistant] -= payAmount;
        scores[blocker] += payAmount;
        message = `Player ${getPlayerNumber(blocker)} wins block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
        message += `Player ${getPlayerNumber(assistant)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(blocker)}`;
    } else {
        // blocker loses, blocker pays to assistant
        scores[blocker] -= payAmount;
        scores[assistant] += payAmount;
        message = `Player ${getPlayerNumber(blocker)} loses block assisted by Player ${getPlayerNumber(assistant)}.\n\n`;
        message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(payAmount)} to Player ${getPlayerNumber(assistant)}`;
    }
    nextGameStarter = blocker;
    setTimeout(() => alert(message), 100);
}

function updateScoresForIntentionalBlockNoAssist(blocker, gameState) {
    let values = computePlayerValues(gameState.players);
    let blockerValue = values[blocker];
    let othersValues = values.filter((_, i) => i !== blocker);
    let minOthers = Math.min(...othersValues);
    let totalTransfer = othersValues.reduce((a, b) => a + b, 0) * 2 * bet;
    let message;
    if (blockerValue <= minOthers) {
        // Blocker wins
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                scores[i] -= pay;
                scores[blocker] += pay;
            }
        }
        message = `Player ${getPlayerNumber(blocker)} wins block!\n\n`;
        message += `Player ${getPlayerNumber(blocker)} receives ${abbreviate(totalTransfer)}\n\n`;
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                message += `Player ${getPlayerNumber(i)} pays ${abbreviate(pay)}\n`;
            }
        }
    } else {
        // Blocker loses
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                scores[blocker] -= pay;
                scores[i] += pay;
            }
        }
        message = `Player ${getPlayerNumber(blocker)} loses block!\n\n`;
        message += `Player ${getPlayerNumber(blocker)} pays ${abbreviate(totalTransfer)} total\n\n`;
        for (let i = 0; i < numPlayers; i++) {
            if (i !== blocker) {
                let pay = 2 * values[i] * bet;
                message += `Player ${getPlayerNumber(i)} receives ${abbreviate(pay)}\n`;
            }
        }
    }
    
    nextGameStarter = blocker;
    
    setTimeout(() => alert(message), 100);
}

function updateScoresForForceBlock(gameState) {
    let values = computePlayerValues(gameState.players);
    let minVal = Math.min(...values);
    let winners = [];
    let losers = [];
    for (let i = 0; i < numPlayers; i++) {
        if (values[i] === minVal) {
            winners.push(i);
        } else {
            losers.push(i);
        }
    }
    
    let message;
    if (winners.length === numPlayers) {
        // All tie
        message = `Force block! All players tie.\n\nNo payout.\nPlayer ${getPlayerNumber(nextGameStarter)} starts next game.`;
        nextGameStarter = playerOrder[(playerOrder.indexOf(lastValidPlayer) + 1) % numPlayers];
    } else {
        let total_pot = 0;
        losers.forEach(l => {
            let pay = values[l] * bet;
            scores[l] -= pay;
            total_pot += pay;
        });
        let share = total_pot / winners.length;
        winners.forEach(w => {
            scores[w] += share;
        });
        if (winners.length === 1) {
            nextGameStarter = winners[0];
            message = `Force block! Player ${getPlayerNumber(nextGameStarter)} has lowest hand.\n\n`;
            message += `Player ${getPlayerNumber(nextGameStarter)} wins ${abbreviate(total_pot)}\n\n`;
            losers.forEach(l => {
                let pay = values[l] * bet;
                message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
            });
        } else {
            nextGameStarter = playerOrder[(playerOrder.indexOf(lastValidPlayer) + 1) % numPlayers];
            message = `Force block! Tie between: ${winners.map(w => `Player ${getPlayerNumber(w)}`).join(', ')}\n\n`;
            message += `Winners share ${abbreviate(total_pot)} (${abbreviate(share)} each)\n\n`;
            losers.forEach(l => {
                let pay = values[l] * bet;
                message += `Player ${getPlayerNumber(l)} pays ${abbreviate(pay)}\n`;
            });
        }
    }
    setTimeout(() => alert(message), 100);
}

function handleNormalGameWin(gameState) {
    gameState.gameOver = true;
    updateScoresForWin(currentPlayer, gameState);
    renderGame(gameState);
    showNewGameButton();
}

function hasNonBlockingAlternative(hand, board, allPlayers, playerIndex) {
    if (!board.leftEnd) return true; // Before first move, game can't be blocked.

    for (const tile of hand) {
        const canPlayLeft = canPlayOnEnd(tile, board.leftEnd.value);
        const canPlayRight = canPlayOnEnd(tile, board.rightEnd.value);

        if (!canPlayLeft && !canPlayRight) {
            continue; 
        }

        if (canPlayLeft) {
            const simBoard = simulatePlay(board, tile, 'left');
            const simPlayers = JSON.parse(JSON.stringify(allPlayers));
            const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
            simPlayers[playerIndex].splice(tileIdx, 1);
            if (isPlayableForAnyone(simPlayers, simBoard)) {
                return true;
            }
        }
        
        if (canPlayRight && (!isDouble(tile) || !canPlayLeft)) {
             const simBoard = simulatePlay(board, tile, 'right');
             const simPlayers = JSON.parse(JSON.stringify(allPlayers));
             const tileIdx = simPlayers[playerIndex].findIndex(t => t.top === tile.top && t.bottom === tile.bottom);
             simPlayers[playerIndex].splice(tileIdx, 1);
             if (isPlayableForAnyone(simPlayers, simBoard)) {
                return true;
             }
        }
    }
    
    return false;
}

function handleBlockedGame(gameState, lastPlayerWhoPlayed, firstSkipped, lastPlayedTile, lastPlayedEnd) {
    gameState.gameOver = true;
    const { players, board, roundHistory } = gameState;
    
    const prevBoard = gameState.prevBoard;
    if (!prevBoard) {
        // First tile played, no intentional block possible
        updateScoresForForceBlock(gameState);
        renderGame(gameState);
        showNewGameButton();
        return;
    }
    
    // Reconstruct the hand before the play for last player
    const handBeforePlay = [...players[lastPlayerWhoPlayed], lastPlayedTile];
    
    // Check if last player had non-blocking alternative
    const lastHadAlternativeMove = hasNonBlockingAlternative(handBeforePlay, prevBoard, players, lastPlayerWhoPlayed);
    
    let blocker = lastPlayerWhoPlayed;
    let assistant = -1;
    
    if (lastHadAlternativeMove) {
        // Intentional by last
        // Check if immediate previous had alternative move
        if (roundHistory.length >= 2 && roundHistory[roundHistory.length - 2].hadAlternativeMove) {
            const prevPlayer = roundHistory[roundHistory.length - 2].player;
            if (prevPlayer === getPreviousPlayer(lastPlayerWhoPlayed)) {
                assistant = prevPlayer;
            }
        }
        if (assistant !== -1) {
            updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState);
        } else {
            updateScoresForIntentionalBlockNoAssist(blocker, gameState);
        }
    } else {
        // Last had no alternative, search for remote
        let remote = -1;
        let remoteIndex = -1;
        for (let i = roundHistory.length - 2; i >= 0; i--) {
            if (roundHistory[i].hadAlternativeMove) {
                remote = roundHistory[i].player;
                remoteIndex = i;
                break;
            }
        }
        if (remote !== -1) {
            if (remoteIndex === roundHistory.length - 2 && remote === getPreviousPlayer(lastPlayerWhoPlayed)) {
                // Immediate previous, assisted case
                blocker = remote;
                assistant = lastPlayerWhoPlayed;
                updateScoresForIntentionalBlockWithAssist(blocker, assistant, gameState);
            } else {
                // Further, no assist
                blocker = remote;
                updateScoresForIntentionalBlockNoAssist(blocker, gameState);
            }
        } else {
            // Force block
            updateScoresForForceBlock(gameState);
        }
    }
    
    renderGame(gameState);
    showNewGameButton();
}

function getPlayerNumber(index) {
    return index + 1;
}

function showNewGameButton() {
    const newGameBtn = document.getElementById('new-game');
    newGameBtn.style.display = 'block';
    newGameBtn.onclick = () => {
        initAudioContext();
        newGameBtn.style.display = 'none';
        gameState = setupGame();
        renderGame(gameState);
        if (!gameState.gameOver && currentPlayer !== 0) {
            setTimeout(() => playAI(gameState), 1500);
        }
    };
}

function renderGame(gameState) {
    const {players, board, gameOver, selectedIndex} = gameState;
    const tableDiv = document.getElementById('table');
    
    tableDiv.innerHTML = '';
    board.tiles.forEach(({tile, x, y, isHorizontal}, index) => {
        const tileDiv = document.createElement('div');
        tileDiv.className = 'table-tile';
        if (isHorizontal) tileDiv.classList.add('horizontal');
        if (board.tiles.length === 1 && index === 0 && isDouble(tile)) {
            tileDiv.classList.add('first-double');
        }
        
        if (!gameOver) {
            let isLeftEnd = index === (board.leftEnd ? board.leftEnd.tileIndex : -1);
            let isRightEnd = index === (board.rightEnd ? board.rightEnd.tileIndex : -1);
            let isDoubleEnd = isDouble(tile); // Check if end tile is double
            if (isLeftEnd) {
                const openSide = board.leftEnd.openSide;
                if (isHorizontal) {
                    if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
                    else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
                } else {
                    if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
                    else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
                }
            }
            if (isRightEnd) {
                const openSide = board.rightEnd.openSide;
                if (isHorizontal) {
                    if (openSide === 'left') tileDiv.classList.add(isDoubleEnd ? 'double-end-left' : 'end-left');
                    else if (openSide === 'right') tileDiv.classList.add(isDoubleEnd ? 'double-end-right' : 'end-right');
                } else {
                    if (openSide === 'up') tileDiv.classList.add(isDoubleEnd ? 'double-end-top' : 'end-top');
                    else if (openSide === 'down') tileDiv.classList.add(isDoubleEnd ? 'double-end-bottom' : 'end-bottom');
                }
            }
        }
        
        let tileData = isHorizontal ? { left: tile.bottom, right: tile.top } : tile;
        tileDiv.innerHTML = generateTileSvg(isHorizontal, tileData);
        tileDiv.style.left = `${x + board.offsetX}px`;
        tileDiv.style.top = `${y + board.offsetY}px`;
        tableDiv.appendChild(tileDiv);
    });

    let leftPlaceholder = null;
    let rightPlaceholder = null;

    if (!gameOver && currentPlayer === 0 && board.tiles.length > 0) {
        const dummyTile = {top: 0, bottom: 0};
        const tableRect = tableDiv.getBoundingClientRect();
        const hand = players[0];

        if (hand.some(tile => canPlayOnEnd(tile, board.leftEnd.value))) {
            const leftPlacement = calculatePlacement(board, 'left', tableRect, dummyTile);
            leftPlaceholder = document.createElement('div');
            leftPlaceholder.className = 'table-tile placeholder';
            if (leftPlacement.isHorizontal) leftPlaceholder.classList.add('horizontal');
            leftPlaceholder.style.left = `${leftPlacement.x + board.offsetX}px`;
            leftPlaceholder.style.top = `${leftPlacement.y + board.offsetY}px`;
            leftPlaceholder.style.border = '2px dashed #6a6a6a';
            tableDiv.appendChild(leftPlaceholder);

            leftPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.leftEnd.value)) leftPlaceholder.style.border = '2px dashed yellow'; };
            leftPlaceholder.ondragleave = () => { leftPlaceholder.style.border = '2px dashed #6a6a6a'; };
            leftPlaceholder.ondrop = (e) => { e.preventDefault(); leftPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.leftEnd.value)) playTile(gameState, tileData, 'left'); } catch (err) {} };
            leftPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.leftEnd.value)) playTile(gameState, selectedTile, 'left'); } };
        }

        if (hand.some(tile => canPlayOnEnd(tile, board.rightEnd.value))) {
            const rightPlacement = calculatePlacement(board, 'right', tableRect, dummyTile);
            rightPlaceholder = document.createElement('div');
            rightPlaceholder.className = 'table-tile placeholder';
            if (rightPlacement.isHorizontal) rightPlaceholder.classList.add('horizontal');
            rightPlaceholder.style.left = `${rightPlacement.x + board.offsetX}px`;
            rightPlaceholder.style.top = `${rightPlacement.y + board.offsetY}px`;
            rightPlaceholder.style.border = '2px dashed #6a6a6a';
            tableDiv.appendChild(rightPlaceholder);

            rightPlaceholder.ondragover = (e) => { e.preventDefault(); if (draggedTile && canPlayOnEnd(draggedTile, board.rightEnd.value)) rightPlaceholder.style.border = '2px dashed yellow'; };
            rightPlaceholder.ondragleave = () => { rightPlaceholder.style.border = '2px dashed #6a6a6a'; };
            rightPlaceholder.ondrop = (e) => { e.preventDefault(); rightPlaceholder.style.border = '2px dashed #6a6a6a'; try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); if (canPlayOnEnd(tileData, board.rightEnd.value)) playTile(gameState, tileData, 'right'); } catch (err) {} };
            rightPlaceholder.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; if (canPlayOnEnd(selectedTile, board.rightEnd.value)) playTile(gameState, selectedTile, 'right'); } };
        }
    }

    if (!gameOver && currentPlayer === 0) {
        if (board.tiles.length === 0) {
            tableDiv.ondragover = (e) => e.preventDefault();
            tableDiv.ondrop = (e) => { e.preventDefault(); try { const tileData = JSON.parse(e.dataTransfer.getData('text/plain')); playTile(gameState, tileData, 'right'); } catch (err) {} };
            tableDiv.onclick = () => { if (gameState.selectedIndex !== -1) { const selectedTile = players[0][gameState.selectedIndex]; playTile(gameState, selectedTile, 'right'); } };
        }
    }

    document.querySelectorAll('.player-hand').forEach((hand, index) => {
        hand.innerHTML = '';
        const scoreDiv = document.createElement('div');
        scoreDiv.className = 'score';
        scoreDiv.innerHTML = `<span class="score-arrow">${!gameOver && index === currentPlayer ? '➤' : ''}</span><span class="score-text">[P${getPlayerNumber(index)}]</span><div class="score-number"><div class="coins-container">${' <span class="coin">🪙</span>'.repeat(3)}</div><span class="score-text" style="position: absolute; top: 50%; left: 50%; transform: translate(calc(-50% - 10px), calc(-50% + 3px)); z-index: 2; color: black;">${scores[index] < 0 ? '-' + abbreviate(-scores[index]) : abbreviate(scores[index])}</span></div>`;
        const tilesContainer = document.createElement('div');
        tilesContainer.className = 'tiles-container';
        let playButtons;
        
        let highestDoubleInHand = null;
        if (!gameOver && index === 0 && board.tiles.length === 0) {
            const doubles = players[0].filter(t => isDouble(t));
            if (doubles.length > 0) {
                highestDoubleInHand = doubles.reduce((max, t) => t.top > max.top ? t : max, doubles[0]);
            }
        }

        if (!gameOver && index === 0) { 
            playButtons = document.createElement('div');
            playButtons.className = 'play-buttons';
            playButtons.innerHTML = `<button class="play-left">Play Left</button><button class="play-right">Play Right</button>`;
            playButtons.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
        }
        
        players[index].forEach((tile, tileIdx) => {
            const tileDiv = document.createElement('div');
            tileDiv.className = 'tile';
            if (!gameOver && index !== 0 && tileMode === 'Close') {
                tileDiv.innerHTML = generateBackTileSvg(false);
            } else {
                tileDiv.innerHTML = generateTileSvg(false, tile);
                tileDiv.dataset.top = tile.top;
                tileDiv.dataset.bottom = tile.bottom;
                
                if (!gameOver && index === 0) {
                    let isPlayable = false;
                    if (board.tiles.length === 0) {
                        if (highestDoubleInHand) {
                            if (tile.top === highestDoubleInHand.top && tile.bottom === highestDoubleInHand.bottom) {
                                isPlayable = true;
                            }
                        } else {
                            isPlayable = true;
                        }
                    } else {
                        isPlayable = canPlayTile(tile, board);
                    }

                    if (isPlayable && currentPlayer === 0) {
                        tileDiv.classList.add('draggable');
                        tileDiv.draggable = true;
                        tileDiv.ondragstart = (e) => { 
                            initAudioContext(); 
                            canPlaySound = true; 
                            draggedTile = tile; 
                            e.dataTransfer.setData('text/plain', JSON.stringify(tile)); 
                        };
                        tileDiv.addEventListener('touchstart', (e) => {
                            initAudioContext();
                            canPlaySound = true;
                            draggedTile = tile;
                            const touch = e.touches[0];
                            const ghost = tileDiv.cloneNode(true);
                            ghost.style.position = 'fixed';
                            ghost.style.pointerEvents = 'none';
                            ghost.style.zIndex = 1000;
                            document.body.appendChild(ghost);
                            ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
                            ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;
                            let moved = false;
                            const onTouchMove = (ev) => {
                                ev.preventDefault(); // This is the fix for drag sensitivity
                                if (ev.touches.length === 1) {
                                    moved = true;
                                    const t = ev.touches[0];
                                    ghost.style.left = `${t.clientX - ghost.offsetWidth / 2}px`;
                                    ghost.style.top = `${t.clientY - ghost.offsetHeight / 2}px`;
                                    if (board.tiles.length > 0) {
                                        if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                                        if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                                        const dropX = t.clientX;
                                        const dropY = t.clientY;
                                        if (leftPlaceholder) {
                                            const leftRect = leftPlaceholder.getBoundingClientRect();
                                            if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                                                if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                                                    leftPlaceholder.style.border = '2px dashed yellow';
                                                }
                                            }
                                        }
                                        if (rightPlaceholder) {
                                            const rightRect = rightPlaceholder.getBoundingClientRect();
                                            if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                                                if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                                                    rightPlaceholder.style.border = '2px dashed yellow';
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                            const onTouchEnd = (ev) => {
                                document.removeEventListener('touchmove', onTouchMove);
                                document.removeEventListener('touchend', onTouchEnd);
                                ghost.remove();
                                if (board.tiles.length > 0) {
                                    if (leftPlaceholder) leftPlaceholder.style.border = '2px dashed #6a6a6a';
                                    if (rightPlaceholder) rightPlaceholder.style.border = '2px dashed #6a6a6a';
                                }
                                if (!moved) {
                                    draggedTile = null;
                                    return;
                                }
                                if (moved) {
                                    tileDiv.dataset.justMoved = 'true';
                                }
                                const dropTouch = ev.changedTouches[0] || {clientX: 0, clientY: 0};
                                let dropped = false;
                                const dropX = dropTouch.clientX;
                                const dropY = dropTouch.clientY;
                                if (board.tiles.length === 0) {
                                    const tableRect = tableDiv.getBoundingClientRect();
                                    if (dropX > tableRect.left && dropX < tableRect.right && dropY > tableRect.top && dropY < tableRect.bottom) {
                                        playTile(gameState, draggedTile, 'right');
                                        dropped = true;
                                    }
                                } else {
                                    if (leftPlaceholder) {
                                        const leftRect = leftPlaceholder.getBoundingClientRect();
                                        if (dropX > leftRect.left && dropX < leftRect.right && dropY > leftRect.top && dropY < leftRect.bottom) {
                                            if (canPlayOnEnd(draggedTile, board.leftEnd.value)) {
                                                playTile(gameState, draggedTile, 'left');
                                                dropped = true;
                                            }
                                        }
                                    }
                                    if (rightPlaceholder) {
                                        const rightRect = rightPlaceholder.getBoundingClientRect();
                                        if (dropX > rightRect.left && dropX < rightRect.right && dropY > rightRect.top && dropY < rightRect.bottom) {
                                            if (canPlayOnEnd(draggedTile, board.rightEnd.value)) {
                                                playTile(gameState, draggedTile, 'right');
                                                dropped = true;
                                            }
                                        }
                                    }
                                }
                                draggedTile = null;
                            };
                            document.addEventListener('touchmove', onTouchMove, {passive: false});
                            document.addEventListener('touchend', onTouchEnd, {passive: false});
                        });
                    }
                    
                    tileDiv.onclick = (e) => { if (isPlayable) { initAudioContext(); canPlaySound = true; e.stopPropagation(); if (tileDiv.dataset.justMoved === 'true') { delete tileDiv.dataset.justMoved; return; } handleTileClick(gameState, tileIdx, playButtons); } };
                    if (selectedIndex === tileIdx) tileDiv.classList.add('selected');
                }
            }
            tilesContainer.appendChild(tileDiv);
        });
        
        if (index === 2) { hand.appendChild(tilesContainer); hand.appendChild(scoreDiv); } 
        else if (index === 0) { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); } 
        else { hand.appendChild(scoreDiv); hand.appendChild(tilesContainer); }
        
        if (playButtons) {
            hand.appendChild(playButtons);
            if (selectedIndex !== -1) {
                const selectedTileData = players[0][selectedIndex];
                const leftBtn = playButtons.querySelector('.play-left');
                const rightBtn = playButtons.querySelector('.play-right');
                leftBtn.style.display = 'none';
                rightBtn.style.display = 'none';

                if (board.tiles.length === 0) {
                    if (highestDoubleInHand ? (selectedTileData.top === highestDoubleInHand.top && selectedTileData.bottom === highestDoubleInHand.bottom) : true) {
                        rightBtn.style.display = 'inline-block';
                        rightBtn.textContent = `Play First`;
                        rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                    }
                } else {
                    const leftEnd = board.leftEnd.value;
                    const rightEnd = board.rightEnd.value;
                    if (canPlayOnEnd(selectedTileData, leftEnd)) {
                        leftBtn.style.display = 'inline-block';
                        leftBtn.textContent = `Play Left (${leftEnd})`;
                        leftBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'left'); };
                    }
                    if (canPlayOnEnd(selectedTileData, rightEnd)) {
                        rightBtn.style.display = 'inline-block';
                        rightBtn.textContent = `Play Right (${rightEnd})`;
                        rightBtn.onclick = () => { const currentSelected = players[0][gameState.selectedIndex]; playTile(gameState, currentSelected, 'right'); };
                    }
                }
            }
        }
    });
}

let gameState = setupGame();
renderGame(gameState);
document.getElementById('tileMode').addEventListener('change', function(e) {
    tileMode = e.target.value;
    renderGame(gameState);
});
document.getElementById('bets').addEventListener('change', function(e) {
    bet = parseInt(e.target.value);
});
document.addEventListener('click', () => {
    initAudioContext();
    canPlaySound = true;
}, {once: true});
// Optional: Show a brief prompt if AI starts first
if (!gameState.gameOver && currentPlayer !== 0) {
    const prompt = document.createElement('div');
    prompt.id = 'aiPrompt';
    prompt.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0, 255, 0, 0.8); color: black; padding: 20px; border-radius: 10px;
        z-index: 1000; font-size: 18px; text-align: center;
    `;
    prompt.textContent = 'Click/Touch anywhere to start AI turn';
    document.body.appendChild(prompt);

    const startAIGame = () => {
        document.removeEventListener('click', startAIGame);
        initAudioContext();
        prompt.style.display = 'none';  // Hide prompt
        playAI(gameState);
    };
    document.addEventListener('click', startAIGame, {once: true});
}
</script>
</body>
</html>